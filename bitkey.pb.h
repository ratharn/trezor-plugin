// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: bitkey.proto

#ifndef PROTOBUF_bitkey_2eproto__INCLUDED
#define PROTOBUF_bitkey_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2004000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2004001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_message_reflection.h>
// @@protoc_insertion_point(includes)

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_bitkey_2eproto();
void protobuf_AssignDesc_bitkey_2eproto();
void protobuf_ShutdownFile_bitkey_2eproto();

class Initialize;
class Features;
class Ping;
class DebugLinkDecision;
class DebugLinkGetState;
class DebugLinkState;
class Success;
class Failure;
class GetUUID;
class UUID;
class ButtonRequest;
class ButtonAck;
class ButtonCancel;
class OtpRequest;
class OtpAck;
class OtpCancel;
class PinRequest;
class PinAck;
class PinCancel;
class GetEntropy;
class Entropy;
class SetMaxFeeKb;
class GetMasterPublicKey;
class MasterPublicKey;
class GetAddress;
class Address;
class LoadDevice;
class ResetDevice;
class SignTx;
class TxRequest;
class TxInput;
class TxOutput;

enum Algorithm {
  BIP32 = 0,
  ELECTRUM = 1
};
bool Algorithm_IsValid(int value);
const Algorithm Algorithm_MIN = BIP32;
const Algorithm Algorithm_MAX = ELECTRUM;
const int Algorithm_ARRAYSIZE = Algorithm_MAX + 1;

const ::google::protobuf::EnumDescriptor* Algorithm_descriptor();
inline const ::std::string& Algorithm_Name(Algorithm value) {
  return ::google::protobuf::internal::NameOfEnum(
    Algorithm_descriptor(), value);
}
inline bool Algorithm_Parse(
    const ::std::string& name, Algorithm* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Algorithm>(
    Algorithm_descriptor(), name, value);
}
enum ScriptType {
  PAYTOADDRESS = 0,
  PAYTOSCRIPTHASH = 1
};
bool ScriptType_IsValid(int value);
const ScriptType ScriptType_MIN = PAYTOADDRESS;
const ScriptType ScriptType_MAX = PAYTOSCRIPTHASH;
const int ScriptType_ARRAYSIZE = ScriptType_MAX + 1;

const ::google::protobuf::EnumDescriptor* ScriptType_descriptor();
inline const ::std::string& ScriptType_Name(ScriptType value) {
  return ::google::protobuf::internal::NameOfEnum(
    ScriptType_descriptor(), value);
}
inline bool ScriptType_Parse(
    const ::std::string& name, ScriptType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ScriptType>(
    ScriptType_descriptor(), name, value);
}
enum RequestType {
  TXINPUT = 0,
  TXOUTPUT = 1
};
bool RequestType_IsValid(int value);
const RequestType RequestType_MIN = TXINPUT;
const RequestType RequestType_MAX = TXOUTPUT;
const int RequestType_ARRAYSIZE = RequestType_MAX + 1;

const ::google::protobuf::EnumDescriptor* RequestType_descriptor();
inline const ::std::string& RequestType_Name(RequestType value) {
  return ::google::protobuf::internal::NameOfEnum(
    RequestType_descriptor(), value);
}
inline bool RequestType_Parse(
    const ::std::string& name, RequestType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<RequestType>(
    RequestType_descriptor(), name, value);
}
// ===================================================================

class Initialize : public ::google::protobuf::Message {
 public:
  Initialize();
  virtual ~Initialize();
  
  Initialize(const Initialize& from);
  
  inline Initialize& operator=(const Initialize& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Initialize& default_instance();
  
  void Swap(Initialize* other);
  
  // implements Message ----------------------------------------------
  
  Initialize* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Initialize& from);
  void MergeFrom(const Initialize& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required bytes session_id = 1;
  inline bool has_session_id() const;
  inline void clear_session_id();
  static const int kSessionIdFieldNumber = 1;
  inline const ::std::string& session_id() const;
  inline void set_session_id(const ::std::string& value);
  inline void set_session_id(const char* value);
  inline void set_session_id(const void* value, size_t size);
  inline ::std::string* mutable_session_id();
  inline ::std::string* release_session_id();
  
  // @@protoc_insertion_point(class_scope:Initialize)
 private:
  inline void set_has_session_id();
  inline void clear_has_session_id();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* session_id_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_bitkey_2eproto();
  friend void protobuf_AssignDesc_bitkey_2eproto();
  friend void protobuf_ShutdownFile_bitkey_2eproto();
  
  void InitAsDefaultInstance();
  static Initialize* default_instance_;
};
// -------------------------------------------------------------------

class Features : public ::google::protobuf::Message {
 public:
  Features();
  virtual ~Features();
  
  Features(const Features& from);
  
  inline Features& operator=(const Features& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Features& default_instance();
  
  void Swap(Features* other);
  
  // implements Message ----------------------------------------------
  
  Features* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Features& from);
  void MergeFrom(const Features& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional bytes session_id = 1;
  inline bool has_session_id() const;
  inline void clear_session_id();
  static const int kSessionIdFieldNumber = 1;
  inline const ::std::string& session_id() const;
  inline void set_session_id(const ::std::string& value);
  inline void set_session_id(const char* value);
  inline void set_session_id(const void* value, size_t size);
  inline ::std::string* mutable_session_id();
  inline ::std::string* release_session_id();
  
  // optional string vendor = 2;
  inline bool has_vendor() const;
  inline void clear_vendor();
  static const int kVendorFieldNumber = 2;
  inline const ::std::string& vendor() const;
  inline void set_vendor(const ::std::string& value);
  inline void set_vendor(const char* value);
  inline void set_vendor(const char* value, size_t size);
  inline ::std::string* mutable_vendor();
  inline ::std::string* release_vendor();
  
  // optional uint32 major_version = 3;
  inline bool has_major_version() const;
  inline void clear_major_version();
  static const int kMajorVersionFieldNumber = 3;
  inline ::google::protobuf::uint32 major_version() const;
  inline void set_major_version(::google::protobuf::uint32 value);
  
  // optional uint32 minor_version = 4;
  inline bool has_minor_version() const;
  inline void clear_minor_version();
  static const int kMinorVersionFieldNumber = 4;
  inline ::google::protobuf::uint32 minor_version() const;
  inline void set_minor_version(::google::protobuf::uint32 value);
  
  // optional bool has_otp = 5;
  inline bool has_has_otp() const;
  inline void clear_has_otp();
  static const int kHasOtpFieldNumber = 5;
  inline bool has_otp() const;
  inline void set_has_otp(bool value);
  
  // optional bool has_spv = 6;
  inline bool has_has_spv() const;
  inline void clear_has_spv();
  static const int kHasSpvFieldNumber = 6;
  inline bool has_spv() const;
  inline void set_has_spv(bool value);
  
  // optional bool pin = 7;
  inline bool has_pin() const;
  inline void clear_pin();
  static const int kPinFieldNumber = 7;
  inline bool pin() const;
  inline void set_pin(bool value);
  
  // optional .Algorithm algo = 8;
  inline bool has_algo() const;
  inline void clear_algo();
  static const int kAlgoFieldNumber = 8;
  inline Algorithm algo() const;
  inline void set_algo(Algorithm value);
  
  // repeated .Algorithm algo_available = 9;
  inline int algo_available_size() const;
  inline void clear_algo_available();
  static const int kAlgoAvailableFieldNumber = 9;
  inline Algorithm algo_available(int index) const;
  inline void set_algo_available(int index, Algorithm value);
  inline void add_algo_available(Algorithm value);
  inline const ::google::protobuf::RepeatedField<int>& algo_available() const;
  inline ::google::protobuf::RepeatedField<int>* mutable_algo_available();
  
  // optional uint64 maxfee_kb = 10;
  inline bool has_maxfee_kb() const;
  inline void clear_maxfee_kb();
  static const int kMaxfeeKbFieldNumber = 10;
  inline ::google::protobuf::uint64 maxfee_kb() const;
  inline void set_maxfee_kb(::google::protobuf::uint64 value);
  
  // @@protoc_insertion_point(class_scope:Features)
 private:
  inline void set_has_session_id();
  inline void clear_has_session_id();
  inline void set_has_vendor();
  inline void clear_has_vendor();
  inline void set_has_major_version();
  inline void clear_has_major_version();
  inline void set_has_minor_version();
  inline void clear_has_minor_version();
  inline void set_has_has_otp();
  inline void clear_has_has_otp();
  inline void set_has_has_spv();
  inline void clear_has_has_spv();
  inline void set_has_pin();
  inline void clear_has_pin();
  inline void set_has_algo();
  inline void clear_has_algo();
  inline void set_has_maxfee_kb();
  inline void clear_has_maxfee_kb();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* session_id_;
  ::std::string* vendor_;
  ::google::protobuf::uint32 major_version_;
  ::google::protobuf::uint32 minor_version_;
  bool has_otp_;
  bool has_spv_;
  bool pin_;
  int algo_;
  ::google::protobuf::RepeatedField<int> algo_available_;
  ::google::protobuf::uint64 maxfee_kb_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(10 + 31) / 32];
  
  friend void  protobuf_AddDesc_bitkey_2eproto();
  friend void protobuf_AssignDesc_bitkey_2eproto();
  friend void protobuf_ShutdownFile_bitkey_2eproto();
  
  void InitAsDefaultInstance();
  static Features* default_instance_;
};
// -------------------------------------------------------------------

class Ping : public ::google::protobuf::Message {
 public:
  Ping();
  virtual ~Ping();
  
  Ping(const Ping& from);
  
  inline Ping& operator=(const Ping& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Ping& default_instance();
  
  void Swap(Ping* other);
  
  // implements Message ----------------------------------------------
  
  Ping* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Ping& from);
  void MergeFrom(const Ping& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional string message = 1;
  inline bool has_message() const;
  inline void clear_message();
  static const int kMessageFieldNumber = 1;
  inline const ::std::string& message() const;
  inline void set_message(const ::std::string& value);
  inline void set_message(const char* value);
  inline void set_message(const char* value, size_t size);
  inline ::std::string* mutable_message();
  inline ::std::string* release_message();
  
  // @@protoc_insertion_point(class_scope:Ping)
 private:
  inline void set_has_message();
  inline void clear_has_message();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* message_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_bitkey_2eproto();
  friend void protobuf_AssignDesc_bitkey_2eproto();
  friend void protobuf_ShutdownFile_bitkey_2eproto();
  
  void InitAsDefaultInstance();
  static Ping* default_instance_;
};
// -------------------------------------------------------------------

class DebugLinkDecision : public ::google::protobuf::Message {
 public:
  DebugLinkDecision();
  virtual ~DebugLinkDecision();
  
  DebugLinkDecision(const DebugLinkDecision& from);
  
  inline DebugLinkDecision& operator=(const DebugLinkDecision& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const DebugLinkDecision& default_instance();
  
  void Swap(DebugLinkDecision* other);
  
  // implements Message ----------------------------------------------
  
  DebugLinkDecision* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DebugLinkDecision& from);
  void MergeFrom(const DebugLinkDecision& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required bool yes_no = 1;
  inline bool has_yes_no() const;
  inline void clear_yes_no();
  static const int kYesNoFieldNumber = 1;
  inline bool yes_no() const;
  inline void set_yes_no(bool value);
  
  // @@protoc_insertion_point(class_scope:DebugLinkDecision)
 private:
  inline void set_has_yes_no();
  inline void clear_has_yes_no();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  bool yes_no_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_bitkey_2eproto();
  friend void protobuf_AssignDesc_bitkey_2eproto();
  friend void protobuf_ShutdownFile_bitkey_2eproto();
  
  void InitAsDefaultInstance();
  static DebugLinkDecision* default_instance_;
};
// -------------------------------------------------------------------

class DebugLinkGetState : public ::google::protobuf::Message {
 public:
  DebugLinkGetState();
  virtual ~DebugLinkGetState();
  
  DebugLinkGetState(const DebugLinkGetState& from);
  
  inline DebugLinkGetState& operator=(const DebugLinkGetState& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const DebugLinkGetState& default_instance();
  
  void Swap(DebugLinkGetState* other);
  
  // implements Message ----------------------------------------------
  
  DebugLinkGetState* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DebugLinkGetState& from);
  void MergeFrom(const DebugLinkGetState& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional bool layout = 1;
  inline bool has_layout() const;
  inline void clear_layout();
  static const int kLayoutFieldNumber = 1;
  inline bool layout() const;
  inline void set_layout(bool value);
  
  // optional bool otp = 2;
  inline bool has_otp() const;
  inline void clear_otp();
  static const int kOtpFieldNumber = 2;
  inline bool otp() const;
  inline void set_otp(bool value);
  
  // optional bool pin = 3;
  inline bool has_pin() const;
  inline void clear_pin();
  static const int kPinFieldNumber = 3;
  inline bool pin() const;
  inline void set_pin(bool value);
  
  // optional bool seed = 4;
  inline bool has_seed() const;
  inline void clear_seed();
  static const int kSeedFieldNumber = 4;
  inline bool seed() const;
  inline void set_seed(bool value);
  
  // @@protoc_insertion_point(class_scope:DebugLinkGetState)
 private:
  inline void set_has_layout();
  inline void clear_has_layout();
  inline void set_has_otp();
  inline void clear_has_otp();
  inline void set_has_pin();
  inline void clear_has_pin();
  inline void set_has_seed();
  inline void clear_has_seed();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  bool layout_;
  bool otp_;
  bool pin_;
  bool seed_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  friend void  protobuf_AddDesc_bitkey_2eproto();
  friend void protobuf_AssignDesc_bitkey_2eproto();
  friend void protobuf_ShutdownFile_bitkey_2eproto();
  
  void InitAsDefaultInstance();
  static DebugLinkGetState* default_instance_;
};
// -------------------------------------------------------------------

class DebugLinkState : public ::google::protobuf::Message {
 public:
  DebugLinkState();
  virtual ~DebugLinkState();
  
  DebugLinkState(const DebugLinkState& from);
  
  inline DebugLinkState& operator=(const DebugLinkState& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const DebugLinkState& default_instance();
  
  void Swap(DebugLinkState* other);
  
  // implements Message ----------------------------------------------
  
  DebugLinkState* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DebugLinkState& from);
  void MergeFrom(const DebugLinkState& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional bytes layout = 1;
  inline bool has_layout() const;
  inline void clear_layout();
  static const int kLayoutFieldNumber = 1;
  inline const ::std::string& layout() const;
  inline void set_layout(const ::std::string& value);
  inline void set_layout(const char* value);
  inline void set_layout(const void* value, size_t size);
  inline ::std::string* mutable_layout();
  inline ::std::string* release_layout();
  
  // optional .OtpAck otp = 2;
  inline bool has_otp() const;
  inline void clear_otp();
  static const int kOtpFieldNumber = 2;
  inline const ::OtpAck& otp() const;
  inline ::OtpAck* mutable_otp();
  inline ::OtpAck* release_otp();
  
  // optional .PinAck pin = 3;
  inline bool has_pin() const;
  inline void clear_pin();
  static const int kPinFieldNumber = 3;
  inline const ::PinAck& pin() const;
  inline ::PinAck* mutable_pin();
  inline ::PinAck* release_pin();
  
  // optional string seed = 4;
  inline bool has_seed() const;
  inline void clear_seed();
  static const int kSeedFieldNumber = 4;
  inline const ::std::string& seed() const;
  inline void set_seed(const ::std::string& value);
  inline void set_seed(const char* value);
  inline void set_seed(const char* value, size_t size);
  inline ::std::string* mutable_seed();
  inline ::std::string* release_seed();
  
  // @@protoc_insertion_point(class_scope:DebugLinkState)
 private:
  inline void set_has_layout();
  inline void clear_has_layout();
  inline void set_has_otp();
  inline void clear_has_otp();
  inline void set_has_pin();
  inline void clear_has_pin();
  inline void set_has_seed();
  inline void clear_has_seed();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* layout_;
  ::OtpAck* otp_;
  ::PinAck* pin_;
  ::std::string* seed_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  friend void  protobuf_AddDesc_bitkey_2eproto();
  friend void protobuf_AssignDesc_bitkey_2eproto();
  friend void protobuf_ShutdownFile_bitkey_2eproto();
  
  void InitAsDefaultInstance();
  static DebugLinkState* default_instance_;
};
// -------------------------------------------------------------------

class Success : public ::google::protobuf::Message {
 public:
  Success();
  virtual ~Success();
  
  Success(const Success& from);
  
  inline Success& operator=(const Success& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Success& default_instance();
  
  void Swap(Success* other);
  
  // implements Message ----------------------------------------------
  
  Success* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Success& from);
  void MergeFrom(const Success& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional string message = 1;
  inline bool has_message() const;
  inline void clear_message();
  static const int kMessageFieldNumber = 1;
  inline const ::std::string& message() const;
  inline void set_message(const ::std::string& value);
  inline void set_message(const char* value);
  inline void set_message(const char* value, size_t size);
  inline ::std::string* mutable_message();
  inline ::std::string* release_message();
  
  // @@protoc_insertion_point(class_scope:Success)
 private:
  inline void set_has_message();
  inline void clear_has_message();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* message_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_bitkey_2eproto();
  friend void protobuf_AssignDesc_bitkey_2eproto();
  friend void protobuf_ShutdownFile_bitkey_2eproto();
  
  void InitAsDefaultInstance();
  static Success* default_instance_;
};
// -------------------------------------------------------------------

class Failure : public ::google::protobuf::Message {
 public:
  Failure();
  virtual ~Failure();
  
  Failure(const Failure& from);
  
  inline Failure& operator=(const Failure& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Failure& default_instance();
  
  void Swap(Failure* other);
  
  // implements Message ----------------------------------------------
  
  Failure* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Failure& from);
  void MergeFrom(const Failure& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional int32 code = 1;
  inline bool has_code() const;
  inline void clear_code();
  static const int kCodeFieldNumber = 1;
  inline ::google::protobuf::int32 code() const;
  inline void set_code(::google::protobuf::int32 value);
  
  // optional string message = 2;
  inline bool has_message() const;
  inline void clear_message();
  static const int kMessageFieldNumber = 2;
  inline const ::std::string& message() const;
  inline void set_message(const ::std::string& value);
  inline void set_message(const char* value);
  inline void set_message(const char* value, size_t size);
  inline ::std::string* mutable_message();
  inline ::std::string* release_message();
  
  // @@protoc_insertion_point(class_scope:Failure)
 private:
  inline void set_has_code();
  inline void clear_has_code();
  inline void set_has_message();
  inline void clear_has_message();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* message_;
  ::google::protobuf::int32 code_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_bitkey_2eproto();
  friend void protobuf_AssignDesc_bitkey_2eproto();
  friend void protobuf_ShutdownFile_bitkey_2eproto();
  
  void InitAsDefaultInstance();
  static Failure* default_instance_;
};
// -------------------------------------------------------------------

class GetUUID : public ::google::protobuf::Message {
 public:
  GetUUID();
  virtual ~GetUUID();
  
  GetUUID(const GetUUID& from);
  
  inline GetUUID& operator=(const GetUUID& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const GetUUID& default_instance();
  
  void Swap(GetUUID* other);
  
  // implements Message ----------------------------------------------
  
  GetUUID* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetUUID& from);
  void MergeFrom(const GetUUID& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // @@protoc_insertion_point(class_scope:GetUUID)
 private:
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];
  
  friend void  protobuf_AddDesc_bitkey_2eproto();
  friend void protobuf_AssignDesc_bitkey_2eproto();
  friend void protobuf_ShutdownFile_bitkey_2eproto();
  
  void InitAsDefaultInstance();
  static GetUUID* default_instance_;
};
// -------------------------------------------------------------------

class UUID : public ::google::protobuf::Message {
 public:
  UUID();
  virtual ~UUID();
  
  UUID(const UUID& from);
  
  inline UUID& operator=(const UUID& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const UUID& default_instance();
  
  void Swap(UUID* other);
  
  // implements Message ----------------------------------------------
  
  UUID* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UUID& from);
  void MergeFrom(const UUID& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required bytes UUID = 1;
  inline bool has_uuid() const;
  inline void clear_uuid();
  static const int kUUIDFieldNumber = 1;
  inline const ::std::string& uuid() const;
  inline void set_uuid(const ::std::string& value);
  inline void set_uuid(const char* value);
  inline void set_uuid(const void* value, size_t size);
  inline ::std::string* mutable_uuid();
  inline ::std::string* release_uuid();
  
  // @@protoc_insertion_point(class_scope:UUID)
 private:
  inline void set_has_uuid();
  inline void clear_has_uuid();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* uuid_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_bitkey_2eproto();
  friend void protobuf_AssignDesc_bitkey_2eproto();
  friend void protobuf_ShutdownFile_bitkey_2eproto();
  
  void InitAsDefaultInstance();
  static UUID* default_instance_;
};
// -------------------------------------------------------------------

class ButtonRequest : public ::google::protobuf::Message {
 public:
  ButtonRequest();
  virtual ~ButtonRequest();
  
  ButtonRequest(const ButtonRequest& from);
  
  inline ButtonRequest& operator=(const ButtonRequest& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ButtonRequest& default_instance();
  
  void Swap(ButtonRequest* other);
  
  // implements Message ----------------------------------------------
  
  ButtonRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ButtonRequest& from);
  void MergeFrom(const ButtonRequest& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // @@protoc_insertion_point(class_scope:ButtonRequest)
 private:
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];
  
  friend void  protobuf_AddDesc_bitkey_2eproto();
  friend void protobuf_AssignDesc_bitkey_2eproto();
  friend void protobuf_ShutdownFile_bitkey_2eproto();
  
  void InitAsDefaultInstance();
  static ButtonRequest* default_instance_;
};
// -------------------------------------------------------------------

class ButtonAck : public ::google::protobuf::Message {
 public:
  ButtonAck();
  virtual ~ButtonAck();
  
  ButtonAck(const ButtonAck& from);
  
  inline ButtonAck& operator=(const ButtonAck& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ButtonAck& default_instance();
  
  void Swap(ButtonAck* other);
  
  // implements Message ----------------------------------------------
  
  ButtonAck* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ButtonAck& from);
  void MergeFrom(const ButtonAck& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // @@protoc_insertion_point(class_scope:ButtonAck)
 private:
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];
  
  friend void  protobuf_AddDesc_bitkey_2eproto();
  friend void protobuf_AssignDesc_bitkey_2eproto();
  friend void protobuf_ShutdownFile_bitkey_2eproto();
  
  void InitAsDefaultInstance();
  static ButtonAck* default_instance_;
};
// -------------------------------------------------------------------

class ButtonCancel : public ::google::protobuf::Message {
 public:
  ButtonCancel();
  virtual ~ButtonCancel();
  
  ButtonCancel(const ButtonCancel& from);
  
  inline ButtonCancel& operator=(const ButtonCancel& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ButtonCancel& default_instance();
  
  void Swap(ButtonCancel* other);
  
  // implements Message ----------------------------------------------
  
  ButtonCancel* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ButtonCancel& from);
  void MergeFrom(const ButtonCancel& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // @@protoc_insertion_point(class_scope:ButtonCancel)
 private:
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];
  
  friend void  protobuf_AddDesc_bitkey_2eproto();
  friend void protobuf_AssignDesc_bitkey_2eproto();
  friend void protobuf_ShutdownFile_bitkey_2eproto();
  
  void InitAsDefaultInstance();
  static ButtonCancel* default_instance_;
};
// -------------------------------------------------------------------

class OtpRequest : public ::google::protobuf::Message {
 public:
  OtpRequest();
  virtual ~OtpRequest();
  
  OtpRequest(const OtpRequest& from);
  
  inline OtpRequest& operator=(const OtpRequest& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const OtpRequest& default_instance();
  
  void Swap(OtpRequest* other);
  
  // implements Message ----------------------------------------------
  
  OtpRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const OtpRequest& from);
  void MergeFrom(const OtpRequest& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional string message = 1;
  inline bool has_message() const;
  inline void clear_message();
  static const int kMessageFieldNumber = 1;
  inline const ::std::string& message() const;
  inline void set_message(const ::std::string& value);
  inline void set_message(const char* value);
  inline void set_message(const char* value, size_t size);
  inline ::std::string* mutable_message();
  inline ::std::string* release_message();
  
  // @@protoc_insertion_point(class_scope:OtpRequest)
 private:
  inline void set_has_message();
  inline void clear_has_message();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* message_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_bitkey_2eproto();
  friend void protobuf_AssignDesc_bitkey_2eproto();
  friend void protobuf_ShutdownFile_bitkey_2eproto();
  
  void InitAsDefaultInstance();
  static OtpRequest* default_instance_;
};
// -------------------------------------------------------------------

class OtpAck : public ::google::protobuf::Message {
 public:
  OtpAck();
  virtual ~OtpAck();
  
  OtpAck(const OtpAck& from);
  
  inline OtpAck& operator=(const OtpAck& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const OtpAck& default_instance();
  
  void Swap(OtpAck* other);
  
  // implements Message ----------------------------------------------
  
  OtpAck* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const OtpAck& from);
  void MergeFrom(const OtpAck& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string otp = 1;
  inline bool has_otp() const;
  inline void clear_otp();
  static const int kOtpFieldNumber = 1;
  inline const ::std::string& otp() const;
  inline void set_otp(const ::std::string& value);
  inline void set_otp(const char* value);
  inline void set_otp(const char* value, size_t size);
  inline ::std::string* mutable_otp();
  inline ::std::string* release_otp();
  
  // @@protoc_insertion_point(class_scope:OtpAck)
 private:
  inline void set_has_otp();
  inline void clear_has_otp();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* otp_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_bitkey_2eproto();
  friend void protobuf_AssignDesc_bitkey_2eproto();
  friend void protobuf_ShutdownFile_bitkey_2eproto();
  
  void InitAsDefaultInstance();
  static OtpAck* default_instance_;
};
// -------------------------------------------------------------------

class OtpCancel : public ::google::protobuf::Message {
 public:
  OtpCancel();
  virtual ~OtpCancel();
  
  OtpCancel(const OtpCancel& from);
  
  inline OtpCancel& operator=(const OtpCancel& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const OtpCancel& default_instance();
  
  void Swap(OtpCancel* other);
  
  // implements Message ----------------------------------------------
  
  OtpCancel* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const OtpCancel& from);
  void MergeFrom(const OtpCancel& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // @@protoc_insertion_point(class_scope:OtpCancel)
 private:
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];
  
  friend void  protobuf_AddDesc_bitkey_2eproto();
  friend void protobuf_AssignDesc_bitkey_2eproto();
  friend void protobuf_ShutdownFile_bitkey_2eproto();
  
  void InitAsDefaultInstance();
  static OtpCancel* default_instance_;
};
// -------------------------------------------------------------------

class PinRequest : public ::google::protobuf::Message {
 public:
  PinRequest();
  virtual ~PinRequest();
  
  PinRequest(const PinRequest& from);
  
  inline PinRequest& operator=(const PinRequest& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const PinRequest& default_instance();
  
  void Swap(PinRequest* other);
  
  // implements Message ----------------------------------------------
  
  PinRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PinRequest& from);
  void MergeFrom(const PinRequest& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional string message = 1;
  inline bool has_message() const;
  inline void clear_message();
  static const int kMessageFieldNumber = 1;
  inline const ::std::string& message() const;
  inline void set_message(const ::std::string& value);
  inline void set_message(const char* value);
  inline void set_message(const char* value, size_t size);
  inline ::std::string* mutable_message();
  inline ::std::string* release_message();
  
  // @@protoc_insertion_point(class_scope:PinRequest)
 private:
  inline void set_has_message();
  inline void clear_has_message();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* message_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_bitkey_2eproto();
  friend void protobuf_AssignDesc_bitkey_2eproto();
  friend void protobuf_ShutdownFile_bitkey_2eproto();
  
  void InitAsDefaultInstance();
  static PinRequest* default_instance_;
};
// -------------------------------------------------------------------

class PinAck : public ::google::protobuf::Message {
 public:
  PinAck();
  virtual ~PinAck();
  
  PinAck(const PinAck& from);
  
  inline PinAck& operator=(const PinAck& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const PinAck& default_instance();
  
  void Swap(PinAck* other);
  
  // implements Message ----------------------------------------------
  
  PinAck* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PinAck& from);
  void MergeFrom(const PinAck& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string pin = 1;
  inline bool has_pin() const;
  inline void clear_pin();
  static const int kPinFieldNumber = 1;
  inline const ::std::string& pin() const;
  inline void set_pin(const ::std::string& value);
  inline void set_pin(const char* value);
  inline void set_pin(const char* value, size_t size);
  inline ::std::string* mutable_pin();
  inline ::std::string* release_pin();
  
  // @@protoc_insertion_point(class_scope:PinAck)
 private:
  inline void set_has_pin();
  inline void clear_has_pin();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* pin_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_bitkey_2eproto();
  friend void protobuf_AssignDesc_bitkey_2eproto();
  friend void protobuf_ShutdownFile_bitkey_2eproto();
  
  void InitAsDefaultInstance();
  static PinAck* default_instance_;
};
// -------------------------------------------------------------------

class PinCancel : public ::google::protobuf::Message {
 public:
  PinCancel();
  virtual ~PinCancel();
  
  PinCancel(const PinCancel& from);
  
  inline PinCancel& operator=(const PinCancel& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const PinCancel& default_instance();
  
  void Swap(PinCancel* other);
  
  // implements Message ----------------------------------------------
  
  PinCancel* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PinCancel& from);
  void MergeFrom(const PinCancel& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // @@protoc_insertion_point(class_scope:PinCancel)
 private:
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];
  
  friend void  protobuf_AddDesc_bitkey_2eproto();
  friend void protobuf_AssignDesc_bitkey_2eproto();
  friend void protobuf_ShutdownFile_bitkey_2eproto();
  
  void InitAsDefaultInstance();
  static PinCancel* default_instance_;
};
// -------------------------------------------------------------------

class GetEntropy : public ::google::protobuf::Message {
 public:
  GetEntropy();
  virtual ~GetEntropy();
  
  GetEntropy(const GetEntropy& from);
  
  inline GetEntropy& operator=(const GetEntropy& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const GetEntropy& default_instance();
  
  void Swap(GetEntropy* other);
  
  // implements Message ----------------------------------------------
  
  GetEntropy* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetEntropy& from);
  void MergeFrom(const GetEntropy& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required uint32 size = 1;
  inline bool has_size() const;
  inline void clear_size();
  static const int kSizeFieldNumber = 1;
  inline ::google::protobuf::uint32 size() const;
  inline void set_size(::google::protobuf::uint32 value);
  
  // @@protoc_insertion_point(class_scope:GetEntropy)
 private:
  inline void set_has_size();
  inline void clear_has_size();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::uint32 size_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_bitkey_2eproto();
  friend void protobuf_AssignDesc_bitkey_2eproto();
  friend void protobuf_ShutdownFile_bitkey_2eproto();
  
  void InitAsDefaultInstance();
  static GetEntropy* default_instance_;
};
// -------------------------------------------------------------------

class Entropy : public ::google::protobuf::Message {
 public:
  Entropy();
  virtual ~Entropy();
  
  Entropy(const Entropy& from);
  
  inline Entropy& operator=(const Entropy& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Entropy& default_instance();
  
  void Swap(Entropy* other);
  
  // implements Message ----------------------------------------------
  
  Entropy* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Entropy& from);
  void MergeFrom(const Entropy& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required bytes entropy = 1;
  inline bool has_entropy() const;
  inline void clear_entropy();
  static const int kEntropyFieldNumber = 1;
  inline const ::std::string& entropy() const;
  inline void set_entropy(const ::std::string& value);
  inline void set_entropy(const char* value);
  inline void set_entropy(const void* value, size_t size);
  inline ::std::string* mutable_entropy();
  inline ::std::string* release_entropy();
  
  // @@protoc_insertion_point(class_scope:Entropy)
 private:
  inline void set_has_entropy();
  inline void clear_has_entropy();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* entropy_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_bitkey_2eproto();
  friend void protobuf_AssignDesc_bitkey_2eproto();
  friend void protobuf_ShutdownFile_bitkey_2eproto();
  
  void InitAsDefaultInstance();
  static Entropy* default_instance_;
};
// -------------------------------------------------------------------

class SetMaxFeeKb : public ::google::protobuf::Message {
 public:
  SetMaxFeeKb();
  virtual ~SetMaxFeeKb();
  
  SetMaxFeeKb(const SetMaxFeeKb& from);
  
  inline SetMaxFeeKb& operator=(const SetMaxFeeKb& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const SetMaxFeeKb& default_instance();
  
  void Swap(SetMaxFeeKb* other);
  
  // implements Message ----------------------------------------------
  
  SetMaxFeeKb* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SetMaxFeeKb& from);
  void MergeFrom(const SetMaxFeeKb& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required uint64 maxfee_kb = 1;
  inline bool has_maxfee_kb() const;
  inline void clear_maxfee_kb();
  static const int kMaxfeeKbFieldNumber = 1;
  inline ::google::protobuf::uint64 maxfee_kb() const;
  inline void set_maxfee_kb(::google::protobuf::uint64 value);
  
  // @@protoc_insertion_point(class_scope:SetMaxFeeKb)
 private:
  inline void set_has_maxfee_kb();
  inline void clear_has_maxfee_kb();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::uint64 maxfee_kb_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_bitkey_2eproto();
  friend void protobuf_AssignDesc_bitkey_2eproto();
  friend void protobuf_ShutdownFile_bitkey_2eproto();
  
  void InitAsDefaultInstance();
  static SetMaxFeeKb* default_instance_;
};
// -------------------------------------------------------------------

class GetMasterPublicKey : public ::google::protobuf::Message {
 public:
  GetMasterPublicKey();
  virtual ~GetMasterPublicKey();
  
  GetMasterPublicKey(const GetMasterPublicKey& from);
  
  inline GetMasterPublicKey& operator=(const GetMasterPublicKey& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const GetMasterPublicKey& default_instance();
  
  void Swap(GetMasterPublicKey* other);
  
  // implements Message ----------------------------------------------
  
  GetMasterPublicKey* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetMasterPublicKey& from);
  void MergeFrom(const GetMasterPublicKey& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // @@protoc_insertion_point(class_scope:GetMasterPublicKey)
 private:
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];
  
  friend void  protobuf_AddDesc_bitkey_2eproto();
  friend void protobuf_AssignDesc_bitkey_2eproto();
  friend void protobuf_ShutdownFile_bitkey_2eproto();
  
  void InitAsDefaultInstance();
  static GetMasterPublicKey* default_instance_;
};
// -------------------------------------------------------------------

class MasterPublicKey : public ::google::protobuf::Message {
 public:
  MasterPublicKey();
  virtual ~MasterPublicKey();
  
  MasterPublicKey(const MasterPublicKey& from);
  
  inline MasterPublicKey& operator=(const MasterPublicKey& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MasterPublicKey& default_instance();
  
  void Swap(MasterPublicKey* other);
  
  // implements Message ----------------------------------------------
  
  MasterPublicKey* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MasterPublicKey& from);
  void MergeFrom(const MasterPublicKey& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required bytes key = 1;
  inline bool has_key() const;
  inline void clear_key();
  static const int kKeyFieldNumber = 1;
  inline const ::std::string& key() const;
  inline void set_key(const ::std::string& value);
  inline void set_key(const char* value);
  inline void set_key(const void* value, size_t size);
  inline ::std::string* mutable_key();
  inline ::std::string* release_key();
  
  // @@protoc_insertion_point(class_scope:MasterPublicKey)
 private:
  inline void set_has_key();
  inline void clear_has_key();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* key_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_bitkey_2eproto();
  friend void protobuf_AssignDesc_bitkey_2eproto();
  friend void protobuf_ShutdownFile_bitkey_2eproto();
  
  void InitAsDefaultInstance();
  static MasterPublicKey* default_instance_;
};
// -------------------------------------------------------------------

class GetAddress : public ::google::protobuf::Message {
 public:
  GetAddress();
  virtual ~GetAddress();
  
  GetAddress(const GetAddress& from);
  
  inline GetAddress& operator=(const GetAddress& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const GetAddress& default_instance();
  
  void Swap(GetAddress* other);
  
  // implements Message ----------------------------------------------
  
  GetAddress* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetAddress& from);
  void MergeFrom(const GetAddress& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated uint32 address_n = 1;
  inline int address_n_size() const;
  inline void clear_address_n();
  static const int kAddressNFieldNumber = 1;
  inline ::google::protobuf::uint32 address_n(int index) const;
  inline void set_address_n(int index, ::google::protobuf::uint32 value);
  inline void add_address_n(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      address_n() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_address_n();
  
  // @@protoc_insertion_point(class_scope:GetAddress)
 private:
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > address_n_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_bitkey_2eproto();
  friend void protobuf_AssignDesc_bitkey_2eproto();
  friend void protobuf_ShutdownFile_bitkey_2eproto();
  
  void InitAsDefaultInstance();
  static GetAddress* default_instance_;
};
// -------------------------------------------------------------------

class Address : public ::google::protobuf::Message {
 public:
  Address();
  virtual ~Address();
  
  Address(const Address& from);
  
  inline Address& operator=(const Address& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Address& default_instance();
  
  void Swap(Address* other);
  
  // implements Message ----------------------------------------------
  
  Address* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Address& from);
  void MergeFrom(const Address& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string address = 1;
  inline bool has_address() const;
  inline void clear_address();
  static const int kAddressFieldNumber = 1;
  inline const ::std::string& address() const;
  inline void set_address(const ::std::string& value);
  inline void set_address(const char* value);
  inline void set_address(const char* value, size_t size);
  inline ::std::string* mutable_address();
  inline ::std::string* release_address();
  
  // @@protoc_insertion_point(class_scope:Address)
 private:
  inline void set_has_address();
  inline void clear_has_address();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* address_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_bitkey_2eproto();
  friend void protobuf_AssignDesc_bitkey_2eproto();
  friend void protobuf_ShutdownFile_bitkey_2eproto();
  
  void InitAsDefaultInstance();
  static Address* default_instance_;
};
// -------------------------------------------------------------------

class LoadDevice : public ::google::protobuf::Message {
 public:
  LoadDevice();
  virtual ~LoadDevice();
  
  LoadDevice(const LoadDevice& from);
  
  inline LoadDevice& operator=(const LoadDevice& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const LoadDevice& default_instance();
  
  void Swap(LoadDevice* other);
  
  // implements Message ----------------------------------------------
  
  LoadDevice* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LoadDevice& from);
  void MergeFrom(const LoadDevice& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string seed = 1;
  inline bool has_seed() const;
  inline void clear_seed();
  static const int kSeedFieldNumber = 1;
  inline const ::std::string& seed() const;
  inline void set_seed(const ::std::string& value);
  inline void set_seed(const char* value);
  inline void set_seed(const char* value, size_t size);
  inline ::std::string* mutable_seed();
  inline ::std::string* release_seed();
  
  // optional bool otp = 2 [default = true];
  inline bool has_otp() const;
  inline void clear_otp();
  static const int kOtpFieldNumber = 2;
  inline bool otp() const;
  inline void set_otp(bool value);
  
  // optional string pin = 3;
  inline bool has_pin() const;
  inline void clear_pin();
  static const int kPinFieldNumber = 3;
  inline const ::std::string& pin() const;
  inline void set_pin(const ::std::string& value);
  inline void set_pin(const char* value);
  inline void set_pin(const char* value, size_t size);
  inline ::std::string* mutable_pin();
  inline ::std::string* release_pin();
  
  // optional bool spv = 4 [default = true];
  inline bool has_spv() const;
  inline void clear_spv();
  static const int kSpvFieldNumber = 4;
  inline bool spv() const;
  inline void set_spv(bool value);
  
  // @@protoc_insertion_point(class_scope:LoadDevice)
 private:
  inline void set_has_seed();
  inline void clear_has_seed();
  inline void set_has_otp();
  inline void clear_has_otp();
  inline void set_has_pin();
  inline void clear_has_pin();
  inline void set_has_spv();
  inline void clear_has_spv();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* seed_;
  ::std::string* pin_;
  bool otp_;
  bool spv_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  friend void  protobuf_AddDesc_bitkey_2eproto();
  friend void protobuf_AssignDesc_bitkey_2eproto();
  friend void protobuf_ShutdownFile_bitkey_2eproto();
  
  void InitAsDefaultInstance();
  static LoadDevice* default_instance_;
};
// -------------------------------------------------------------------

class ResetDevice : public ::google::protobuf::Message {
 public:
  ResetDevice();
  virtual ~ResetDevice();
  
  ResetDevice(const ResetDevice& from);
  
  inline ResetDevice& operator=(const ResetDevice& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ResetDevice& default_instance();
  
  void Swap(ResetDevice* other);
  
  // implements Message ----------------------------------------------
  
  ResetDevice* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ResetDevice& from);
  void MergeFrom(const ResetDevice& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional bytes random = 7;
  inline bool has_random() const;
  inline void clear_random();
  static const int kRandomFieldNumber = 7;
  inline const ::std::string& random() const;
  inline void set_random(const ::std::string& value);
  inline void set_random(const char* value);
  inline void set_random(const void* value, size_t size);
  inline ::std::string* mutable_random();
  inline ::std::string* release_random();
  
  // @@protoc_insertion_point(class_scope:ResetDevice)
 private:
  inline void set_has_random();
  inline void clear_has_random();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* random_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_bitkey_2eproto();
  friend void protobuf_AssignDesc_bitkey_2eproto();
  friend void protobuf_ShutdownFile_bitkey_2eproto();
  
  void InitAsDefaultInstance();
  static ResetDevice* default_instance_;
};
// -------------------------------------------------------------------

class SignTx : public ::google::protobuf::Message {
 public:
  SignTx();
  virtual ~SignTx();
  
  SignTx(const SignTx& from);
  
  inline SignTx& operator=(const SignTx& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const SignTx& default_instance();
  
  void Swap(SignTx* other);
  
  // implements Message ----------------------------------------------
  
  SignTx* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SignTx& from);
  void MergeFrom(const SignTx& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required uint32 outputs_count = 3;
  inline bool has_outputs_count() const;
  inline void clear_outputs_count();
  static const int kOutputsCountFieldNumber = 3;
  inline ::google::protobuf::uint32 outputs_count() const;
  inline void set_outputs_count(::google::protobuf::uint32 value);
  
  // required uint32 inputs_count = 5;
  inline bool has_inputs_count() const;
  inline void clear_inputs_count();
  static const int kInputsCountFieldNumber = 5;
  inline ::google::protobuf::uint32 inputs_count() const;
  inline void set_inputs_count(::google::protobuf::uint32 value);
  
  // optional bytes random = 6;
  inline bool has_random() const;
  inline void clear_random();
  static const int kRandomFieldNumber = 6;
  inline const ::std::string& random() const;
  inline void set_random(const ::std::string& value);
  inline void set_random(const char* value);
  inline void set_random(const void* value, size_t size);
  inline ::std::string* mutable_random();
  inline ::std::string* release_random();
  
  // @@protoc_insertion_point(class_scope:SignTx)
 private:
  inline void set_has_outputs_count();
  inline void clear_has_outputs_count();
  inline void set_has_inputs_count();
  inline void clear_has_inputs_count();
  inline void set_has_random();
  inline void clear_has_random();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::uint32 outputs_count_;
  ::google::protobuf::uint32 inputs_count_;
  ::std::string* random_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_bitkey_2eproto();
  friend void protobuf_AssignDesc_bitkey_2eproto();
  friend void protobuf_ShutdownFile_bitkey_2eproto();
  
  void InitAsDefaultInstance();
  static SignTx* default_instance_;
};
// -------------------------------------------------------------------

class TxRequest : public ::google::protobuf::Message {
 public:
  TxRequest();
  virtual ~TxRequest();
  
  TxRequest(const TxRequest& from);
  
  inline TxRequest& operator=(const TxRequest& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const TxRequest& default_instance();
  
  void Swap(TxRequest* other);
  
  // implements Message ----------------------------------------------
  
  TxRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TxRequest& from);
  void MergeFrom(const TxRequest& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional int32 request_index = 1;
  inline bool has_request_index() const;
  inline void clear_request_index();
  static const int kRequestIndexFieldNumber = 1;
  inline ::google::protobuf::int32 request_index() const;
  inline void set_request_index(::google::protobuf::int32 value);
  
  // optional .RequestType request_type = 2;
  inline bool has_request_type() const;
  inline void clear_request_type();
  static const int kRequestTypeFieldNumber = 2;
  inline RequestType request_type() const;
  inline void set_request_type(RequestType value);
  
  // optional int32 signed_index = 3;
  inline bool has_signed_index() const;
  inline void clear_signed_index();
  static const int kSignedIndexFieldNumber = 3;
  inline ::google::protobuf::int32 signed_index() const;
  inline void set_signed_index(::google::protobuf::int32 value);
  
  // optional bytes signature = 4;
  inline bool has_signature() const;
  inline void clear_signature();
  static const int kSignatureFieldNumber = 4;
  inline const ::std::string& signature() const;
  inline void set_signature(const ::std::string& value);
  inline void set_signature(const char* value);
  inline void set_signature(const void* value, size_t size);
  inline ::std::string* mutable_signature();
  inline ::std::string* release_signature();
  
  // optional bytes serialized_tx = 5;
  inline bool has_serialized_tx() const;
  inline void clear_serialized_tx();
  static const int kSerializedTxFieldNumber = 5;
  inline const ::std::string& serialized_tx() const;
  inline void set_serialized_tx(const ::std::string& value);
  inline void set_serialized_tx(const char* value);
  inline void set_serialized_tx(const void* value, size_t size);
  inline ::std::string* mutable_serialized_tx();
  inline ::std::string* release_serialized_tx();
  
  // @@protoc_insertion_point(class_scope:TxRequest)
 private:
  inline void set_has_request_index();
  inline void clear_has_request_index();
  inline void set_has_request_type();
  inline void clear_has_request_type();
  inline void set_has_signed_index();
  inline void clear_has_signed_index();
  inline void set_has_signature();
  inline void clear_has_signature();
  inline void set_has_serialized_tx();
  inline void clear_has_serialized_tx();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::int32 request_index_;
  int request_type_;
  ::std::string* signature_;
  ::std::string* serialized_tx_;
  ::google::protobuf::int32 signed_index_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];
  
  friend void  protobuf_AddDesc_bitkey_2eproto();
  friend void protobuf_AssignDesc_bitkey_2eproto();
  friend void protobuf_ShutdownFile_bitkey_2eproto();
  
  void InitAsDefaultInstance();
  static TxRequest* default_instance_;
};
// -------------------------------------------------------------------

class TxInput : public ::google::protobuf::Message {
 public:
  TxInput();
  virtual ~TxInput();
  
  TxInput(const TxInput& from);
  
  inline TxInput& operator=(const TxInput& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const TxInput& default_instance();
  
  void Swap(TxInput* other);
  
  // implements Message ----------------------------------------------
  
  TxInput* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TxInput& from);
  void MergeFrom(const TxInput& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required uint32 index = 1;
  inline bool has_index() const;
  inline void clear_index();
  static const int kIndexFieldNumber = 1;
  inline ::google::protobuf::uint32 index() const;
  inline void set_index(::google::protobuf::uint32 value);
  
  // repeated uint32 address_n = 2;
  inline int address_n_size() const;
  inline void clear_address_n();
  static const int kAddressNFieldNumber = 2;
  inline ::google::protobuf::uint32 address_n(int index) const;
  inline void set_address_n(int index, ::google::protobuf::uint32 value);
  inline void add_address_n(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      address_n() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_address_n();
  
  // required uint64 amount = 3;
  inline bool has_amount() const;
  inline void clear_amount();
  static const int kAmountFieldNumber = 3;
  inline ::google::protobuf::uint64 amount() const;
  inline void set_amount(::google::protobuf::uint64 value);
  
  // required bytes prev_hash = 4;
  inline bool has_prev_hash() const;
  inline void clear_prev_hash();
  static const int kPrevHashFieldNumber = 4;
  inline const ::std::string& prev_hash() const;
  inline void set_prev_hash(const ::std::string& value);
  inline void set_prev_hash(const char* value);
  inline void set_prev_hash(const void* value, size_t size);
  inline ::std::string* mutable_prev_hash();
  inline ::std::string* release_prev_hash();
  
  // required uint32 prev_index = 5;
  inline bool has_prev_index() const;
  inline void clear_prev_index();
  static const int kPrevIndexFieldNumber = 5;
  inline ::google::protobuf::uint32 prev_index() const;
  inline void set_prev_index(::google::protobuf::uint32 value);
  
  // optional bytes script_sig = 6;
  inline bool has_script_sig() const;
  inline void clear_script_sig();
  static const int kScriptSigFieldNumber = 6;
  inline const ::std::string& script_sig() const;
  inline void set_script_sig(const ::std::string& value);
  inline void set_script_sig(const char* value);
  inline void set_script_sig(const void* value, size_t size);
  inline ::std::string* mutable_script_sig();
  inline ::std::string* release_script_sig();
  
  // @@protoc_insertion_point(class_scope:TxInput)
 private:
  inline void set_has_index();
  inline void clear_has_index();
  inline void set_has_amount();
  inline void clear_has_amount();
  inline void set_has_prev_hash();
  inline void clear_has_prev_hash();
  inline void set_has_prev_index();
  inline void clear_has_prev_index();
  inline void set_has_script_sig();
  inline void clear_has_script_sig();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > address_n_;
  ::google::protobuf::uint64 amount_;
  ::google::protobuf::uint32 index_;
  ::google::protobuf::uint32 prev_index_;
  ::std::string* prev_hash_;
  ::std::string* script_sig_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];
  
  friend void  protobuf_AddDesc_bitkey_2eproto();
  friend void protobuf_AssignDesc_bitkey_2eproto();
  friend void protobuf_ShutdownFile_bitkey_2eproto();
  
  void InitAsDefaultInstance();
  static TxInput* default_instance_;
};
// -------------------------------------------------------------------

class TxOutput : public ::google::protobuf::Message {
 public:
  TxOutput();
  virtual ~TxOutput();
  
  TxOutput(const TxOutput& from);
  
  inline TxOutput& operator=(const TxOutput& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const TxOutput& default_instance();
  
  void Swap(TxOutput* other);
  
  // implements Message ----------------------------------------------
  
  TxOutput* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TxOutput& from);
  void MergeFrom(const TxOutput& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required uint32 index = 1;
  inline bool has_index() const;
  inline void clear_index();
  static const int kIndexFieldNumber = 1;
  inline ::google::protobuf::uint32 index() const;
  inline void set_index(::google::protobuf::uint32 value);
  
  // required string address = 2;
  inline bool has_address() const;
  inline void clear_address();
  static const int kAddressFieldNumber = 2;
  inline const ::std::string& address() const;
  inline void set_address(const ::std::string& value);
  inline void set_address(const char* value);
  inline void set_address(const char* value, size_t size);
  inline ::std::string* mutable_address();
  inline ::std::string* release_address();
  
  // repeated uint32 address_n = 3;
  inline int address_n_size() const;
  inline void clear_address_n();
  static const int kAddressNFieldNumber = 3;
  inline ::google::protobuf::uint32 address_n(int index) const;
  inline void set_address_n(int index, ::google::protobuf::uint32 value);
  inline void add_address_n(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      address_n() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_address_n();
  
  // required uint64 amount = 4;
  inline bool has_amount() const;
  inline void clear_amount();
  static const int kAmountFieldNumber = 4;
  inline ::google::protobuf::uint64 amount() const;
  inline void set_amount(::google::protobuf::uint64 value);
  
  // required .ScriptType script_type = 5;
  inline bool has_script_type() const;
  inline void clear_script_type();
  static const int kScriptTypeFieldNumber = 5;
  inline ScriptType script_type() const;
  inline void set_script_type(ScriptType value);
  
  // repeated bytes script_args = 6;
  inline int script_args_size() const;
  inline void clear_script_args();
  static const int kScriptArgsFieldNumber = 6;
  inline const ::std::string& script_args(int index) const;
  inline ::std::string* mutable_script_args(int index);
  inline void set_script_args(int index, const ::std::string& value);
  inline void set_script_args(int index, const char* value);
  inline void set_script_args(int index, const void* value, size_t size);
  inline ::std::string* add_script_args();
  inline void add_script_args(const ::std::string& value);
  inline void add_script_args(const char* value);
  inline void add_script_args(const void* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& script_args() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_script_args();
  
  // @@protoc_insertion_point(class_scope:TxOutput)
 private:
  inline void set_has_index();
  inline void clear_has_index();
  inline void set_has_address();
  inline void clear_has_address();
  inline void set_has_amount();
  inline void clear_has_amount();
  inline void set_has_script_type();
  inline void clear_has_script_type();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* address_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > address_n_;
  ::google::protobuf::uint32 index_;
  int script_type_;
  ::google::protobuf::uint64 amount_;
  ::google::protobuf::RepeatedPtrField< ::std::string> script_args_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];
  
  friend void  protobuf_AddDesc_bitkey_2eproto();
  friend void protobuf_AssignDesc_bitkey_2eproto();
  friend void protobuf_ShutdownFile_bitkey_2eproto();
  
  void InitAsDefaultInstance();
  static TxOutput* default_instance_;
};
// ===================================================================


// ===================================================================

// Initialize

// required bytes session_id = 1;
inline bool Initialize::has_session_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Initialize::set_has_session_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Initialize::clear_has_session_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Initialize::clear_session_id() {
  if (session_id_ != &::google::protobuf::internal::kEmptyString) {
    session_id_->clear();
  }
  clear_has_session_id();
}
inline const ::std::string& Initialize::session_id() const {
  return *session_id_;
}
inline void Initialize::set_session_id(const ::std::string& value) {
  set_has_session_id();
  if (session_id_ == &::google::protobuf::internal::kEmptyString) {
    session_id_ = new ::std::string;
  }
  session_id_->assign(value);
}
inline void Initialize::set_session_id(const char* value) {
  set_has_session_id();
  if (session_id_ == &::google::protobuf::internal::kEmptyString) {
    session_id_ = new ::std::string;
  }
  session_id_->assign(value);
}
inline void Initialize::set_session_id(const void* value, size_t size) {
  set_has_session_id();
  if (session_id_ == &::google::protobuf::internal::kEmptyString) {
    session_id_ = new ::std::string;
  }
  session_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Initialize::mutable_session_id() {
  set_has_session_id();
  if (session_id_ == &::google::protobuf::internal::kEmptyString) {
    session_id_ = new ::std::string;
  }
  return session_id_;
}
inline ::std::string* Initialize::release_session_id() {
  clear_has_session_id();
  if (session_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = session_id_;
    session_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// Features

// optional bytes session_id = 1;
inline bool Features::has_session_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Features::set_has_session_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Features::clear_has_session_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Features::clear_session_id() {
  if (session_id_ != &::google::protobuf::internal::kEmptyString) {
    session_id_->clear();
  }
  clear_has_session_id();
}
inline const ::std::string& Features::session_id() const {
  return *session_id_;
}
inline void Features::set_session_id(const ::std::string& value) {
  set_has_session_id();
  if (session_id_ == &::google::protobuf::internal::kEmptyString) {
    session_id_ = new ::std::string;
  }
  session_id_->assign(value);
}
inline void Features::set_session_id(const char* value) {
  set_has_session_id();
  if (session_id_ == &::google::protobuf::internal::kEmptyString) {
    session_id_ = new ::std::string;
  }
  session_id_->assign(value);
}
inline void Features::set_session_id(const void* value, size_t size) {
  set_has_session_id();
  if (session_id_ == &::google::protobuf::internal::kEmptyString) {
    session_id_ = new ::std::string;
  }
  session_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Features::mutable_session_id() {
  set_has_session_id();
  if (session_id_ == &::google::protobuf::internal::kEmptyString) {
    session_id_ = new ::std::string;
  }
  return session_id_;
}
inline ::std::string* Features::release_session_id() {
  clear_has_session_id();
  if (session_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = session_id_;
    session_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string vendor = 2;
inline bool Features::has_vendor() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Features::set_has_vendor() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Features::clear_has_vendor() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Features::clear_vendor() {
  if (vendor_ != &::google::protobuf::internal::kEmptyString) {
    vendor_->clear();
  }
  clear_has_vendor();
}
inline const ::std::string& Features::vendor() const {
  return *vendor_;
}
inline void Features::set_vendor(const ::std::string& value) {
  set_has_vendor();
  if (vendor_ == &::google::protobuf::internal::kEmptyString) {
    vendor_ = new ::std::string;
  }
  vendor_->assign(value);
}
inline void Features::set_vendor(const char* value) {
  set_has_vendor();
  if (vendor_ == &::google::protobuf::internal::kEmptyString) {
    vendor_ = new ::std::string;
  }
  vendor_->assign(value);
}
inline void Features::set_vendor(const char* value, size_t size) {
  set_has_vendor();
  if (vendor_ == &::google::protobuf::internal::kEmptyString) {
    vendor_ = new ::std::string;
  }
  vendor_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Features::mutable_vendor() {
  set_has_vendor();
  if (vendor_ == &::google::protobuf::internal::kEmptyString) {
    vendor_ = new ::std::string;
  }
  return vendor_;
}
inline ::std::string* Features::release_vendor() {
  clear_has_vendor();
  if (vendor_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = vendor_;
    vendor_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional uint32 major_version = 3;
inline bool Features::has_major_version() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Features::set_has_major_version() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Features::clear_has_major_version() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Features::clear_major_version() {
  major_version_ = 0u;
  clear_has_major_version();
}
inline ::google::protobuf::uint32 Features::major_version() const {
  return major_version_;
}
inline void Features::set_major_version(::google::protobuf::uint32 value) {
  set_has_major_version();
  major_version_ = value;
}

// optional uint32 minor_version = 4;
inline bool Features::has_minor_version() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Features::set_has_minor_version() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Features::clear_has_minor_version() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Features::clear_minor_version() {
  minor_version_ = 0u;
  clear_has_minor_version();
}
inline ::google::protobuf::uint32 Features::minor_version() const {
  return minor_version_;
}
inline void Features::set_minor_version(::google::protobuf::uint32 value) {
  set_has_minor_version();
  minor_version_ = value;
}

// optional bool has_otp = 5;
inline bool Features::has_has_otp() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Features::set_has_has_otp() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Features::clear_has_has_otp() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Features::clear_has_otp() {
  has_otp_ = false;
  clear_has_has_otp();
}
inline bool Features::has_otp() const {
  return has_otp_;
}
inline void Features::set_has_otp(bool value) {
  set_has_has_otp();
  has_otp_ = value;
}

// optional bool has_spv = 6;
inline bool Features::has_has_spv() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Features::set_has_has_spv() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Features::clear_has_has_spv() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Features::clear_has_spv() {
  has_spv_ = false;
  clear_has_has_spv();
}
inline bool Features::has_spv() const {
  return has_spv_;
}
inline void Features::set_has_spv(bool value) {
  set_has_has_spv();
  has_spv_ = value;
}

// optional bool pin = 7;
inline bool Features::has_pin() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Features::set_has_pin() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Features::clear_has_pin() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Features::clear_pin() {
  pin_ = false;
  clear_has_pin();
}
inline bool Features::pin() const {
  return pin_;
}
inline void Features::set_pin(bool value) {
  set_has_pin();
  pin_ = value;
}

// optional .Algorithm algo = 8;
inline bool Features::has_algo() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Features::set_has_algo() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Features::clear_has_algo() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Features::clear_algo() {
  algo_ = 0;
  clear_has_algo();
}
inline Algorithm Features::algo() const {
  return static_cast< Algorithm >(algo_);
}
inline void Features::set_algo(Algorithm value) {
  GOOGLE_DCHECK(Algorithm_IsValid(value));
  set_has_algo();
  algo_ = value;
}

// repeated .Algorithm algo_available = 9;
inline int Features::algo_available_size() const {
  return algo_available_.size();
}
inline void Features::clear_algo_available() {
  algo_available_.Clear();
}
inline Algorithm Features::algo_available(int index) const {
  return static_cast< Algorithm >(algo_available_.Get(index));
}
inline void Features::set_algo_available(int index, Algorithm value) {
  GOOGLE_DCHECK(Algorithm_IsValid(value));
  algo_available_.Set(index, value);
}
inline void Features::add_algo_available(Algorithm value) {
  GOOGLE_DCHECK(Algorithm_IsValid(value));
  algo_available_.Add(value);
}
inline const ::google::protobuf::RepeatedField<int>&
Features::algo_available() const {
  return algo_available_;
}
inline ::google::protobuf::RepeatedField<int>*
Features::mutable_algo_available() {
  return &algo_available_;
}

// optional uint64 maxfee_kb = 10;
inline bool Features::has_maxfee_kb() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void Features::set_has_maxfee_kb() {
  _has_bits_[0] |= 0x00000200u;
}
inline void Features::clear_has_maxfee_kb() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void Features::clear_maxfee_kb() {
  maxfee_kb_ = GOOGLE_ULONGLONG(0);
  clear_has_maxfee_kb();
}
inline ::google::protobuf::uint64 Features::maxfee_kb() const {
  return maxfee_kb_;
}
inline void Features::set_maxfee_kb(::google::protobuf::uint64 value) {
  set_has_maxfee_kb();
  maxfee_kb_ = value;
}

// -------------------------------------------------------------------

// Ping

// optional string message = 1;
inline bool Ping::has_message() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Ping::set_has_message() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Ping::clear_has_message() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Ping::clear_message() {
  if (message_ != &::google::protobuf::internal::kEmptyString) {
    message_->clear();
  }
  clear_has_message();
}
inline const ::std::string& Ping::message() const {
  return *message_;
}
inline void Ping::set_message(const ::std::string& value) {
  set_has_message();
  if (message_ == &::google::protobuf::internal::kEmptyString) {
    message_ = new ::std::string;
  }
  message_->assign(value);
}
inline void Ping::set_message(const char* value) {
  set_has_message();
  if (message_ == &::google::protobuf::internal::kEmptyString) {
    message_ = new ::std::string;
  }
  message_->assign(value);
}
inline void Ping::set_message(const char* value, size_t size) {
  set_has_message();
  if (message_ == &::google::protobuf::internal::kEmptyString) {
    message_ = new ::std::string;
  }
  message_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Ping::mutable_message() {
  set_has_message();
  if (message_ == &::google::protobuf::internal::kEmptyString) {
    message_ = new ::std::string;
  }
  return message_;
}
inline ::std::string* Ping::release_message() {
  clear_has_message();
  if (message_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = message_;
    message_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// DebugLinkDecision

// required bool yes_no = 1;
inline bool DebugLinkDecision::has_yes_no() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DebugLinkDecision::set_has_yes_no() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DebugLinkDecision::clear_has_yes_no() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DebugLinkDecision::clear_yes_no() {
  yes_no_ = false;
  clear_has_yes_no();
}
inline bool DebugLinkDecision::yes_no() const {
  return yes_no_;
}
inline void DebugLinkDecision::set_yes_no(bool value) {
  set_has_yes_no();
  yes_no_ = value;
}

// -------------------------------------------------------------------

// DebugLinkGetState

// optional bool layout = 1;
inline bool DebugLinkGetState::has_layout() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DebugLinkGetState::set_has_layout() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DebugLinkGetState::clear_has_layout() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DebugLinkGetState::clear_layout() {
  layout_ = false;
  clear_has_layout();
}
inline bool DebugLinkGetState::layout() const {
  return layout_;
}
inline void DebugLinkGetState::set_layout(bool value) {
  set_has_layout();
  layout_ = value;
}

// optional bool otp = 2;
inline bool DebugLinkGetState::has_otp() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DebugLinkGetState::set_has_otp() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DebugLinkGetState::clear_has_otp() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DebugLinkGetState::clear_otp() {
  otp_ = false;
  clear_has_otp();
}
inline bool DebugLinkGetState::otp() const {
  return otp_;
}
inline void DebugLinkGetState::set_otp(bool value) {
  set_has_otp();
  otp_ = value;
}

// optional bool pin = 3;
inline bool DebugLinkGetState::has_pin() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DebugLinkGetState::set_has_pin() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DebugLinkGetState::clear_has_pin() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DebugLinkGetState::clear_pin() {
  pin_ = false;
  clear_has_pin();
}
inline bool DebugLinkGetState::pin() const {
  return pin_;
}
inline void DebugLinkGetState::set_pin(bool value) {
  set_has_pin();
  pin_ = value;
}

// optional bool seed = 4;
inline bool DebugLinkGetState::has_seed() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void DebugLinkGetState::set_has_seed() {
  _has_bits_[0] |= 0x00000008u;
}
inline void DebugLinkGetState::clear_has_seed() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void DebugLinkGetState::clear_seed() {
  seed_ = false;
  clear_has_seed();
}
inline bool DebugLinkGetState::seed() const {
  return seed_;
}
inline void DebugLinkGetState::set_seed(bool value) {
  set_has_seed();
  seed_ = value;
}

// -------------------------------------------------------------------

// DebugLinkState

// optional bytes layout = 1;
inline bool DebugLinkState::has_layout() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DebugLinkState::set_has_layout() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DebugLinkState::clear_has_layout() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DebugLinkState::clear_layout() {
  if (layout_ != &::google::protobuf::internal::kEmptyString) {
    layout_->clear();
  }
  clear_has_layout();
}
inline const ::std::string& DebugLinkState::layout() const {
  return *layout_;
}
inline void DebugLinkState::set_layout(const ::std::string& value) {
  set_has_layout();
  if (layout_ == &::google::protobuf::internal::kEmptyString) {
    layout_ = new ::std::string;
  }
  layout_->assign(value);
}
inline void DebugLinkState::set_layout(const char* value) {
  set_has_layout();
  if (layout_ == &::google::protobuf::internal::kEmptyString) {
    layout_ = new ::std::string;
  }
  layout_->assign(value);
}
inline void DebugLinkState::set_layout(const void* value, size_t size) {
  set_has_layout();
  if (layout_ == &::google::protobuf::internal::kEmptyString) {
    layout_ = new ::std::string;
  }
  layout_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DebugLinkState::mutable_layout() {
  set_has_layout();
  if (layout_ == &::google::protobuf::internal::kEmptyString) {
    layout_ = new ::std::string;
  }
  return layout_;
}
inline ::std::string* DebugLinkState::release_layout() {
  clear_has_layout();
  if (layout_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = layout_;
    layout_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional .OtpAck otp = 2;
inline bool DebugLinkState::has_otp() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DebugLinkState::set_has_otp() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DebugLinkState::clear_has_otp() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DebugLinkState::clear_otp() {
  if (otp_ != NULL) otp_->::OtpAck::Clear();
  clear_has_otp();
}
inline const ::OtpAck& DebugLinkState::otp() const {
  return otp_ != NULL ? *otp_ : *default_instance_->otp_;
}
inline ::OtpAck* DebugLinkState::mutable_otp() {
  set_has_otp();
  if (otp_ == NULL) otp_ = new ::OtpAck;
  return otp_;
}
inline ::OtpAck* DebugLinkState::release_otp() {
  clear_has_otp();
  ::OtpAck* temp = otp_;
  otp_ = NULL;
  return temp;
}

// optional .PinAck pin = 3;
inline bool DebugLinkState::has_pin() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DebugLinkState::set_has_pin() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DebugLinkState::clear_has_pin() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DebugLinkState::clear_pin() {
  if (pin_ != NULL) pin_->::PinAck::Clear();
  clear_has_pin();
}
inline const ::PinAck& DebugLinkState::pin() const {
  return pin_ != NULL ? *pin_ : *default_instance_->pin_;
}
inline ::PinAck* DebugLinkState::mutable_pin() {
  set_has_pin();
  if (pin_ == NULL) pin_ = new ::PinAck;
  return pin_;
}
inline ::PinAck* DebugLinkState::release_pin() {
  clear_has_pin();
  ::PinAck* temp = pin_;
  pin_ = NULL;
  return temp;
}

// optional string seed = 4;
inline bool DebugLinkState::has_seed() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void DebugLinkState::set_has_seed() {
  _has_bits_[0] |= 0x00000008u;
}
inline void DebugLinkState::clear_has_seed() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void DebugLinkState::clear_seed() {
  if (seed_ != &::google::protobuf::internal::kEmptyString) {
    seed_->clear();
  }
  clear_has_seed();
}
inline const ::std::string& DebugLinkState::seed() const {
  return *seed_;
}
inline void DebugLinkState::set_seed(const ::std::string& value) {
  set_has_seed();
  if (seed_ == &::google::protobuf::internal::kEmptyString) {
    seed_ = new ::std::string;
  }
  seed_->assign(value);
}
inline void DebugLinkState::set_seed(const char* value) {
  set_has_seed();
  if (seed_ == &::google::protobuf::internal::kEmptyString) {
    seed_ = new ::std::string;
  }
  seed_->assign(value);
}
inline void DebugLinkState::set_seed(const char* value, size_t size) {
  set_has_seed();
  if (seed_ == &::google::protobuf::internal::kEmptyString) {
    seed_ = new ::std::string;
  }
  seed_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DebugLinkState::mutable_seed() {
  set_has_seed();
  if (seed_ == &::google::protobuf::internal::kEmptyString) {
    seed_ = new ::std::string;
  }
  return seed_;
}
inline ::std::string* DebugLinkState::release_seed() {
  clear_has_seed();
  if (seed_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = seed_;
    seed_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// Success

// optional string message = 1;
inline bool Success::has_message() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Success::set_has_message() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Success::clear_has_message() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Success::clear_message() {
  if (message_ != &::google::protobuf::internal::kEmptyString) {
    message_->clear();
  }
  clear_has_message();
}
inline const ::std::string& Success::message() const {
  return *message_;
}
inline void Success::set_message(const ::std::string& value) {
  set_has_message();
  if (message_ == &::google::protobuf::internal::kEmptyString) {
    message_ = new ::std::string;
  }
  message_->assign(value);
}
inline void Success::set_message(const char* value) {
  set_has_message();
  if (message_ == &::google::protobuf::internal::kEmptyString) {
    message_ = new ::std::string;
  }
  message_->assign(value);
}
inline void Success::set_message(const char* value, size_t size) {
  set_has_message();
  if (message_ == &::google::protobuf::internal::kEmptyString) {
    message_ = new ::std::string;
  }
  message_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Success::mutable_message() {
  set_has_message();
  if (message_ == &::google::protobuf::internal::kEmptyString) {
    message_ = new ::std::string;
  }
  return message_;
}
inline ::std::string* Success::release_message() {
  clear_has_message();
  if (message_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = message_;
    message_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// Failure

// optional int32 code = 1;
inline bool Failure::has_code() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Failure::set_has_code() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Failure::clear_has_code() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Failure::clear_code() {
  code_ = 0;
  clear_has_code();
}
inline ::google::protobuf::int32 Failure::code() const {
  return code_;
}
inline void Failure::set_code(::google::protobuf::int32 value) {
  set_has_code();
  code_ = value;
}

// optional string message = 2;
inline bool Failure::has_message() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Failure::set_has_message() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Failure::clear_has_message() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Failure::clear_message() {
  if (message_ != &::google::protobuf::internal::kEmptyString) {
    message_->clear();
  }
  clear_has_message();
}
inline const ::std::string& Failure::message() const {
  return *message_;
}
inline void Failure::set_message(const ::std::string& value) {
  set_has_message();
  if (message_ == &::google::protobuf::internal::kEmptyString) {
    message_ = new ::std::string;
  }
  message_->assign(value);
}
inline void Failure::set_message(const char* value) {
  set_has_message();
  if (message_ == &::google::protobuf::internal::kEmptyString) {
    message_ = new ::std::string;
  }
  message_->assign(value);
}
inline void Failure::set_message(const char* value, size_t size) {
  set_has_message();
  if (message_ == &::google::protobuf::internal::kEmptyString) {
    message_ = new ::std::string;
  }
  message_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Failure::mutable_message() {
  set_has_message();
  if (message_ == &::google::protobuf::internal::kEmptyString) {
    message_ = new ::std::string;
  }
  return message_;
}
inline ::std::string* Failure::release_message() {
  clear_has_message();
  if (message_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = message_;
    message_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// GetUUID

// -------------------------------------------------------------------

// UUID

// required bytes UUID = 1;
inline bool UUID::has_uuid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UUID::set_has_uuid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UUID::clear_has_uuid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UUID::clear_uuid() {
  if (uuid_ != &::google::protobuf::internal::kEmptyString) {
    uuid_->clear();
  }
  clear_has_uuid();
}
inline const ::std::string& UUID::uuid() const {
  return *uuid_;
}
inline void UUID::set_uuid(const ::std::string& value) {
  set_has_uuid();
  if (uuid_ == &::google::protobuf::internal::kEmptyString) {
    uuid_ = new ::std::string;
  }
  uuid_->assign(value);
}
inline void UUID::set_uuid(const char* value) {
  set_has_uuid();
  if (uuid_ == &::google::protobuf::internal::kEmptyString) {
    uuid_ = new ::std::string;
  }
  uuid_->assign(value);
}
inline void UUID::set_uuid(const void* value, size_t size) {
  set_has_uuid();
  if (uuid_ == &::google::protobuf::internal::kEmptyString) {
    uuid_ = new ::std::string;
  }
  uuid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UUID::mutable_uuid() {
  set_has_uuid();
  if (uuid_ == &::google::protobuf::internal::kEmptyString) {
    uuid_ = new ::std::string;
  }
  return uuid_;
}
inline ::std::string* UUID::release_uuid() {
  clear_has_uuid();
  if (uuid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = uuid_;
    uuid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// ButtonRequest

// -------------------------------------------------------------------

// ButtonAck

// -------------------------------------------------------------------

// ButtonCancel

// -------------------------------------------------------------------

// OtpRequest

// optional string message = 1;
inline bool OtpRequest::has_message() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void OtpRequest::set_has_message() {
  _has_bits_[0] |= 0x00000001u;
}
inline void OtpRequest::clear_has_message() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void OtpRequest::clear_message() {
  if (message_ != &::google::protobuf::internal::kEmptyString) {
    message_->clear();
  }
  clear_has_message();
}
inline const ::std::string& OtpRequest::message() const {
  return *message_;
}
inline void OtpRequest::set_message(const ::std::string& value) {
  set_has_message();
  if (message_ == &::google::protobuf::internal::kEmptyString) {
    message_ = new ::std::string;
  }
  message_->assign(value);
}
inline void OtpRequest::set_message(const char* value) {
  set_has_message();
  if (message_ == &::google::protobuf::internal::kEmptyString) {
    message_ = new ::std::string;
  }
  message_->assign(value);
}
inline void OtpRequest::set_message(const char* value, size_t size) {
  set_has_message();
  if (message_ == &::google::protobuf::internal::kEmptyString) {
    message_ = new ::std::string;
  }
  message_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* OtpRequest::mutable_message() {
  set_has_message();
  if (message_ == &::google::protobuf::internal::kEmptyString) {
    message_ = new ::std::string;
  }
  return message_;
}
inline ::std::string* OtpRequest::release_message() {
  clear_has_message();
  if (message_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = message_;
    message_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// OtpAck

// required string otp = 1;
inline bool OtpAck::has_otp() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void OtpAck::set_has_otp() {
  _has_bits_[0] |= 0x00000001u;
}
inline void OtpAck::clear_has_otp() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void OtpAck::clear_otp() {
  if (otp_ != &::google::protobuf::internal::kEmptyString) {
    otp_->clear();
  }
  clear_has_otp();
}
inline const ::std::string& OtpAck::otp() const {
  return *otp_;
}
inline void OtpAck::set_otp(const ::std::string& value) {
  set_has_otp();
  if (otp_ == &::google::protobuf::internal::kEmptyString) {
    otp_ = new ::std::string;
  }
  otp_->assign(value);
}
inline void OtpAck::set_otp(const char* value) {
  set_has_otp();
  if (otp_ == &::google::protobuf::internal::kEmptyString) {
    otp_ = new ::std::string;
  }
  otp_->assign(value);
}
inline void OtpAck::set_otp(const char* value, size_t size) {
  set_has_otp();
  if (otp_ == &::google::protobuf::internal::kEmptyString) {
    otp_ = new ::std::string;
  }
  otp_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* OtpAck::mutable_otp() {
  set_has_otp();
  if (otp_ == &::google::protobuf::internal::kEmptyString) {
    otp_ = new ::std::string;
  }
  return otp_;
}
inline ::std::string* OtpAck::release_otp() {
  clear_has_otp();
  if (otp_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = otp_;
    otp_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// OtpCancel

// -------------------------------------------------------------------

// PinRequest

// optional string message = 1;
inline bool PinRequest::has_message() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PinRequest::set_has_message() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PinRequest::clear_has_message() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PinRequest::clear_message() {
  if (message_ != &::google::protobuf::internal::kEmptyString) {
    message_->clear();
  }
  clear_has_message();
}
inline const ::std::string& PinRequest::message() const {
  return *message_;
}
inline void PinRequest::set_message(const ::std::string& value) {
  set_has_message();
  if (message_ == &::google::protobuf::internal::kEmptyString) {
    message_ = new ::std::string;
  }
  message_->assign(value);
}
inline void PinRequest::set_message(const char* value) {
  set_has_message();
  if (message_ == &::google::protobuf::internal::kEmptyString) {
    message_ = new ::std::string;
  }
  message_->assign(value);
}
inline void PinRequest::set_message(const char* value, size_t size) {
  set_has_message();
  if (message_ == &::google::protobuf::internal::kEmptyString) {
    message_ = new ::std::string;
  }
  message_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PinRequest::mutable_message() {
  set_has_message();
  if (message_ == &::google::protobuf::internal::kEmptyString) {
    message_ = new ::std::string;
  }
  return message_;
}
inline ::std::string* PinRequest::release_message() {
  clear_has_message();
  if (message_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = message_;
    message_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// PinAck

// required string pin = 1;
inline bool PinAck::has_pin() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PinAck::set_has_pin() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PinAck::clear_has_pin() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PinAck::clear_pin() {
  if (pin_ != &::google::protobuf::internal::kEmptyString) {
    pin_->clear();
  }
  clear_has_pin();
}
inline const ::std::string& PinAck::pin() const {
  return *pin_;
}
inline void PinAck::set_pin(const ::std::string& value) {
  set_has_pin();
  if (pin_ == &::google::protobuf::internal::kEmptyString) {
    pin_ = new ::std::string;
  }
  pin_->assign(value);
}
inline void PinAck::set_pin(const char* value) {
  set_has_pin();
  if (pin_ == &::google::protobuf::internal::kEmptyString) {
    pin_ = new ::std::string;
  }
  pin_->assign(value);
}
inline void PinAck::set_pin(const char* value, size_t size) {
  set_has_pin();
  if (pin_ == &::google::protobuf::internal::kEmptyString) {
    pin_ = new ::std::string;
  }
  pin_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PinAck::mutable_pin() {
  set_has_pin();
  if (pin_ == &::google::protobuf::internal::kEmptyString) {
    pin_ = new ::std::string;
  }
  return pin_;
}
inline ::std::string* PinAck::release_pin() {
  clear_has_pin();
  if (pin_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = pin_;
    pin_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// PinCancel

// -------------------------------------------------------------------

// GetEntropy

// required uint32 size = 1;
inline bool GetEntropy::has_size() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetEntropy::set_has_size() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetEntropy::clear_has_size() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetEntropy::clear_size() {
  size_ = 0u;
  clear_has_size();
}
inline ::google::protobuf::uint32 GetEntropy::size() const {
  return size_;
}
inline void GetEntropy::set_size(::google::protobuf::uint32 value) {
  set_has_size();
  size_ = value;
}

// -------------------------------------------------------------------

// Entropy

// required bytes entropy = 1;
inline bool Entropy::has_entropy() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Entropy::set_has_entropy() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Entropy::clear_has_entropy() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Entropy::clear_entropy() {
  if (entropy_ != &::google::protobuf::internal::kEmptyString) {
    entropy_->clear();
  }
  clear_has_entropy();
}
inline const ::std::string& Entropy::entropy() const {
  return *entropy_;
}
inline void Entropy::set_entropy(const ::std::string& value) {
  set_has_entropy();
  if (entropy_ == &::google::protobuf::internal::kEmptyString) {
    entropy_ = new ::std::string;
  }
  entropy_->assign(value);
}
inline void Entropy::set_entropy(const char* value) {
  set_has_entropy();
  if (entropy_ == &::google::protobuf::internal::kEmptyString) {
    entropy_ = new ::std::string;
  }
  entropy_->assign(value);
}
inline void Entropy::set_entropy(const void* value, size_t size) {
  set_has_entropy();
  if (entropy_ == &::google::protobuf::internal::kEmptyString) {
    entropy_ = new ::std::string;
  }
  entropy_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Entropy::mutable_entropy() {
  set_has_entropy();
  if (entropy_ == &::google::protobuf::internal::kEmptyString) {
    entropy_ = new ::std::string;
  }
  return entropy_;
}
inline ::std::string* Entropy::release_entropy() {
  clear_has_entropy();
  if (entropy_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = entropy_;
    entropy_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// SetMaxFeeKb

// required uint64 maxfee_kb = 1;
inline bool SetMaxFeeKb::has_maxfee_kb() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SetMaxFeeKb::set_has_maxfee_kb() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SetMaxFeeKb::clear_has_maxfee_kb() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SetMaxFeeKb::clear_maxfee_kb() {
  maxfee_kb_ = GOOGLE_ULONGLONG(0);
  clear_has_maxfee_kb();
}
inline ::google::protobuf::uint64 SetMaxFeeKb::maxfee_kb() const {
  return maxfee_kb_;
}
inline void SetMaxFeeKb::set_maxfee_kb(::google::protobuf::uint64 value) {
  set_has_maxfee_kb();
  maxfee_kb_ = value;
}

// -------------------------------------------------------------------

// GetMasterPublicKey

// -------------------------------------------------------------------

// MasterPublicKey

// required bytes key = 1;
inline bool MasterPublicKey::has_key() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MasterPublicKey::set_has_key() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MasterPublicKey::clear_has_key() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MasterPublicKey::clear_key() {
  if (key_ != &::google::protobuf::internal::kEmptyString) {
    key_->clear();
  }
  clear_has_key();
}
inline const ::std::string& MasterPublicKey::key() const {
  return *key_;
}
inline void MasterPublicKey::set_key(const ::std::string& value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  key_->assign(value);
}
inline void MasterPublicKey::set_key(const char* value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  key_->assign(value);
}
inline void MasterPublicKey::set_key(const void* value, size_t size) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  key_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MasterPublicKey::mutable_key() {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  return key_;
}
inline ::std::string* MasterPublicKey::release_key() {
  clear_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = key_;
    key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// GetAddress

// repeated uint32 address_n = 1;
inline int GetAddress::address_n_size() const {
  return address_n_.size();
}
inline void GetAddress::clear_address_n() {
  address_n_.Clear();
}
inline ::google::protobuf::uint32 GetAddress::address_n(int index) const {
  return address_n_.Get(index);
}
inline void GetAddress::set_address_n(int index, ::google::protobuf::uint32 value) {
  address_n_.Set(index, value);
}
inline void GetAddress::add_address_n(::google::protobuf::uint32 value) {
  address_n_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
GetAddress::address_n() const {
  return address_n_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
GetAddress::mutable_address_n() {
  return &address_n_;
}

// -------------------------------------------------------------------

// Address

// required string address = 1;
inline bool Address::has_address() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Address::set_has_address() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Address::clear_has_address() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Address::clear_address() {
  if (address_ != &::google::protobuf::internal::kEmptyString) {
    address_->clear();
  }
  clear_has_address();
}
inline const ::std::string& Address::address() const {
  return *address_;
}
inline void Address::set_address(const ::std::string& value) {
  set_has_address();
  if (address_ == &::google::protobuf::internal::kEmptyString) {
    address_ = new ::std::string;
  }
  address_->assign(value);
}
inline void Address::set_address(const char* value) {
  set_has_address();
  if (address_ == &::google::protobuf::internal::kEmptyString) {
    address_ = new ::std::string;
  }
  address_->assign(value);
}
inline void Address::set_address(const char* value, size_t size) {
  set_has_address();
  if (address_ == &::google::protobuf::internal::kEmptyString) {
    address_ = new ::std::string;
  }
  address_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Address::mutable_address() {
  set_has_address();
  if (address_ == &::google::protobuf::internal::kEmptyString) {
    address_ = new ::std::string;
  }
  return address_;
}
inline ::std::string* Address::release_address() {
  clear_has_address();
  if (address_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = address_;
    address_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// LoadDevice

// required string seed = 1;
inline bool LoadDevice::has_seed() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LoadDevice::set_has_seed() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LoadDevice::clear_has_seed() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LoadDevice::clear_seed() {
  if (seed_ != &::google::protobuf::internal::kEmptyString) {
    seed_->clear();
  }
  clear_has_seed();
}
inline const ::std::string& LoadDevice::seed() const {
  return *seed_;
}
inline void LoadDevice::set_seed(const ::std::string& value) {
  set_has_seed();
  if (seed_ == &::google::protobuf::internal::kEmptyString) {
    seed_ = new ::std::string;
  }
  seed_->assign(value);
}
inline void LoadDevice::set_seed(const char* value) {
  set_has_seed();
  if (seed_ == &::google::protobuf::internal::kEmptyString) {
    seed_ = new ::std::string;
  }
  seed_->assign(value);
}
inline void LoadDevice::set_seed(const char* value, size_t size) {
  set_has_seed();
  if (seed_ == &::google::protobuf::internal::kEmptyString) {
    seed_ = new ::std::string;
  }
  seed_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LoadDevice::mutable_seed() {
  set_has_seed();
  if (seed_ == &::google::protobuf::internal::kEmptyString) {
    seed_ = new ::std::string;
  }
  return seed_;
}
inline ::std::string* LoadDevice::release_seed() {
  clear_has_seed();
  if (seed_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = seed_;
    seed_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional bool otp = 2 [default = true];
inline bool LoadDevice::has_otp() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LoadDevice::set_has_otp() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LoadDevice::clear_has_otp() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LoadDevice::clear_otp() {
  otp_ = true;
  clear_has_otp();
}
inline bool LoadDevice::otp() const {
  return otp_;
}
inline void LoadDevice::set_otp(bool value) {
  set_has_otp();
  otp_ = value;
}

// optional string pin = 3;
inline bool LoadDevice::has_pin() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void LoadDevice::set_has_pin() {
  _has_bits_[0] |= 0x00000004u;
}
inline void LoadDevice::clear_has_pin() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void LoadDevice::clear_pin() {
  if (pin_ != &::google::protobuf::internal::kEmptyString) {
    pin_->clear();
  }
  clear_has_pin();
}
inline const ::std::string& LoadDevice::pin() const {
  return *pin_;
}
inline void LoadDevice::set_pin(const ::std::string& value) {
  set_has_pin();
  if (pin_ == &::google::protobuf::internal::kEmptyString) {
    pin_ = new ::std::string;
  }
  pin_->assign(value);
}
inline void LoadDevice::set_pin(const char* value) {
  set_has_pin();
  if (pin_ == &::google::protobuf::internal::kEmptyString) {
    pin_ = new ::std::string;
  }
  pin_->assign(value);
}
inline void LoadDevice::set_pin(const char* value, size_t size) {
  set_has_pin();
  if (pin_ == &::google::protobuf::internal::kEmptyString) {
    pin_ = new ::std::string;
  }
  pin_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LoadDevice::mutable_pin() {
  set_has_pin();
  if (pin_ == &::google::protobuf::internal::kEmptyString) {
    pin_ = new ::std::string;
  }
  return pin_;
}
inline ::std::string* LoadDevice::release_pin() {
  clear_has_pin();
  if (pin_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = pin_;
    pin_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional bool spv = 4 [default = true];
inline bool LoadDevice::has_spv() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void LoadDevice::set_has_spv() {
  _has_bits_[0] |= 0x00000008u;
}
inline void LoadDevice::clear_has_spv() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void LoadDevice::clear_spv() {
  spv_ = true;
  clear_has_spv();
}
inline bool LoadDevice::spv() const {
  return spv_;
}
inline void LoadDevice::set_spv(bool value) {
  set_has_spv();
  spv_ = value;
}

// -------------------------------------------------------------------

// ResetDevice

// optional bytes random = 7;
inline bool ResetDevice::has_random() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ResetDevice::set_has_random() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ResetDevice::clear_has_random() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ResetDevice::clear_random() {
  if (random_ != &::google::protobuf::internal::kEmptyString) {
    random_->clear();
  }
  clear_has_random();
}
inline const ::std::string& ResetDevice::random() const {
  return *random_;
}
inline void ResetDevice::set_random(const ::std::string& value) {
  set_has_random();
  if (random_ == &::google::protobuf::internal::kEmptyString) {
    random_ = new ::std::string;
  }
  random_->assign(value);
}
inline void ResetDevice::set_random(const char* value) {
  set_has_random();
  if (random_ == &::google::protobuf::internal::kEmptyString) {
    random_ = new ::std::string;
  }
  random_->assign(value);
}
inline void ResetDevice::set_random(const void* value, size_t size) {
  set_has_random();
  if (random_ == &::google::protobuf::internal::kEmptyString) {
    random_ = new ::std::string;
  }
  random_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ResetDevice::mutable_random() {
  set_has_random();
  if (random_ == &::google::protobuf::internal::kEmptyString) {
    random_ = new ::std::string;
  }
  return random_;
}
inline ::std::string* ResetDevice::release_random() {
  clear_has_random();
  if (random_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = random_;
    random_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// SignTx

// required uint32 outputs_count = 3;
inline bool SignTx::has_outputs_count() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SignTx::set_has_outputs_count() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SignTx::clear_has_outputs_count() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SignTx::clear_outputs_count() {
  outputs_count_ = 0u;
  clear_has_outputs_count();
}
inline ::google::protobuf::uint32 SignTx::outputs_count() const {
  return outputs_count_;
}
inline void SignTx::set_outputs_count(::google::protobuf::uint32 value) {
  set_has_outputs_count();
  outputs_count_ = value;
}

// required uint32 inputs_count = 5;
inline bool SignTx::has_inputs_count() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SignTx::set_has_inputs_count() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SignTx::clear_has_inputs_count() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SignTx::clear_inputs_count() {
  inputs_count_ = 0u;
  clear_has_inputs_count();
}
inline ::google::protobuf::uint32 SignTx::inputs_count() const {
  return inputs_count_;
}
inline void SignTx::set_inputs_count(::google::protobuf::uint32 value) {
  set_has_inputs_count();
  inputs_count_ = value;
}

// optional bytes random = 6;
inline bool SignTx::has_random() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SignTx::set_has_random() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SignTx::clear_has_random() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SignTx::clear_random() {
  if (random_ != &::google::protobuf::internal::kEmptyString) {
    random_->clear();
  }
  clear_has_random();
}
inline const ::std::string& SignTx::random() const {
  return *random_;
}
inline void SignTx::set_random(const ::std::string& value) {
  set_has_random();
  if (random_ == &::google::protobuf::internal::kEmptyString) {
    random_ = new ::std::string;
  }
  random_->assign(value);
}
inline void SignTx::set_random(const char* value) {
  set_has_random();
  if (random_ == &::google::protobuf::internal::kEmptyString) {
    random_ = new ::std::string;
  }
  random_->assign(value);
}
inline void SignTx::set_random(const void* value, size_t size) {
  set_has_random();
  if (random_ == &::google::protobuf::internal::kEmptyString) {
    random_ = new ::std::string;
  }
  random_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SignTx::mutable_random() {
  set_has_random();
  if (random_ == &::google::protobuf::internal::kEmptyString) {
    random_ = new ::std::string;
  }
  return random_;
}
inline ::std::string* SignTx::release_random() {
  clear_has_random();
  if (random_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = random_;
    random_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// TxRequest

// optional int32 request_index = 1;
inline bool TxRequest::has_request_index() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TxRequest::set_has_request_index() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TxRequest::clear_has_request_index() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TxRequest::clear_request_index() {
  request_index_ = 0;
  clear_has_request_index();
}
inline ::google::protobuf::int32 TxRequest::request_index() const {
  return request_index_;
}
inline void TxRequest::set_request_index(::google::protobuf::int32 value) {
  set_has_request_index();
  request_index_ = value;
}

// optional .RequestType request_type = 2;
inline bool TxRequest::has_request_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TxRequest::set_has_request_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TxRequest::clear_has_request_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TxRequest::clear_request_type() {
  request_type_ = 0;
  clear_has_request_type();
}
inline RequestType TxRequest::request_type() const {
  return static_cast< RequestType >(request_type_);
}
inline void TxRequest::set_request_type(RequestType value) {
  GOOGLE_DCHECK(RequestType_IsValid(value));
  set_has_request_type();
  request_type_ = value;
}

// optional int32 signed_index = 3;
inline bool TxRequest::has_signed_index() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TxRequest::set_has_signed_index() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TxRequest::clear_has_signed_index() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TxRequest::clear_signed_index() {
  signed_index_ = 0;
  clear_has_signed_index();
}
inline ::google::protobuf::int32 TxRequest::signed_index() const {
  return signed_index_;
}
inline void TxRequest::set_signed_index(::google::protobuf::int32 value) {
  set_has_signed_index();
  signed_index_ = value;
}

// optional bytes signature = 4;
inline bool TxRequest::has_signature() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TxRequest::set_has_signature() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TxRequest::clear_has_signature() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TxRequest::clear_signature() {
  if (signature_ != &::google::protobuf::internal::kEmptyString) {
    signature_->clear();
  }
  clear_has_signature();
}
inline const ::std::string& TxRequest::signature() const {
  return *signature_;
}
inline void TxRequest::set_signature(const ::std::string& value) {
  set_has_signature();
  if (signature_ == &::google::protobuf::internal::kEmptyString) {
    signature_ = new ::std::string;
  }
  signature_->assign(value);
}
inline void TxRequest::set_signature(const char* value) {
  set_has_signature();
  if (signature_ == &::google::protobuf::internal::kEmptyString) {
    signature_ = new ::std::string;
  }
  signature_->assign(value);
}
inline void TxRequest::set_signature(const void* value, size_t size) {
  set_has_signature();
  if (signature_ == &::google::protobuf::internal::kEmptyString) {
    signature_ = new ::std::string;
  }
  signature_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TxRequest::mutable_signature() {
  set_has_signature();
  if (signature_ == &::google::protobuf::internal::kEmptyString) {
    signature_ = new ::std::string;
  }
  return signature_;
}
inline ::std::string* TxRequest::release_signature() {
  clear_has_signature();
  if (signature_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = signature_;
    signature_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional bytes serialized_tx = 5;
inline bool TxRequest::has_serialized_tx() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TxRequest::set_has_serialized_tx() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TxRequest::clear_has_serialized_tx() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TxRequest::clear_serialized_tx() {
  if (serialized_tx_ != &::google::protobuf::internal::kEmptyString) {
    serialized_tx_->clear();
  }
  clear_has_serialized_tx();
}
inline const ::std::string& TxRequest::serialized_tx() const {
  return *serialized_tx_;
}
inline void TxRequest::set_serialized_tx(const ::std::string& value) {
  set_has_serialized_tx();
  if (serialized_tx_ == &::google::protobuf::internal::kEmptyString) {
    serialized_tx_ = new ::std::string;
  }
  serialized_tx_->assign(value);
}
inline void TxRequest::set_serialized_tx(const char* value) {
  set_has_serialized_tx();
  if (serialized_tx_ == &::google::protobuf::internal::kEmptyString) {
    serialized_tx_ = new ::std::string;
  }
  serialized_tx_->assign(value);
}
inline void TxRequest::set_serialized_tx(const void* value, size_t size) {
  set_has_serialized_tx();
  if (serialized_tx_ == &::google::protobuf::internal::kEmptyString) {
    serialized_tx_ = new ::std::string;
  }
  serialized_tx_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TxRequest::mutable_serialized_tx() {
  set_has_serialized_tx();
  if (serialized_tx_ == &::google::protobuf::internal::kEmptyString) {
    serialized_tx_ = new ::std::string;
  }
  return serialized_tx_;
}
inline ::std::string* TxRequest::release_serialized_tx() {
  clear_has_serialized_tx();
  if (serialized_tx_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = serialized_tx_;
    serialized_tx_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// TxInput

// required uint32 index = 1;
inline bool TxInput::has_index() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TxInput::set_has_index() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TxInput::clear_has_index() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TxInput::clear_index() {
  index_ = 0u;
  clear_has_index();
}
inline ::google::protobuf::uint32 TxInput::index() const {
  return index_;
}
inline void TxInput::set_index(::google::protobuf::uint32 value) {
  set_has_index();
  index_ = value;
}

// repeated uint32 address_n = 2;
inline int TxInput::address_n_size() const {
  return address_n_.size();
}
inline void TxInput::clear_address_n() {
  address_n_.Clear();
}
inline ::google::protobuf::uint32 TxInput::address_n(int index) const {
  return address_n_.Get(index);
}
inline void TxInput::set_address_n(int index, ::google::protobuf::uint32 value) {
  address_n_.Set(index, value);
}
inline void TxInput::add_address_n(::google::protobuf::uint32 value) {
  address_n_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
TxInput::address_n() const {
  return address_n_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
TxInput::mutable_address_n() {
  return &address_n_;
}

// required uint64 amount = 3;
inline bool TxInput::has_amount() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TxInput::set_has_amount() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TxInput::clear_has_amount() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TxInput::clear_amount() {
  amount_ = GOOGLE_ULONGLONG(0);
  clear_has_amount();
}
inline ::google::protobuf::uint64 TxInput::amount() const {
  return amount_;
}
inline void TxInput::set_amount(::google::protobuf::uint64 value) {
  set_has_amount();
  amount_ = value;
}

// required bytes prev_hash = 4;
inline bool TxInput::has_prev_hash() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TxInput::set_has_prev_hash() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TxInput::clear_has_prev_hash() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TxInput::clear_prev_hash() {
  if (prev_hash_ != &::google::protobuf::internal::kEmptyString) {
    prev_hash_->clear();
  }
  clear_has_prev_hash();
}
inline const ::std::string& TxInput::prev_hash() const {
  return *prev_hash_;
}
inline void TxInput::set_prev_hash(const ::std::string& value) {
  set_has_prev_hash();
  if (prev_hash_ == &::google::protobuf::internal::kEmptyString) {
    prev_hash_ = new ::std::string;
  }
  prev_hash_->assign(value);
}
inline void TxInput::set_prev_hash(const char* value) {
  set_has_prev_hash();
  if (prev_hash_ == &::google::protobuf::internal::kEmptyString) {
    prev_hash_ = new ::std::string;
  }
  prev_hash_->assign(value);
}
inline void TxInput::set_prev_hash(const void* value, size_t size) {
  set_has_prev_hash();
  if (prev_hash_ == &::google::protobuf::internal::kEmptyString) {
    prev_hash_ = new ::std::string;
  }
  prev_hash_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TxInput::mutable_prev_hash() {
  set_has_prev_hash();
  if (prev_hash_ == &::google::protobuf::internal::kEmptyString) {
    prev_hash_ = new ::std::string;
  }
  return prev_hash_;
}
inline ::std::string* TxInput::release_prev_hash() {
  clear_has_prev_hash();
  if (prev_hash_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = prev_hash_;
    prev_hash_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required uint32 prev_index = 5;
inline bool TxInput::has_prev_index() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TxInput::set_has_prev_index() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TxInput::clear_has_prev_index() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TxInput::clear_prev_index() {
  prev_index_ = 0u;
  clear_has_prev_index();
}
inline ::google::protobuf::uint32 TxInput::prev_index() const {
  return prev_index_;
}
inline void TxInput::set_prev_index(::google::protobuf::uint32 value) {
  set_has_prev_index();
  prev_index_ = value;
}

// optional bytes script_sig = 6;
inline bool TxInput::has_script_sig() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TxInput::set_has_script_sig() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TxInput::clear_has_script_sig() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TxInput::clear_script_sig() {
  if (script_sig_ != &::google::protobuf::internal::kEmptyString) {
    script_sig_->clear();
  }
  clear_has_script_sig();
}
inline const ::std::string& TxInput::script_sig() const {
  return *script_sig_;
}
inline void TxInput::set_script_sig(const ::std::string& value) {
  set_has_script_sig();
  if (script_sig_ == &::google::protobuf::internal::kEmptyString) {
    script_sig_ = new ::std::string;
  }
  script_sig_->assign(value);
}
inline void TxInput::set_script_sig(const char* value) {
  set_has_script_sig();
  if (script_sig_ == &::google::protobuf::internal::kEmptyString) {
    script_sig_ = new ::std::string;
  }
  script_sig_->assign(value);
}
inline void TxInput::set_script_sig(const void* value, size_t size) {
  set_has_script_sig();
  if (script_sig_ == &::google::protobuf::internal::kEmptyString) {
    script_sig_ = new ::std::string;
  }
  script_sig_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TxInput::mutable_script_sig() {
  set_has_script_sig();
  if (script_sig_ == &::google::protobuf::internal::kEmptyString) {
    script_sig_ = new ::std::string;
  }
  return script_sig_;
}
inline ::std::string* TxInput::release_script_sig() {
  clear_has_script_sig();
  if (script_sig_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = script_sig_;
    script_sig_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// TxOutput

// required uint32 index = 1;
inline bool TxOutput::has_index() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TxOutput::set_has_index() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TxOutput::clear_has_index() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TxOutput::clear_index() {
  index_ = 0u;
  clear_has_index();
}
inline ::google::protobuf::uint32 TxOutput::index() const {
  return index_;
}
inline void TxOutput::set_index(::google::protobuf::uint32 value) {
  set_has_index();
  index_ = value;
}

// required string address = 2;
inline bool TxOutput::has_address() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TxOutput::set_has_address() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TxOutput::clear_has_address() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TxOutput::clear_address() {
  if (address_ != &::google::protobuf::internal::kEmptyString) {
    address_->clear();
  }
  clear_has_address();
}
inline const ::std::string& TxOutput::address() const {
  return *address_;
}
inline void TxOutput::set_address(const ::std::string& value) {
  set_has_address();
  if (address_ == &::google::protobuf::internal::kEmptyString) {
    address_ = new ::std::string;
  }
  address_->assign(value);
}
inline void TxOutput::set_address(const char* value) {
  set_has_address();
  if (address_ == &::google::protobuf::internal::kEmptyString) {
    address_ = new ::std::string;
  }
  address_->assign(value);
}
inline void TxOutput::set_address(const char* value, size_t size) {
  set_has_address();
  if (address_ == &::google::protobuf::internal::kEmptyString) {
    address_ = new ::std::string;
  }
  address_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TxOutput::mutable_address() {
  set_has_address();
  if (address_ == &::google::protobuf::internal::kEmptyString) {
    address_ = new ::std::string;
  }
  return address_;
}
inline ::std::string* TxOutput::release_address() {
  clear_has_address();
  if (address_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = address_;
    address_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// repeated uint32 address_n = 3;
inline int TxOutput::address_n_size() const {
  return address_n_.size();
}
inline void TxOutput::clear_address_n() {
  address_n_.Clear();
}
inline ::google::protobuf::uint32 TxOutput::address_n(int index) const {
  return address_n_.Get(index);
}
inline void TxOutput::set_address_n(int index, ::google::protobuf::uint32 value) {
  address_n_.Set(index, value);
}
inline void TxOutput::add_address_n(::google::protobuf::uint32 value) {
  address_n_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
TxOutput::address_n() const {
  return address_n_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
TxOutput::mutable_address_n() {
  return &address_n_;
}

// required uint64 amount = 4;
inline bool TxOutput::has_amount() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TxOutput::set_has_amount() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TxOutput::clear_has_amount() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TxOutput::clear_amount() {
  amount_ = GOOGLE_ULONGLONG(0);
  clear_has_amount();
}
inline ::google::protobuf::uint64 TxOutput::amount() const {
  return amount_;
}
inline void TxOutput::set_amount(::google::protobuf::uint64 value) {
  set_has_amount();
  amount_ = value;
}

// required .ScriptType script_type = 5;
inline bool TxOutput::has_script_type() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TxOutput::set_has_script_type() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TxOutput::clear_has_script_type() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TxOutput::clear_script_type() {
  script_type_ = 0;
  clear_has_script_type();
}
inline ScriptType TxOutput::script_type() const {
  return static_cast< ScriptType >(script_type_);
}
inline void TxOutput::set_script_type(ScriptType value) {
  GOOGLE_DCHECK(ScriptType_IsValid(value));
  set_has_script_type();
  script_type_ = value;
}

// repeated bytes script_args = 6;
inline int TxOutput::script_args_size() const {
  return script_args_.size();
}
inline void TxOutput::clear_script_args() {
  script_args_.Clear();
}
inline const ::std::string& TxOutput::script_args(int index) const {
  return script_args_.Get(index);
}
inline ::std::string* TxOutput::mutable_script_args(int index) {
  return script_args_.Mutable(index);
}
inline void TxOutput::set_script_args(int index, const ::std::string& value) {
  script_args_.Mutable(index)->assign(value);
}
inline void TxOutput::set_script_args(int index, const char* value) {
  script_args_.Mutable(index)->assign(value);
}
inline void TxOutput::set_script_args(int index, const void* value, size_t size) {
  script_args_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TxOutput::add_script_args() {
  return script_args_.Add();
}
inline void TxOutput::add_script_args(const ::std::string& value) {
  script_args_.Add()->assign(value);
}
inline void TxOutput::add_script_args(const char* value) {
  script_args_.Add()->assign(value);
}
inline void TxOutput::add_script_args(const void* value, size_t size) {
  script_args_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
TxOutput::script_args() const {
  return script_args_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
TxOutput::mutable_script_args() {
  return &script_args_;
}


// @@protoc_insertion_point(namespace_scope)

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< Algorithm>() {
  return Algorithm_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ScriptType>() {
  return ScriptType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< RequestType>() {
  return RequestType_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_bitkey_2eproto__INCLUDED
