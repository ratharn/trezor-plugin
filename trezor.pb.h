// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: trezor.proto

#ifndef PROTOBUF_trezor_2eproto__INCLUDED
#define PROTOBUF_trezor_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_trezor_2eproto();
void protobuf_AssignDesc_trezor_2eproto();
void protobuf_ShutdownFile_trezor_2eproto();

class XprvType;
class CoinType;
class SettingsType;
class Initialize;
class Features;
class ApplySettings;
class Ping;
class DebugLinkDecision;
class DebugLinkGetState;
class DebugLinkState;
class DebugLinkStop;
class Success;
class Failure;
class ButtonRequest;
class ButtonAck;
class ButtonCancel;
class PinMatrixRequest;
class PinMatrixAck;
class PinMatrixCancel;
class GetEntropy;
class Entropy;
class GetMasterPublicKey;
class MasterPublicKey;
class GetAddress;
class Address;
class LoadDevice;
class ResetDevice;
class SignTx;
class SimpleSignTx;
class TxRequest;
class TxInput;
class TxOutput;

enum ScriptType {
  PAYTOADDRESS = 0,
  PAYTOSCRIPTHASH = 1
};
bool ScriptType_IsValid(int value);
const ScriptType ScriptType_MIN = PAYTOADDRESS;
const ScriptType ScriptType_MAX = PAYTOSCRIPTHASH;
const int ScriptType_ARRAYSIZE = ScriptType_MAX + 1;

const ::google::protobuf::EnumDescriptor* ScriptType_descriptor();
inline const ::std::string& ScriptType_Name(ScriptType value) {
  return ::google::protobuf::internal::NameOfEnum(
    ScriptType_descriptor(), value);
}
inline bool ScriptType_Parse(
    const ::std::string& name, ScriptType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ScriptType>(
    ScriptType_descriptor(), name, value);
}
enum RequestType {
  TXINPUT = 0,
  TXOUTPUT = 1
};
bool RequestType_IsValid(int value);
const RequestType RequestType_MIN = TXINPUT;
const RequestType RequestType_MAX = TXOUTPUT;
const int RequestType_ARRAYSIZE = RequestType_MAX + 1;

const ::google::protobuf::EnumDescriptor* RequestType_descriptor();
inline const ::std::string& RequestType_Name(RequestType value) {
  return ::google::protobuf::internal::NameOfEnum(
    RequestType_descriptor(), value);
}
inline bool RequestType_Parse(
    const ::std::string& name, RequestType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<RequestType>(
    RequestType_descriptor(), name, value);
}
// ===================================================================

class XprvType : public ::google::protobuf::Message {
 public:
  XprvType();
  virtual ~XprvType();

  XprvType(const XprvType& from);

  inline XprvType& operator=(const XprvType& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const XprvType& default_instance();

  void Swap(XprvType* other);

  // implements Message ----------------------------------------------

  XprvType* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const XprvType& from);
  void MergeFrom(const XprvType& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes version = 1;
  inline bool has_version() const;
  inline void clear_version();
  static const int kVersionFieldNumber = 1;
  inline const ::std::string& version() const;
  inline void set_version(const ::std::string& value);
  inline void set_version(const char* value);
  inline void set_version(const void* value, size_t size);
  inline ::std::string* mutable_version();
  inline ::std::string* release_version();
  inline void set_allocated_version(::std::string* version);

  // required uint32 depth = 2;
  inline bool has_depth() const;
  inline void clear_depth();
  static const int kDepthFieldNumber = 2;
  inline ::google::protobuf::uint32 depth() const;
  inline void set_depth(::google::protobuf::uint32 value);

  // required uint32 fingerprint = 3;
  inline bool has_fingerprint() const;
  inline void clear_fingerprint();
  static const int kFingerprintFieldNumber = 3;
  inline ::google::protobuf::uint32 fingerprint() const;
  inline void set_fingerprint(::google::protobuf::uint32 value);

  // required uint32 child_num = 4;
  inline bool has_child_num() const;
  inline void clear_child_num();
  static const int kChildNumFieldNumber = 4;
  inline ::google::protobuf::uint32 child_num() const;
  inline void set_child_num(::google::protobuf::uint32 value);

  // required bytes chain_code = 5;
  inline bool has_chain_code() const;
  inline void clear_chain_code();
  static const int kChainCodeFieldNumber = 5;
  inline const ::std::string& chain_code() const;
  inline void set_chain_code(const ::std::string& value);
  inline void set_chain_code(const char* value);
  inline void set_chain_code(const void* value, size_t size);
  inline ::std::string* mutable_chain_code();
  inline ::std::string* release_chain_code();
  inline void set_allocated_chain_code(::std::string* chain_code);

  // required bytes private_key = 6;
  inline bool has_private_key() const;
  inline void clear_private_key();
  static const int kPrivateKeyFieldNumber = 6;
  inline const ::std::string& private_key() const;
  inline void set_private_key(const ::std::string& value);
  inline void set_private_key(const char* value);
  inline void set_private_key(const void* value, size_t size);
  inline ::std::string* mutable_private_key();
  inline ::std::string* release_private_key();
  inline void set_allocated_private_key(::std::string* private_key);

  // @@protoc_insertion_point(class_scope:XprvType)
 private:
  inline void set_has_version();
  inline void clear_has_version();
  inline void set_has_depth();
  inline void clear_has_depth();
  inline void set_has_fingerprint();
  inline void clear_has_fingerprint();
  inline void set_has_child_num();
  inline void clear_has_child_num();
  inline void set_has_chain_code();
  inline void clear_has_chain_code();
  inline void set_has_private_key();
  inline void clear_has_private_key();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* version_;
  ::google::protobuf::uint32 depth_;
  ::google::protobuf::uint32 fingerprint_;
  ::std::string* chain_code_;
  ::std::string* private_key_;
  ::google::protobuf::uint32 child_num_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_trezor_2eproto();
  friend void protobuf_AssignDesc_trezor_2eproto();
  friend void protobuf_ShutdownFile_trezor_2eproto();

  void InitAsDefaultInstance();
  static XprvType* default_instance_;
};
// -------------------------------------------------------------------

class CoinType : public ::google::protobuf::Message {
 public:
  CoinType();
  virtual ~CoinType();

  CoinType(const CoinType& from);

  inline CoinType& operator=(const CoinType& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CoinType& default_instance();

  void Swap(CoinType* other);

  // implements Message ----------------------------------------------

  CoinType* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CoinType& from);
  void MergeFrom(const CoinType& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes coin_name = 2;
  inline bool has_coin_name() const;
  inline void clear_coin_name();
  static const int kCoinNameFieldNumber = 2;
  inline const ::std::string& coin_name() const;
  inline void set_coin_name(const ::std::string& value);
  inline void set_coin_name(const char* value);
  inline void set_coin_name(const void* value, size_t size);
  inline ::std::string* mutable_coin_name();
  inline ::std::string* release_coin_name();
  inline void set_allocated_coin_name(::std::string* coin_name);

  // optional bytes coin_shortcut = 3;
  inline bool has_coin_shortcut() const;
  inline void clear_coin_shortcut();
  static const int kCoinShortcutFieldNumber = 3;
  inline const ::std::string& coin_shortcut() const;
  inline void set_coin_shortcut(const ::std::string& value);
  inline void set_coin_shortcut(const char* value);
  inline void set_coin_shortcut(const void* value, size_t size);
  inline ::std::string* mutable_coin_shortcut();
  inline ::std::string* release_coin_shortcut();
  inline void set_allocated_coin_shortcut(::std::string* coin_shortcut);

  // optional uint32 address_type = 4;
  inline bool has_address_type() const;
  inline void clear_address_type();
  static const int kAddressTypeFieldNumber = 4;
  inline ::google::protobuf::uint32 address_type() const;
  inline void set_address_type(::google::protobuf::uint32 value);

  // optional uint64 maxfee_kb = 5;
  inline bool has_maxfee_kb() const;
  inline void clear_maxfee_kb();
  static const int kMaxfeeKbFieldNumber = 5;
  inline ::google::protobuf::uint64 maxfee_kb() const;
  inline void set_maxfee_kb(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:CoinType)
 private:
  inline void set_has_coin_name();
  inline void clear_has_coin_name();
  inline void set_has_coin_shortcut();
  inline void clear_has_coin_shortcut();
  inline void set_has_address_type();
  inline void clear_has_address_type();
  inline void set_has_maxfee_kb();
  inline void clear_has_maxfee_kb();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* coin_name_;
  ::std::string* coin_shortcut_;
  ::google::protobuf::uint64 maxfee_kb_;
  ::google::protobuf::uint32 address_type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_trezor_2eproto();
  friend void protobuf_AssignDesc_trezor_2eproto();
  friend void protobuf_ShutdownFile_trezor_2eproto();

  void InitAsDefaultInstance();
  static CoinType* default_instance_;
};
// -------------------------------------------------------------------

class SettingsType : public ::google::protobuf::Message {
 public:
  SettingsType();
  virtual ~SettingsType();

  SettingsType(const SettingsType& from);

  inline SettingsType& operator=(const SettingsType& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SettingsType& default_instance();

  void Swap(SettingsType* other);

  // implements Message ----------------------------------------------

  SettingsType* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SettingsType& from);
  void MergeFrom(const SettingsType& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes language = 1;
  inline bool has_language() const;
  inline void clear_language();
  static const int kLanguageFieldNumber = 1;
  inline const ::std::string& language() const;
  inline void set_language(const ::std::string& value);
  inline void set_language(const char* value);
  inline void set_language(const void* value, size_t size);
  inline ::std::string* mutable_language();
  inline ::std::string* release_language();
  inline void set_allocated_language(::std::string* language);

  // optional .CoinType coin = 2;
  inline bool has_coin() const;
  inline void clear_coin();
  static const int kCoinFieldNumber = 2;
  inline const ::CoinType& coin() const;
  inline ::CoinType* mutable_coin();
  inline ::CoinType* release_coin();
  inline void set_allocated_coin(::CoinType* coin);

  // optional bytes label = 3;
  inline bool has_label() const;
  inline void clear_label();
  static const int kLabelFieldNumber = 3;
  inline const ::std::string& label() const;
  inline void set_label(const ::std::string& value);
  inline void set_label(const char* value);
  inline void set_label(const void* value, size_t size);
  inline ::std::string* mutable_label();
  inline ::std::string* release_label();
  inline void set_allocated_label(::std::string* label);

  // @@protoc_insertion_point(class_scope:SettingsType)
 private:
  inline void set_has_language();
  inline void clear_has_language();
  inline void set_has_coin();
  inline void clear_has_coin();
  inline void set_has_label();
  inline void clear_has_label();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* language_;
  ::CoinType* coin_;
  ::std::string* label_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_trezor_2eproto();
  friend void protobuf_AssignDesc_trezor_2eproto();
  friend void protobuf_ShutdownFile_trezor_2eproto();

  void InitAsDefaultInstance();
  static SettingsType* default_instance_;
};
// -------------------------------------------------------------------

class Initialize : public ::google::protobuf::Message {
 public:
  Initialize();
  virtual ~Initialize();

  Initialize(const Initialize& from);

  inline Initialize& operator=(const Initialize& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Initialize& default_instance();

  void Swap(Initialize* other);

  // implements Message ----------------------------------------------

  Initialize* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Initialize& from);
  void MergeFrom(const Initialize& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:Initialize)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;


  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];

  friend void  protobuf_AddDesc_trezor_2eproto();
  friend void protobuf_AssignDesc_trezor_2eproto();
  friend void protobuf_ShutdownFile_trezor_2eproto();

  void InitAsDefaultInstance();
  static Initialize* default_instance_;
};
// -------------------------------------------------------------------

class Features : public ::google::protobuf::Message {
 public:
  Features();
  virtual ~Features();

  Features(const Features& from);

  inline Features& operator=(const Features& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Features& default_instance();

  void Swap(Features* other);

  // implements Message ----------------------------------------------

  Features* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Features& from);
  void MergeFrom(const Features& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes vendor = 1;
  inline bool has_vendor() const;
  inline void clear_vendor();
  static const int kVendorFieldNumber = 1;
  inline const ::std::string& vendor() const;
  inline void set_vendor(const ::std::string& value);
  inline void set_vendor(const char* value);
  inline void set_vendor(const void* value, size_t size);
  inline ::std::string* mutable_vendor();
  inline ::std::string* release_vendor();
  inline void set_allocated_vendor(::std::string* vendor);

  // optional uint32 major_version = 2;
  inline bool has_major_version() const;
  inline void clear_major_version();
  static const int kMajorVersionFieldNumber = 2;
  inline ::google::protobuf::uint32 major_version() const;
  inline void set_major_version(::google::protobuf::uint32 value);

  // optional uint32 minor_version = 3;
  inline bool has_minor_version() const;
  inline void clear_minor_version();
  static const int kMinorVersionFieldNumber = 3;
  inline ::google::protobuf::uint32 minor_version() const;
  inline void set_minor_version(::google::protobuf::uint32 value);

  // optional .SettingsType settings = 4;
  inline bool has_settings() const;
  inline void clear_settings();
  static const int kSettingsFieldNumber = 4;
  inline const ::SettingsType& settings() const;
  inline ::SettingsType* mutable_settings();
  inline ::SettingsType* release_settings();
  inline void set_allocated_settings(::SettingsType* settings);

  // optional bytes serial_number = 5;
  inline bool has_serial_number() const;
  inline void clear_serial_number();
  static const int kSerialNumberFieldNumber = 5;
  inline const ::std::string& serial_number() const;
  inline void set_serial_number(const ::std::string& value);
  inline void set_serial_number(const char* value);
  inline void set_serial_number(const void* value, size_t size);
  inline ::std::string* mutable_serial_number();
  inline ::std::string* release_serial_number();
  inline void set_allocated_serial_number(::std::string* serial_number);

  // @@protoc_insertion_point(class_scope:Features)
 private:
  inline void set_has_vendor();
  inline void clear_has_vendor();
  inline void set_has_major_version();
  inline void clear_has_major_version();
  inline void set_has_minor_version();
  inline void clear_has_minor_version();
  inline void set_has_settings();
  inline void clear_has_settings();
  inline void set_has_serial_number();
  inline void clear_has_serial_number();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* vendor_;
  ::google::protobuf::uint32 major_version_;
  ::google::protobuf::uint32 minor_version_;
  ::SettingsType* settings_;
  ::std::string* serial_number_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_trezor_2eproto();
  friend void protobuf_AssignDesc_trezor_2eproto();
  friend void protobuf_ShutdownFile_trezor_2eproto();

  void InitAsDefaultInstance();
  static Features* default_instance_;
};
// -------------------------------------------------------------------

class ApplySettings : public ::google::protobuf::Message {
 public:
  ApplySettings();
  virtual ~ApplySettings();

  ApplySettings(const ApplySettings& from);

  inline ApplySettings& operator=(const ApplySettings& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ApplySettings& default_instance();

  void Swap(ApplySettings* other);

  // implements Message ----------------------------------------------

  ApplySettings* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ApplySettings& from);
  void MergeFrom(const ApplySettings& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes language = 1;
  inline bool has_language() const;
  inline void clear_language();
  static const int kLanguageFieldNumber = 1;
  inline const ::std::string& language() const;
  inline void set_language(const ::std::string& value);
  inline void set_language(const char* value);
  inline void set_language(const void* value, size_t size);
  inline ::std::string* mutable_language();
  inline ::std::string* release_language();
  inline void set_allocated_language(::std::string* language);

  // optional bytes coin_shortcut = 2;
  inline bool has_coin_shortcut() const;
  inline void clear_coin_shortcut();
  static const int kCoinShortcutFieldNumber = 2;
  inline const ::std::string& coin_shortcut() const;
  inline void set_coin_shortcut(const ::std::string& value);
  inline void set_coin_shortcut(const char* value);
  inline void set_coin_shortcut(const void* value, size_t size);
  inline ::std::string* mutable_coin_shortcut();
  inline ::std::string* release_coin_shortcut();
  inline void set_allocated_coin_shortcut(::std::string* coin_shortcut);

  // optional bytes label = 3;
  inline bool has_label() const;
  inline void clear_label();
  static const int kLabelFieldNumber = 3;
  inline const ::std::string& label() const;
  inline void set_label(const ::std::string& value);
  inline void set_label(const char* value);
  inline void set_label(const void* value, size_t size);
  inline ::std::string* mutable_label();
  inline ::std::string* release_label();
  inline void set_allocated_label(::std::string* label);

  // @@protoc_insertion_point(class_scope:ApplySettings)
 private:
  inline void set_has_language();
  inline void clear_has_language();
  inline void set_has_coin_shortcut();
  inline void clear_has_coin_shortcut();
  inline void set_has_label();
  inline void clear_has_label();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* language_;
  ::std::string* coin_shortcut_;
  ::std::string* label_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_trezor_2eproto();
  friend void protobuf_AssignDesc_trezor_2eproto();
  friend void protobuf_ShutdownFile_trezor_2eproto();

  void InitAsDefaultInstance();
  static ApplySettings* default_instance_;
};
// -------------------------------------------------------------------

class Ping : public ::google::protobuf::Message {
 public:
  Ping();
  virtual ~Ping();

  Ping(const Ping& from);

  inline Ping& operator=(const Ping& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Ping& default_instance();

  void Swap(Ping* other);

  // implements Message ----------------------------------------------

  Ping* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Ping& from);
  void MergeFrom(const Ping& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes message = 1;
  inline bool has_message() const;
  inline void clear_message();
  static const int kMessageFieldNumber = 1;
  inline const ::std::string& message() const;
  inline void set_message(const ::std::string& value);
  inline void set_message(const char* value);
  inline void set_message(const void* value, size_t size);
  inline ::std::string* mutable_message();
  inline ::std::string* release_message();
  inline void set_allocated_message(::std::string* message);

  // @@protoc_insertion_point(class_scope:Ping)
 private:
  inline void set_has_message();
  inline void clear_has_message();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* message_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_trezor_2eproto();
  friend void protobuf_AssignDesc_trezor_2eproto();
  friend void protobuf_ShutdownFile_trezor_2eproto();

  void InitAsDefaultInstance();
  static Ping* default_instance_;
};
// -------------------------------------------------------------------

class DebugLinkDecision : public ::google::protobuf::Message {
 public:
  DebugLinkDecision();
  virtual ~DebugLinkDecision();

  DebugLinkDecision(const DebugLinkDecision& from);

  inline DebugLinkDecision& operator=(const DebugLinkDecision& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DebugLinkDecision& default_instance();

  void Swap(DebugLinkDecision* other);

  // implements Message ----------------------------------------------

  DebugLinkDecision* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DebugLinkDecision& from);
  void MergeFrom(const DebugLinkDecision& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bool yes_no = 1;
  inline bool has_yes_no() const;
  inline void clear_yes_no();
  static const int kYesNoFieldNumber = 1;
  inline bool yes_no() const;
  inline void set_yes_no(bool value);

  // @@protoc_insertion_point(class_scope:DebugLinkDecision)
 private:
  inline void set_has_yes_no();
  inline void clear_has_yes_no();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  bool yes_no_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_trezor_2eproto();
  friend void protobuf_AssignDesc_trezor_2eproto();
  friend void protobuf_ShutdownFile_trezor_2eproto();

  void InitAsDefaultInstance();
  static DebugLinkDecision* default_instance_;
};
// -------------------------------------------------------------------

class DebugLinkGetState : public ::google::protobuf::Message {
 public:
  DebugLinkGetState();
  virtual ~DebugLinkGetState();

  DebugLinkGetState(const DebugLinkGetState& from);

  inline DebugLinkGetState& operator=(const DebugLinkGetState& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DebugLinkGetState& default_instance();

  void Swap(DebugLinkGetState* other);

  // implements Message ----------------------------------------------

  DebugLinkGetState* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DebugLinkGetState& from);
  void MergeFrom(const DebugLinkGetState& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool layout = 1;
  inline bool has_layout() const;
  inline void clear_layout();
  static const int kLayoutFieldNumber = 1;
  inline bool layout() const;
  inline void set_layout(bool value);

  // optional bool pin = 2;
  inline bool has_pin() const;
  inline void clear_pin();
  static const int kPinFieldNumber = 2;
  inline bool pin() const;
  inline void set_pin(bool value);

  // optional bool matrix = 3;
  inline bool has_matrix() const;
  inline void clear_matrix();
  static const int kMatrixFieldNumber = 3;
  inline bool matrix() const;
  inline void set_matrix(bool value);

  // optional bool seed = 4;
  inline bool has_seed() const;
  inline void clear_seed();
  static const int kSeedFieldNumber = 4;
  inline bool seed() const;
  inline void set_seed(bool value);

  // @@protoc_insertion_point(class_scope:DebugLinkGetState)
 private:
  inline void set_has_layout();
  inline void clear_has_layout();
  inline void set_has_pin();
  inline void clear_has_pin();
  inline void set_has_matrix();
  inline void clear_has_matrix();
  inline void set_has_seed();
  inline void clear_has_seed();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  bool layout_;
  bool pin_;
  bool matrix_;
  bool seed_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_trezor_2eproto();
  friend void protobuf_AssignDesc_trezor_2eproto();
  friend void protobuf_ShutdownFile_trezor_2eproto();

  void InitAsDefaultInstance();
  static DebugLinkGetState* default_instance_;
};
// -------------------------------------------------------------------

class DebugLinkState : public ::google::protobuf::Message {
 public:
  DebugLinkState();
  virtual ~DebugLinkState();

  DebugLinkState(const DebugLinkState& from);

  inline DebugLinkState& operator=(const DebugLinkState& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DebugLinkState& default_instance();

  void Swap(DebugLinkState* other);

  // implements Message ----------------------------------------------

  DebugLinkState* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DebugLinkState& from);
  void MergeFrom(const DebugLinkState& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes layout = 1;
  inline bool has_layout() const;
  inline void clear_layout();
  static const int kLayoutFieldNumber = 1;
  inline const ::std::string& layout() const;
  inline void set_layout(const ::std::string& value);
  inline void set_layout(const char* value);
  inline void set_layout(const void* value, size_t size);
  inline ::std::string* mutable_layout();
  inline ::std::string* release_layout();
  inline void set_allocated_layout(::std::string* layout);

  // optional bytes pin = 2;
  inline bool has_pin() const;
  inline void clear_pin();
  static const int kPinFieldNumber = 2;
  inline const ::std::string& pin() const;
  inline void set_pin(const ::std::string& value);
  inline void set_pin(const char* value);
  inline void set_pin(const void* value, size_t size);
  inline ::std::string* mutable_pin();
  inline ::std::string* release_pin();
  inline void set_allocated_pin(::std::string* pin);

  // optional bytes matrix = 3;
  inline bool has_matrix() const;
  inline void clear_matrix();
  static const int kMatrixFieldNumber = 3;
  inline const ::std::string& matrix() const;
  inline void set_matrix(const ::std::string& value);
  inline void set_matrix(const char* value);
  inline void set_matrix(const void* value, size_t size);
  inline ::std::string* mutable_matrix();
  inline ::std::string* release_matrix();
  inline void set_allocated_matrix(::std::string* matrix);

  // optional bytes seed = 4;
  inline bool has_seed() const;
  inline void clear_seed();
  static const int kSeedFieldNumber = 4;
  inline const ::std::string& seed() const;
  inline void set_seed(const ::std::string& value);
  inline void set_seed(const char* value);
  inline void set_seed(const void* value, size_t size);
  inline ::std::string* mutable_seed();
  inline ::std::string* release_seed();
  inline void set_allocated_seed(::std::string* seed);

  // @@protoc_insertion_point(class_scope:DebugLinkState)
 private:
  inline void set_has_layout();
  inline void clear_has_layout();
  inline void set_has_pin();
  inline void clear_has_pin();
  inline void set_has_matrix();
  inline void clear_has_matrix();
  inline void set_has_seed();
  inline void clear_has_seed();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* layout_;
  ::std::string* pin_;
  ::std::string* matrix_;
  ::std::string* seed_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_trezor_2eproto();
  friend void protobuf_AssignDesc_trezor_2eproto();
  friend void protobuf_ShutdownFile_trezor_2eproto();

  void InitAsDefaultInstance();
  static DebugLinkState* default_instance_;
};
// -------------------------------------------------------------------

class DebugLinkStop : public ::google::protobuf::Message {
 public:
  DebugLinkStop();
  virtual ~DebugLinkStop();

  DebugLinkStop(const DebugLinkStop& from);

  inline DebugLinkStop& operator=(const DebugLinkStop& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DebugLinkStop& default_instance();

  void Swap(DebugLinkStop* other);

  // implements Message ----------------------------------------------

  DebugLinkStop* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DebugLinkStop& from);
  void MergeFrom(const DebugLinkStop& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:DebugLinkStop)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;


  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];

  friend void  protobuf_AddDesc_trezor_2eproto();
  friend void protobuf_AssignDesc_trezor_2eproto();
  friend void protobuf_ShutdownFile_trezor_2eproto();

  void InitAsDefaultInstance();
  static DebugLinkStop* default_instance_;
};
// -------------------------------------------------------------------

class Success : public ::google::protobuf::Message {
 public:
  Success();
  virtual ~Success();

  Success(const Success& from);

  inline Success& operator=(const Success& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Success& default_instance();

  void Swap(Success* other);

  // implements Message ----------------------------------------------

  Success* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Success& from);
  void MergeFrom(const Success& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes message = 1;
  inline bool has_message() const;
  inline void clear_message();
  static const int kMessageFieldNumber = 1;
  inline const ::std::string& message() const;
  inline void set_message(const ::std::string& value);
  inline void set_message(const char* value);
  inline void set_message(const void* value, size_t size);
  inline ::std::string* mutable_message();
  inline ::std::string* release_message();
  inline void set_allocated_message(::std::string* message);

  // @@protoc_insertion_point(class_scope:Success)
 private:
  inline void set_has_message();
  inline void clear_has_message();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* message_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_trezor_2eproto();
  friend void protobuf_AssignDesc_trezor_2eproto();
  friend void protobuf_ShutdownFile_trezor_2eproto();

  void InitAsDefaultInstance();
  static Success* default_instance_;
};
// -------------------------------------------------------------------

class Failure : public ::google::protobuf::Message {
 public:
  Failure();
  virtual ~Failure();

  Failure(const Failure& from);

  inline Failure& operator=(const Failure& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Failure& default_instance();

  void Swap(Failure* other);

  // implements Message ----------------------------------------------

  Failure* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Failure& from);
  void MergeFrom(const Failure& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 code = 1;
  inline bool has_code() const;
  inline void clear_code();
  static const int kCodeFieldNumber = 1;
  inline ::google::protobuf::int32 code() const;
  inline void set_code(::google::protobuf::int32 value);

  // optional bytes message = 2;
  inline bool has_message() const;
  inline void clear_message();
  static const int kMessageFieldNumber = 2;
  inline const ::std::string& message() const;
  inline void set_message(const ::std::string& value);
  inline void set_message(const char* value);
  inline void set_message(const void* value, size_t size);
  inline ::std::string* mutable_message();
  inline ::std::string* release_message();
  inline void set_allocated_message(::std::string* message);

  // @@protoc_insertion_point(class_scope:Failure)
 private:
  inline void set_has_code();
  inline void clear_has_code();
  inline void set_has_message();
  inline void clear_has_message();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* message_;
  ::google::protobuf::int32 code_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_trezor_2eproto();
  friend void protobuf_AssignDesc_trezor_2eproto();
  friend void protobuf_ShutdownFile_trezor_2eproto();

  void InitAsDefaultInstance();
  static Failure* default_instance_;
};
// -------------------------------------------------------------------

class ButtonRequest : public ::google::protobuf::Message {
 public:
  ButtonRequest();
  virtual ~ButtonRequest();

  ButtonRequest(const ButtonRequest& from);

  inline ButtonRequest& operator=(const ButtonRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ButtonRequest& default_instance();

  void Swap(ButtonRequest* other);

  // implements Message ----------------------------------------------

  ButtonRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ButtonRequest& from);
  void MergeFrom(const ButtonRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:ButtonRequest)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;


  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];

  friend void  protobuf_AddDesc_trezor_2eproto();
  friend void protobuf_AssignDesc_trezor_2eproto();
  friend void protobuf_ShutdownFile_trezor_2eproto();

  void InitAsDefaultInstance();
  static ButtonRequest* default_instance_;
};
// -------------------------------------------------------------------

class ButtonAck : public ::google::protobuf::Message {
 public:
  ButtonAck();
  virtual ~ButtonAck();

  ButtonAck(const ButtonAck& from);

  inline ButtonAck& operator=(const ButtonAck& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ButtonAck& default_instance();

  void Swap(ButtonAck* other);

  // implements Message ----------------------------------------------

  ButtonAck* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ButtonAck& from);
  void MergeFrom(const ButtonAck& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:ButtonAck)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;


  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];

  friend void  protobuf_AddDesc_trezor_2eproto();
  friend void protobuf_AssignDesc_trezor_2eproto();
  friend void protobuf_ShutdownFile_trezor_2eproto();

  void InitAsDefaultInstance();
  static ButtonAck* default_instance_;
};
// -------------------------------------------------------------------

class ButtonCancel : public ::google::protobuf::Message {
 public:
  ButtonCancel();
  virtual ~ButtonCancel();

  ButtonCancel(const ButtonCancel& from);

  inline ButtonCancel& operator=(const ButtonCancel& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ButtonCancel& default_instance();

  void Swap(ButtonCancel* other);

  // implements Message ----------------------------------------------

  ButtonCancel* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ButtonCancel& from);
  void MergeFrom(const ButtonCancel& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:ButtonCancel)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;


  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];

  friend void  protobuf_AddDesc_trezor_2eproto();
  friend void protobuf_AssignDesc_trezor_2eproto();
  friend void protobuf_ShutdownFile_trezor_2eproto();

  void InitAsDefaultInstance();
  static ButtonCancel* default_instance_;
};
// -------------------------------------------------------------------

class PinMatrixRequest : public ::google::protobuf::Message {
 public:
  PinMatrixRequest();
  virtual ~PinMatrixRequest();

  PinMatrixRequest(const PinMatrixRequest& from);

  inline PinMatrixRequest& operator=(const PinMatrixRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PinMatrixRequest& default_instance();

  void Swap(PinMatrixRequest* other);

  // implements Message ----------------------------------------------

  PinMatrixRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PinMatrixRequest& from);
  void MergeFrom(const PinMatrixRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes message = 1;
  inline bool has_message() const;
  inline void clear_message();
  static const int kMessageFieldNumber = 1;
  inline const ::std::string& message() const;
  inline void set_message(const ::std::string& value);
  inline void set_message(const char* value);
  inline void set_message(const void* value, size_t size);
  inline ::std::string* mutable_message();
  inline ::std::string* release_message();
  inline void set_allocated_message(::std::string* message);

  // @@protoc_insertion_point(class_scope:PinMatrixRequest)
 private:
  inline void set_has_message();
  inline void clear_has_message();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* message_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_trezor_2eproto();
  friend void protobuf_AssignDesc_trezor_2eproto();
  friend void protobuf_ShutdownFile_trezor_2eproto();

  void InitAsDefaultInstance();
  static PinMatrixRequest* default_instance_;
};
// -------------------------------------------------------------------

class PinMatrixAck : public ::google::protobuf::Message {
 public:
  PinMatrixAck();
  virtual ~PinMatrixAck();

  PinMatrixAck(const PinMatrixAck& from);

  inline PinMatrixAck& operator=(const PinMatrixAck& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PinMatrixAck& default_instance();

  void Swap(PinMatrixAck* other);

  // implements Message ----------------------------------------------

  PinMatrixAck* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PinMatrixAck& from);
  void MergeFrom(const PinMatrixAck& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes pin = 1;
  inline bool has_pin() const;
  inline void clear_pin();
  static const int kPinFieldNumber = 1;
  inline const ::std::string& pin() const;
  inline void set_pin(const ::std::string& value);
  inline void set_pin(const char* value);
  inline void set_pin(const void* value, size_t size);
  inline ::std::string* mutable_pin();
  inline ::std::string* release_pin();
  inline void set_allocated_pin(::std::string* pin);

  // @@protoc_insertion_point(class_scope:PinMatrixAck)
 private:
  inline void set_has_pin();
  inline void clear_has_pin();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* pin_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_trezor_2eproto();
  friend void protobuf_AssignDesc_trezor_2eproto();
  friend void protobuf_ShutdownFile_trezor_2eproto();

  void InitAsDefaultInstance();
  static PinMatrixAck* default_instance_;
};
// -------------------------------------------------------------------

class PinMatrixCancel : public ::google::protobuf::Message {
 public:
  PinMatrixCancel();
  virtual ~PinMatrixCancel();

  PinMatrixCancel(const PinMatrixCancel& from);

  inline PinMatrixCancel& operator=(const PinMatrixCancel& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PinMatrixCancel& default_instance();

  void Swap(PinMatrixCancel* other);

  // implements Message ----------------------------------------------

  PinMatrixCancel* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PinMatrixCancel& from);
  void MergeFrom(const PinMatrixCancel& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:PinMatrixCancel)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;


  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];

  friend void  protobuf_AddDesc_trezor_2eproto();
  friend void protobuf_AssignDesc_trezor_2eproto();
  friend void protobuf_ShutdownFile_trezor_2eproto();

  void InitAsDefaultInstance();
  static PinMatrixCancel* default_instance_;
};
// -------------------------------------------------------------------

class GetEntropy : public ::google::protobuf::Message {
 public:
  GetEntropy();
  virtual ~GetEntropy();

  GetEntropy(const GetEntropy& from);

  inline GetEntropy& operator=(const GetEntropy& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetEntropy& default_instance();

  void Swap(GetEntropy* other);

  // implements Message ----------------------------------------------

  GetEntropy* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetEntropy& from);
  void MergeFrom(const GetEntropy& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 size = 1;
  inline bool has_size() const;
  inline void clear_size();
  static const int kSizeFieldNumber = 1;
  inline ::google::protobuf::uint32 size() const;
  inline void set_size(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:GetEntropy)
 private:
  inline void set_has_size();
  inline void clear_has_size();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 size_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_trezor_2eproto();
  friend void protobuf_AssignDesc_trezor_2eproto();
  friend void protobuf_ShutdownFile_trezor_2eproto();

  void InitAsDefaultInstance();
  static GetEntropy* default_instance_;
};
// -------------------------------------------------------------------

class Entropy : public ::google::protobuf::Message {
 public:
  Entropy();
  virtual ~Entropy();

  Entropy(const Entropy& from);

  inline Entropy& operator=(const Entropy& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Entropy& default_instance();

  void Swap(Entropy* other);

  // implements Message ----------------------------------------------

  Entropy* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Entropy& from);
  void MergeFrom(const Entropy& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes entropy = 1;
  inline bool has_entropy() const;
  inline void clear_entropy();
  static const int kEntropyFieldNumber = 1;
  inline const ::std::string& entropy() const;
  inline void set_entropy(const ::std::string& value);
  inline void set_entropy(const char* value);
  inline void set_entropy(const void* value, size_t size);
  inline ::std::string* mutable_entropy();
  inline ::std::string* release_entropy();
  inline void set_allocated_entropy(::std::string* entropy);

  // @@protoc_insertion_point(class_scope:Entropy)
 private:
  inline void set_has_entropy();
  inline void clear_has_entropy();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* entropy_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_trezor_2eproto();
  friend void protobuf_AssignDesc_trezor_2eproto();
  friend void protobuf_ShutdownFile_trezor_2eproto();

  void InitAsDefaultInstance();
  static Entropy* default_instance_;
};
// -------------------------------------------------------------------

class GetMasterPublicKey : public ::google::protobuf::Message {
 public:
  GetMasterPublicKey();
  virtual ~GetMasterPublicKey();

  GetMasterPublicKey(const GetMasterPublicKey& from);

  inline GetMasterPublicKey& operator=(const GetMasterPublicKey& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetMasterPublicKey& default_instance();

  void Swap(GetMasterPublicKey* other);

  // implements Message ----------------------------------------------

  GetMasterPublicKey* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetMasterPublicKey& from);
  void MergeFrom(const GetMasterPublicKey& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:GetMasterPublicKey)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;


  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];

  friend void  protobuf_AddDesc_trezor_2eproto();
  friend void protobuf_AssignDesc_trezor_2eproto();
  friend void protobuf_ShutdownFile_trezor_2eproto();

  void InitAsDefaultInstance();
  static GetMasterPublicKey* default_instance_;
};
// -------------------------------------------------------------------

class MasterPublicKey : public ::google::protobuf::Message {
 public:
  MasterPublicKey();
  virtual ~MasterPublicKey();

  MasterPublicKey(const MasterPublicKey& from);

  inline MasterPublicKey& operator=(const MasterPublicKey& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MasterPublicKey& default_instance();

  void Swap(MasterPublicKey* other);

  // implements Message ----------------------------------------------

  MasterPublicKey* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MasterPublicKey& from);
  void MergeFrom(const MasterPublicKey& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes key = 1;
  inline bool has_key() const;
  inline void clear_key();
  static const int kKeyFieldNumber = 1;
  inline const ::std::string& key() const;
  inline void set_key(const ::std::string& value);
  inline void set_key(const char* value);
  inline void set_key(const void* value, size_t size);
  inline ::std::string* mutable_key();
  inline ::std::string* release_key();
  inline void set_allocated_key(::std::string* key);

  // @@protoc_insertion_point(class_scope:MasterPublicKey)
 private:
  inline void set_has_key();
  inline void clear_has_key();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* key_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_trezor_2eproto();
  friend void protobuf_AssignDesc_trezor_2eproto();
  friend void protobuf_ShutdownFile_trezor_2eproto();

  void InitAsDefaultInstance();
  static MasterPublicKey* default_instance_;
};
// -------------------------------------------------------------------

class GetAddress : public ::google::protobuf::Message {
 public:
  GetAddress();
  virtual ~GetAddress();

  GetAddress(const GetAddress& from);

  inline GetAddress& operator=(const GetAddress& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetAddress& default_instance();

  void Swap(GetAddress* other);

  // implements Message ----------------------------------------------

  GetAddress* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetAddress& from);
  void MergeFrom(const GetAddress& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated uint32 address_n = 1;
  inline int address_n_size() const;
  inline void clear_address_n();
  static const int kAddressNFieldNumber = 1;
  inline ::google::protobuf::uint32 address_n(int index) const;
  inline void set_address_n(int index, ::google::protobuf::uint32 value);
  inline void add_address_n(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      address_n() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_address_n();

  // @@protoc_insertion_point(class_scope:GetAddress)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > address_n_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_trezor_2eproto();
  friend void protobuf_AssignDesc_trezor_2eproto();
  friend void protobuf_ShutdownFile_trezor_2eproto();

  void InitAsDefaultInstance();
  static GetAddress* default_instance_;
};
// -------------------------------------------------------------------

class Address : public ::google::protobuf::Message {
 public:
  Address();
  virtual ~Address();

  Address(const Address& from);

  inline Address& operator=(const Address& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Address& default_instance();

  void Swap(Address* other);

  // implements Message ----------------------------------------------

  Address* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Address& from);
  void MergeFrom(const Address& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes address = 1;
  inline bool has_address() const;
  inline void clear_address();
  static const int kAddressFieldNumber = 1;
  inline const ::std::string& address() const;
  inline void set_address(const ::std::string& value);
  inline void set_address(const char* value);
  inline void set_address(const void* value, size_t size);
  inline ::std::string* mutable_address();
  inline ::std::string* release_address();
  inline void set_allocated_address(::std::string* address);

  // @@protoc_insertion_point(class_scope:Address)
 private:
  inline void set_has_address();
  inline void clear_has_address();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* address_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_trezor_2eproto();
  friend void protobuf_AssignDesc_trezor_2eproto();
  friend void protobuf_ShutdownFile_trezor_2eproto();

  void InitAsDefaultInstance();
  static Address* default_instance_;
};
// -------------------------------------------------------------------

class LoadDevice : public ::google::protobuf::Message {
 public:
  LoadDevice();
  virtual ~LoadDevice();

  LoadDevice(const LoadDevice& from);

  inline LoadDevice& operator=(const LoadDevice& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LoadDevice& default_instance();

  void Swap(LoadDevice* other);

  // implements Message ----------------------------------------------

  LoadDevice* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LoadDevice& from);
  void MergeFrom(const LoadDevice& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes seed = 1;
  inline bool has_seed() const;
  inline void clear_seed();
  static const int kSeedFieldNumber = 1;
  inline const ::std::string& seed() const;
  inline void set_seed(const ::std::string& value);
  inline void set_seed(const char* value);
  inline void set_seed(const void* value, size_t size);
  inline ::std::string* mutable_seed();
  inline ::std::string* release_seed();
  inline void set_allocated_seed(::std::string* seed);

  // optional .XprvType xprv = 2;
  inline bool has_xprv() const;
  inline void clear_xprv();
  static const int kXprvFieldNumber = 2;
  inline const ::XprvType& xprv() const;
  inline ::XprvType* mutable_xprv();
  inline ::XprvType* release_xprv();
  inline void set_allocated_xprv(::XprvType* xprv);

  // optional bytes pin = 3;
  inline bool has_pin() const;
  inline void clear_pin();
  static const int kPinFieldNumber = 3;
  inline const ::std::string& pin() const;
  inline void set_pin(const ::std::string& value);
  inline void set_pin(const char* value);
  inline void set_pin(const void* value, size_t size);
  inline ::std::string* mutable_pin();
  inline ::std::string* release_pin();
  inline void set_allocated_pin(::std::string* pin);

  // @@protoc_insertion_point(class_scope:LoadDevice)
 private:
  inline void set_has_seed();
  inline void clear_has_seed();
  inline void set_has_xprv();
  inline void clear_has_xprv();
  inline void set_has_pin();
  inline void clear_has_pin();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* seed_;
  ::XprvType* xprv_;
  ::std::string* pin_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_trezor_2eproto();
  friend void protobuf_AssignDesc_trezor_2eproto();
  friend void protobuf_ShutdownFile_trezor_2eproto();

  void InitAsDefaultInstance();
  static LoadDevice* default_instance_;
};
// -------------------------------------------------------------------

class ResetDevice : public ::google::protobuf::Message {
 public:
  ResetDevice();
  virtual ~ResetDevice();

  ResetDevice(const ResetDevice& from);

  inline ResetDevice& operator=(const ResetDevice& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ResetDevice& default_instance();

  void Swap(ResetDevice* other);

  // implements Message ----------------------------------------------

  ResetDevice* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ResetDevice& from);
  void MergeFrom(const ResetDevice& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes random = 7;
  inline bool has_random() const;
  inline void clear_random();
  static const int kRandomFieldNumber = 7;
  inline const ::std::string& random() const;
  inline void set_random(const ::std::string& value);
  inline void set_random(const char* value);
  inline void set_random(const void* value, size_t size);
  inline ::std::string* mutable_random();
  inline ::std::string* release_random();
  inline void set_allocated_random(::std::string* random);

  // @@protoc_insertion_point(class_scope:ResetDevice)
 private:
  inline void set_has_random();
  inline void clear_has_random();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* random_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_trezor_2eproto();
  friend void protobuf_AssignDesc_trezor_2eproto();
  friend void protobuf_ShutdownFile_trezor_2eproto();

  void InitAsDefaultInstance();
  static ResetDevice* default_instance_;
};
// -------------------------------------------------------------------

class SignTx : public ::google::protobuf::Message {
 public:
  SignTx();
  virtual ~SignTx();

  SignTx(const SignTx& from);

  inline SignTx& operator=(const SignTx& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SignTx& default_instance();

  void Swap(SignTx* other);

  // implements Message ----------------------------------------------

  SignTx* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SignTx& from);
  void MergeFrom(const SignTx& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 outputs_count = 3;
  inline bool has_outputs_count() const;
  inline void clear_outputs_count();
  static const int kOutputsCountFieldNumber = 3;
  inline ::google::protobuf::uint32 outputs_count() const;
  inline void set_outputs_count(::google::protobuf::uint32 value);

  // required uint32 inputs_count = 5;
  inline bool has_inputs_count() const;
  inline void clear_inputs_count();
  static const int kInputsCountFieldNumber = 5;
  inline ::google::protobuf::uint32 inputs_count() const;
  inline void set_inputs_count(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:SignTx)
 private:
  inline void set_has_outputs_count();
  inline void clear_has_outputs_count();
  inline void set_has_inputs_count();
  inline void clear_has_inputs_count();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 outputs_count_;
  ::google::protobuf::uint32 inputs_count_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_trezor_2eproto();
  friend void protobuf_AssignDesc_trezor_2eproto();
  friend void protobuf_ShutdownFile_trezor_2eproto();

  void InitAsDefaultInstance();
  static SignTx* default_instance_;
};
// -------------------------------------------------------------------

class SimpleSignTx : public ::google::protobuf::Message {
 public:
  SimpleSignTx();
  virtual ~SimpleSignTx();

  SimpleSignTx(const SimpleSignTx& from);

  inline SimpleSignTx& operator=(const SimpleSignTx& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SimpleSignTx& default_instance();

  void Swap(SimpleSignTx* other);

  // implements Message ----------------------------------------------

  SimpleSignTx* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SimpleSignTx& from);
  void MergeFrom(const SimpleSignTx& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .TxInput inputs = 1;
  inline int inputs_size() const;
  inline void clear_inputs();
  static const int kInputsFieldNumber = 1;
  inline const ::TxInput& inputs(int index) const;
  inline ::TxInput* mutable_inputs(int index);
  inline ::TxInput* add_inputs();
  inline const ::google::protobuf::RepeatedPtrField< ::TxInput >&
      inputs() const;
  inline ::google::protobuf::RepeatedPtrField< ::TxInput >*
      mutable_inputs();

  // repeated .TxOutput outputs = 2;
  inline int outputs_size() const;
  inline void clear_outputs();
  static const int kOutputsFieldNumber = 2;
  inline const ::TxOutput& outputs(int index) const;
  inline ::TxOutput* mutable_outputs(int index);
  inline ::TxOutput* add_outputs();
  inline const ::google::protobuf::RepeatedPtrField< ::TxOutput >&
      outputs() const;
  inline ::google::protobuf::RepeatedPtrField< ::TxOutput >*
      mutable_outputs();

  // @@protoc_insertion_point(class_scope:SimpleSignTx)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::TxInput > inputs_;
  ::google::protobuf::RepeatedPtrField< ::TxOutput > outputs_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_trezor_2eproto();
  friend void protobuf_AssignDesc_trezor_2eproto();
  friend void protobuf_ShutdownFile_trezor_2eproto();

  void InitAsDefaultInstance();
  static SimpleSignTx* default_instance_;
};
// -------------------------------------------------------------------

class TxRequest : public ::google::protobuf::Message {
 public:
  TxRequest();
  virtual ~TxRequest();

  TxRequest(const TxRequest& from);

  inline TxRequest& operator=(const TxRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TxRequest& default_instance();

  void Swap(TxRequest* other);

  // implements Message ----------------------------------------------

  TxRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TxRequest& from);
  void MergeFrom(const TxRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 request_index = 1;
  inline bool has_request_index() const;
  inline void clear_request_index();
  static const int kRequestIndexFieldNumber = 1;
  inline ::google::protobuf::int32 request_index() const;
  inline void set_request_index(::google::protobuf::int32 value);

  // optional .RequestType request_type = 2;
  inline bool has_request_type() const;
  inline void clear_request_type();
  static const int kRequestTypeFieldNumber = 2;
  inline ::RequestType request_type() const;
  inline void set_request_type(::RequestType value);

  // optional int32 signed_index = 3;
  inline bool has_signed_index() const;
  inline void clear_signed_index();
  static const int kSignedIndexFieldNumber = 3;
  inline ::google::protobuf::int32 signed_index() const;
  inline void set_signed_index(::google::protobuf::int32 value);

  // optional bytes signature = 4;
  inline bool has_signature() const;
  inline void clear_signature();
  static const int kSignatureFieldNumber = 4;
  inline const ::std::string& signature() const;
  inline void set_signature(const ::std::string& value);
  inline void set_signature(const char* value);
  inline void set_signature(const void* value, size_t size);
  inline ::std::string* mutable_signature();
  inline ::std::string* release_signature();
  inline void set_allocated_signature(::std::string* signature);

  // optional bytes serialized_tx = 5;
  inline bool has_serialized_tx() const;
  inline void clear_serialized_tx();
  static const int kSerializedTxFieldNumber = 5;
  inline const ::std::string& serialized_tx() const;
  inline void set_serialized_tx(const ::std::string& value);
  inline void set_serialized_tx(const char* value);
  inline void set_serialized_tx(const void* value, size_t size);
  inline ::std::string* mutable_serialized_tx();
  inline ::std::string* release_serialized_tx();
  inline void set_allocated_serialized_tx(::std::string* serialized_tx);

  // @@protoc_insertion_point(class_scope:TxRequest)
 private:
  inline void set_has_request_index();
  inline void clear_has_request_index();
  inline void set_has_request_type();
  inline void clear_has_request_type();
  inline void set_has_signed_index();
  inline void clear_has_signed_index();
  inline void set_has_signature();
  inline void clear_has_signature();
  inline void set_has_serialized_tx();
  inline void clear_has_serialized_tx();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 request_index_;
  int request_type_;
  ::std::string* signature_;
  ::std::string* serialized_tx_;
  ::google::protobuf::int32 signed_index_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_trezor_2eproto();
  friend void protobuf_AssignDesc_trezor_2eproto();
  friend void protobuf_ShutdownFile_trezor_2eproto();

  void InitAsDefaultInstance();
  static TxRequest* default_instance_;
};
// -------------------------------------------------------------------

class TxInput : public ::google::protobuf::Message {
 public:
  TxInput();
  virtual ~TxInput();

  TxInput(const TxInput& from);

  inline TxInput& operator=(const TxInput& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TxInput& default_instance();

  void Swap(TxInput* other);

  // implements Message ----------------------------------------------

  TxInput* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TxInput& from);
  void MergeFrom(const TxInput& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 index = 1;
  inline bool has_index() const;
  inline void clear_index();
  static const int kIndexFieldNumber = 1;
  inline ::google::protobuf::uint32 index() const;
  inline void set_index(::google::protobuf::uint32 value);

  // repeated uint32 address_n = 2;
  inline int address_n_size() const;
  inline void clear_address_n();
  static const int kAddressNFieldNumber = 2;
  inline ::google::protobuf::uint32 address_n(int index) const;
  inline void set_address_n(int index, ::google::protobuf::uint32 value);
  inline void add_address_n(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      address_n() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_address_n();

  // required uint64 amount = 3;
  inline bool has_amount() const;
  inline void clear_amount();
  static const int kAmountFieldNumber = 3;
  inline ::google::protobuf::uint64 amount() const;
  inline void set_amount(::google::protobuf::uint64 value);

  // required bytes prev_hash = 4;
  inline bool has_prev_hash() const;
  inline void clear_prev_hash();
  static const int kPrevHashFieldNumber = 4;
  inline const ::std::string& prev_hash() const;
  inline void set_prev_hash(const ::std::string& value);
  inline void set_prev_hash(const char* value);
  inline void set_prev_hash(const void* value, size_t size);
  inline ::std::string* mutable_prev_hash();
  inline ::std::string* release_prev_hash();
  inline void set_allocated_prev_hash(::std::string* prev_hash);

  // required uint32 prev_index = 5;
  inline bool has_prev_index() const;
  inline void clear_prev_index();
  static const int kPrevIndexFieldNumber = 5;
  inline ::google::protobuf::uint32 prev_index() const;
  inline void set_prev_index(::google::protobuf::uint32 value);

  // optional bytes script_sig = 6;
  inline bool has_script_sig() const;
  inline void clear_script_sig();
  static const int kScriptSigFieldNumber = 6;
  inline const ::std::string& script_sig() const;
  inline void set_script_sig(const ::std::string& value);
  inline void set_script_sig(const char* value);
  inline void set_script_sig(const void* value, size_t size);
  inline ::std::string* mutable_script_sig();
  inline ::std::string* release_script_sig();
  inline void set_allocated_script_sig(::std::string* script_sig);

  // @@protoc_insertion_point(class_scope:TxInput)
 private:
  inline void set_has_index();
  inline void clear_has_index();
  inline void set_has_amount();
  inline void clear_has_amount();
  inline void set_has_prev_hash();
  inline void clear_has_prev_hash();
  inline void set_has_prev_index();
  inline void clear_has_prev_index();
  inline void set_has_script_sig();
  inline void clear_has_script_sig();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > address_n_;
  ::google::protobuf::uint64 amount_;
  ::google::protobuf::uint32 index_;
  ::google::protobuf::uint32 prev_index_;
  ::std::string* prev_hash_;
  ::std::string* script_sig_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_trezor_2eproto();
  friend void protobuf_AssignDesc_trezor_2eproto();
  friend void protobuf_ShutdownFile_trezor_2eproto();

  void InitAsDefaultInstance();
  static TxInput* default_instance_;
};
// -------------------------------------------------------------------

class TxOutput : public ::google::protobuf::Message {
 public:
  TxOutput();
  virtual ~TxOutput();

  TxOutput(const TxOutput& from);

  inline TxOutput& operator=(const TxOutput& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TxOutput& default_instance();

  void Swap(TxOutput* other);

  // implements Message ----------------------------------------------

  TxOutput* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TxOutput& from);
  void MergeFrom(const TxOutput& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 index = 1;
  inline bool has_index() const;
  inline void clear_index();
  static const int kIndexFieldNumber = 1;
  inline ::google::protobuf::uint32 index() const;
  inline void set_index(::google::protobuf::uint32 value);

  // required bytes address = 2;
  inline bool has_address() const;
  inline void clear_address();
  static const int kAddressFieldNumber = 2;
  inline const ::std::string& address() const;
  inline void set_address(const ::std::string& value);
  inline void set_address(const char* value);
  inline void set_address(const void* value, size_t size);
  inline ::std::string* mutable_address();
  inline ::std::string* release_address();
  inline void set_allocated_address(::std::string* address);

  // repeated uint32 address_n = 3;
  inline int address_n_size() const;
  inline void clear_address_n();
  static const int kAddressNFieldNumber = 3;
  inline ::google::protobuf::uint32 address_n(int index) const;
  inline void set_address_n(int index, ::google::protobuf::uint32 value);
  inline void add_address_n(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      address_n() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_address_n();

  // required uint64 amount = 4;
  inline bool has_amount() const;
  inline void clear_amount();
  static const int kAmountFieldNumber = 4;
  inline ::google::protobuf::uint64 amount() const;
  inline void set_amount(::google::protobuf::uint64 value);

  // required .ScriptType script_type = 5;
  inline bool has_script_type() const;
  inline void clear_script_type();
  static const int kScriptTypeFieldNumber = 5;
  inline ::ScriptType script_type() const;
  inline void set_script_type(::ScriptType value);

  // repeated bytes script_args = 6;
  inline int script_args_size() const;
  inline void clear_script_args();
  static const int kScriptArgsFieldNumber = 6;
  inline const ::std::string& script_args(int index) const;
  inline ::std::string* mutable_script_args(int index);
  inline void set_script_args(int index, const ::std::string& value);
  inline void set_script_args(int index, const char* value);
  inline void set_script_args(int index, const void* value, size_t size);
  inline ::std::string* add_script_args();
  inline void add_script_args(const ::std::string& value);
  inline void add_script_args(const char* value);
  inline void add_script_args(const void* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& script_args() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_script_args();

  // @@protoc_insertion_point(class_scope:TxOutput)
 private:
  inline void set_has_index();
  inline void clear_has_index();
  inline void set_has_address();
  inline void clear_has_address();
  inline void set_has_amount();
  inline void clear_has_amount();
  inline void set_has_script_type();
  inline void clear_has_script_type();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* address_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > address_n_;
  ::google::protobuf::uint32 index_;
  int script_type_;
  ::google::protobuf::uint64 amount_;
  ::google::protobuf::RepeatedPtrField< ::std::string> script_args_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_trezor_2eproto();
  friend void protobuf_AssignDesc_trezor_2eproto();
  friend void protobuf_ShutdownFile_trezor_2eproto();

  void InitAsDefaultInstance();
  static TxOutput* default_instance_;
};
// ===================================================================


// ===================================================================

// XprvType

// required bytes version = 1;
inline bool XprvType::has_version() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void XprvType::set_has_version() {
  _has_bits_[0] |= 0x00000001u;
}
inline void XprvType::clear_has_version() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void XprvType::clear_version() {
  if (version_ != &::google::protobuf::internal::kEmptyString) {
    version_->clear();
  }
  clear_has_version();
}
inline const ::std::string& XprvType::version() const {
  return *version_;
}
inline void XprvType::set_version(const ::std::string& value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(value);
}
inline void XprvType::set_version(const char* value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(value);
}
inline void XprvType::set_version(const void* value, size_t size) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* XprvType::mutable_version() {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  return version_;
}
inline ::std::string* XprvType::release_version() {
  clear_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = version_;
    version_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void XprvType::set_allocated_version(::std::string* version) {
  if (version_ != &::google::protobuf::internal::kEmptyString) {
    delete version_;
  }
  if (version) {
    set_has_version();
    version_ = version;
  } else {
    clear_has_version();
    version_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required uint32 depth = 2;
inline bool XprvType::has_depth() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void XprvType::set_has_depth() {
  _has_bits_[0] |= 0x00000002u;
}
inline void XprvType::clear_has_depth() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void XprvType::clear_depth() {
  depth_ = 0u;
  clear_has_depth();
}
inline ::google::protobuf::uint32 XprvType::depth() const {
  return depth_;
}
inline void XprvType::set_depth(::google::protobuf::uint32 value) {
  set_has_depth();
  depth_ = value;
}

// required uint32 fingerprint = 3;
inline bool XprvType::has_fingerprint() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void XprvType::set_has_fingerprint() {
  _has_bits_[0] |= 0x00000004u;
}
inline void XprvType::clear_has_fingerprint() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void XprvType::clear_fingerprint() {
  fingerprint_ = 0u;
  clear_has_fingerprint();
}
inline ::google::protobuf::uint32 XprvType::fingerprint() const {
  return fingerprint_;
}
inline void XprvType::set_fingerprint(::google::protobuf::uint32 value) {
  set_has_fingerprint();
  fingerprint_ = value;
}

// required uint32 child_num = 4;
inline bool XprvType::has_child_num() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void XprvType::set_has_child_num() {
  _has_bits_[0] |= 0x00000008u;
}
inline void XprvType::clear_has_child_num() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void XprvType::clear_child_num() {
  child_num_ = 0u;
  clear_has_child_num();
}
inline ::google::protobuf::uint32 XprvType::child_num() const {
  return child_num_;
}
inline void XprvType::set_child_num(::google::protobuf::uint32 value) {
  set_has_child_num();
  child_num_ = value;
}

// required bytes chain_code = 5;
inline bool XprvType::has_chain_code() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void XprvType::set_has_chain_code() {
  _has_bits_[0] |= 0x00000010u;
}
inline void XprvType::clear_has_chain_code() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void XprvType::clear_chain_code() {
  if (chain_code_ != &::google::protobuf::internal::kEmptyString) {
    chain_code_->clear();
  }
  clear_has_chain_code();
}
inline const ::std::string& XprvType::chain_code() const {
  return *chain_code_;
}
inline void XprvType::set_chain_code(const ::std::string& value) {
  set_has_chain_code();
  if (chain_code_ == &::google::protobuf::internal::kEmptyString) {
    chain_code_ = new ::std::string;
  }
  chain_code_->assign(value);
}
inline void XprvType::set_chain_code(const char* value) {
  set_has_chain_code();
  if (chain_code_ == &::google::protobuf::internal::kEmptyString) {
    chain_code_ = new ::std::string;
  }
  chain_code_->assign(value);
}
inline void XprvType::set_chain_code(const void* value, size_t size) {
  set_has_chain_code();
  if (chain_code_ == &::google::protobuf::internal::kEmptyString) {
    chain_code_ = new ::std::string;
  }
  chain_code_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* XprvType::mutable_chain_code() {
  set_has_chain_code();
  if (chain_code_ == &::google::protobuf::internal::kEmptyString) {
    chain_code_ = new ::std::string;
  }
  return chain_code_;
}
inline ::std::string* XprvType::release_chain_code() {
  clear_has_chain_code();
  if (chain_code_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = chain_code_;
    chain_code_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void XprvType::set_allocated_chain_code(::std::string* chain_code) {
  if (chain_code_ != &::google::protobuf::internal::kEmptyString) {
    delete chain_code_;
  }
  if (chain_code) {
    set_has_chain_code();
    chain_code_ = chain_code;
  } else {
    clear_has_chain_code();
    chain_code_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required bytes private_key = 6;
inline bool XprvType::has_private_key() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void XprvType::set_has_private_key() {
  _has_bits_[0] |= 0x00000020u;
}
inline void XprvType::clear_has_private_key() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void XprvType::clear_private_key() {
  if (private_key_ != &::google::protobuf::internal::kEmptyString) {
    private_key_->clear();
  }
  clear_has_private_key();
}
inline const ::std::string& XprvType::private_key() const {
  return *private_key_;
}
inline void XprvType::set_private_key(const ::std::string& value) {
  set_has_private_key();
  if (private_key_ == &::google::protobuf::internal::kEmptyString) {
    private_key_ = new ::std::string;
  }
  private_key_->assign(value);
}
inline void XprvType::set_private_key(const char* value) {
  set_has_private_key();
  if (private_key_ == &::google::protobuf::internal::kEmptyString) {
    private_key_ = new ::std::string;
  }
  private_key_->assign(value);
}
inline void XprvType::set_private_key(const void* value, size_t size) {
  set_has_private_key();
  if (private_key_ == &::google::protobuf::internal::kEmptyString) {
    private_key_ = new ::std::string;
  }
  private_key_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* XprvType::mutable_private_key() {
  set_has_private_key();
  if (private_key_ == &::google::protobuf::internal::kEmptyString) {
    private_key_ = new ::std::string;
  }
  return private_key_;
}
inline ::std::string* XprvType::release_private_key() {
  clear_has_private_key();
  if (private_key_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = private_key_;
    private_key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void XprvType::set_allocated_private_key(::std::string* private_key) {
  if (private_key_ != &::google::protobuf::internal::kEmptyString) {
    delete private_key_;
  }
  if (private_key) {
    set_has_private_key();
    private_key_ = private_key;
  } else {
    clear_has_private_key();
    private_key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// CoinType

// optional bytes coin_name = 2;
inline bool CoinType::has_coin_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CoinType::set_has_coin_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CoinType::clear_has_coin_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CoinType::clear_coin_name() {
  if (coin_name_ != &::google::protobuf::internal::kEmptyString) {
    coin_name_->clear();
  }
  clear_has_coin_name();
}
inline const ::std::string& CoinType::coin_name() const {
  return *coin_name_;
}
inline void CoinType::set_coin_name(const ::std::string& value) {
  set_has_coin_name();
  if (coin_name_ == &::google::protobuf::internal::kEmptyString) {
    coin_name_ = new ::std::string;
  }
  coin_name_->assign(value);
}
inline void CoinType::set_coin_name(const char* value) {
  set_has_coin_name();
  if (coin_name_ == &::google::protobuf::internal::kEmptyString) {
    coin_name_ = new ::std::string;
  }
  coin_name_->assign(value);
}
inline void CoinType::set_coin_name(const void* value, size_t size) {
  set_has_coin_name();
  if (coin_name_ == &::google::protobuf::internal::kEmptyString) {
    coin_name_ = new ::std::string;
  }
  coin_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CoinType::mutable_coin_name() {
  set_has_coin_name();
  if (coin_name_ == &::google::protobuf::internal::kEmptyString) {
    coin_name_ = new ::std::string;
  }
  return coin_name_;
}
inline ::std::string* CoinType::release_coin_name() {
  clear_has_coin_name();
  if (coin_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = coin_name_;
    coin_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CoinType::set_allocated_coin_name(::std::string* coin_name) {
  if (coin_name_ != &::google::protobuf::internal::kEmptyString) {
    delete coin_name_;
  }
  if (coin_name) {
    set_has_coin_name();
    coin_name_ = coin_name;
  } else {
    clear_has_coin_name();
    coin_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes coin_shortcut = 3;
inline bool CoinType::has_coin_shortcut() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CoinType::set_has_coin_shortcut() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CoinType::clear_has_coin_shortcut() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CoinType::clear_coin_shortcut() {
  if (coin_shortcut_ != &::google::protobuf::internal::kEmptyString) {
    coin_shortcut_->clear();
  }
  clear_has_coin_shortcut();
}
inline const ::std::string& CoinType::coin_shortcut() const {
  return *coin_shortcut_;
}
inline void CoinType::set_coin_shortcut(const ::std::string& value) {
  set_has_coin_shortcut();
  if (coin_shortcut_ == &::google::protobuf::internal::kEmptyString) {
    coin_shortcut_ = new ::std::string;
  }
  coin_shortcut_->assign(value);
}
inline void CoinType::set_coin_shortcut(const char* value) {
  set_has_coin_shortcut();
  if (coin_shortcut_ == &::google::protobuf::internal::kEmptyString) {
    coin_shortcut_ = new ::std::string;
  }
  coin_shortcut_->assign(value);
}
inline void CoinType::set_coin_shortcut(const void* value, size_t size) {
  set_has_coin_shortcut();
  if (coin_shortcut_ == &::google::protobuf::internal::kEmptyString) {
    coin_shortcut_ = new ::std::string;
  }
  coin_shortcut_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CoinType::mutable_coin_shortcut() {
  set_has_coin_shortcut();
  if (coin_shortcut_ == &::google::protobuf::internal::kEmptyString) {
    coin_shortcut_ = new ::std::string;
  }
  return coin_shortcut_;
}
inline ::std::string* CoinType::release_coin_shortcut() {
  clear_has_coin_shortcut();
  if (coin_shortcut_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = coin_shortcut_;
    coin_shortcut_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CoinType::set_allocated_coin_shortcut(::std::string* coin_shortcut) {
  if (coin_shortcut_ != &::google::protobuf::internal::kEmptyString) {
    delete coin_shortcut_;
  }
  if (coin_shortcut) {
    set_has_coin_shortcut();
    coin_shortcut_ = coin_shortcut;
  } else {
    clear_has_coin_shortcut();
    coin_shortcut_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 address_type = 4;
inline bool CoinType::has_address_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CoinType::set_has_address_type() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CoinType::clear_has_address_type() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CoinType::clear_address_type() {
  address_type_ = 0u;
  clear_has_address_type();
}
inline ::google::protobuf::uint32 CoinType::address_type() const {
  return address_type_;
}
inline void CoinType::set_address_type(::google::protobuf::uint32 value) {
  set_has_address_type();
  address_type_ = value;
}

// optional uint64 maxfee_kb = 5;
inline bool CoinType::has_maxfee_kb() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CoinType::set_has_maxfee_kb() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CoinType::clear_has_maxfee_kb() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CoinType::clear_maxfee_kb() {
  maxfee_kb_ = GOOGLE_ULONGLONG(0);
  clear_has_maxfee_kb();
}
inline ::google::protobuf::uint64 CoinType::maxfee_kb() const {
  return maxfee_kb_;
}
inline void CoinType::set_maxfee_kb(::google::protobuf::uint64 value) {
  set_has_maxfee_kb();
  maxfee_kb_ = value;
}

// -------------------------------------------------------------------

// SettingsType

// optional bytes language = 1;
inline bool SettingsType::has_language() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SettingsType::set_has_language() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SettingsType::clear_has_language() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SettingsType::clear_language() {
  if (language_ != &::google::protobuf::internal::kEmptyString) {
    language_->clear();
  }
  clear_has_language();
}
inline const ::std::string& SettingsType::language() const {
  return *language_;
}
inline void SettingsType::set_language(const ::std::string& value) {
  set_has_language();
  if (language_ == &::google::protobuf::internal::kEmptyString) {
    language_ = new ::std::string;
  }
  language_->assign(value);
}
inline void SettingsType::set_language(const char* value) {
  set_has_language();
  if (language_ == &::google::protobuf::internal::kEmptyString) {
    language_ = new ::std::string;
  }
  language_->assign(value);
}
inline void SettingsType::set_language(const void* value, size_t size) {
  set_has_language();
  if (language_ == &::google::protobuf::internal::kEmptyString) {
    language_ = new ::std::string;
  }
  language_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SettingsType::mutable_language() {
  set_has_language();
  if (language_ == &::google::protobuf::internal::kEmptyString) {
    language_ = new ::std::string;
  }
  return language_;
}
inline ::std::string* SettingsType::release_language() {
  clear_has_language();
  if (language_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = language_;
    language_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SettingsType::set_allocated_language(::std::string* language) {
  if (language_ != &::google::protobuf::internal::kEmptyString) {
    delete language_;
  }
  if (language) {
    set_has_language();
    language_ = language;
  } else {
    clear_has_language();
    language_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .CoinType coin = 2;
inline bool SettingsType::has_coin() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SettingsType::set_has_coin() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SettingsType::clear_has_coin() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SettingsType::clear_coin() {
  if (coin_ != NULL) coin_->::CoinType::Clear();
  clear_has_coin();
}
inline const ::CoinType& SettingsType::coin() const {
  return coin_ != NULL ? *coin_ : *default_instance_->coin_;
}
inline ::CoinType* SettingsType::mutable_coin() {
  set_has_coin();
  if (coin_ == NULL) coin_ = new ::CoinType;
  return coin_;
}
inline ::CoinType* SettingsType::release_coin() {
  clear_has_coin();
  ::CoinType* temp = coin_;
  coin_ = NULL;
  return temp;
}
inline void SettingsType::set_allocated_coin(::CoinType* coin) {
  delete coin_;
  coin_ = coin;
  if (coin) {
    set_has_coin();
  } else {
    clear_has_coin();
  }
}

// optional bytes label = 3;
inline bool SettingsType::has_label() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SettingsType::set_has_label() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SettingsType::clear_has_label() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SettingsType::clear_label() {
  if (label_ != &::google::protobuf::internal::kEmptyString) {
    label_->clear();
  }
  clear_has_label();
}
inline const ::std::string& SettingsType::label() const {
  return *label_;
}
inline void SettingsType::set_label(const ::std::string& value) {
  set_has_label();
  if (label_ == &::google::protobuf::internal::kEmptyString) {
    label_ = new ::std::string;
  }
  label_->assign(value);
}
inline void SettingsType::set_label(const char* value) {
  set_has_label();
  if (label_ == &::google::protobuf::internal::kEmptyString) {
    label_ = new ::std::string;
  }
  label_->assign(value);
}
inline void SettingsType::set_label(const void* value, size_t size) {
  set_has_label();
  if (label_ == &::google::protobuf::internal::kEmptyString) {
    label_ = new ::std::string;
  }
  label_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SettingsType::mutable_label() {
  set_has_label();
  if (label_ == &::google::protobuf::internal::kEmptyString) {
    label_ = new ::std::string;
  }
  return label_;
}
inline ::std::string* SettingsType::release_label() {
  clear_has_label();
  if (label_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = label_;
    label_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SettingsType::set_allocated_label(::std::string* label) {
  if (label_ != &::google::protobuf::internal::kEmptyString) {
    delete label_;
  }
  if (label) {
    set_has_label();
    label_ = label;
  } else {
    clear_has_label();
    label_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// Initialize

// -------------------------------------------------------------------

// Features

// optional bytes vendor = 1;
inline bool Features::has_vendor() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Features::set_has_vendor() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Features::clear_has_vendor() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Features::clear_vendor() {
  if (vendor_ != &::google::protobuf::internal::kEmptyString) {
    vendor_->clear();
  }
  clear_has_vendor();
}
inline const ::std::string& Features::vendor() const {
  return *vendor_;
}
inline void Features::set_vendor(const ::std::string& value) {
  set_has_vendor();
  if (vendor_ == &::google::protobuf::internal::kEmptyString) {
    vendor_ = new ::std::string;
  }
  vendor_->assign(value);
}
inline void Features::set_vendor(const char* value) {
  set_has_vendor();
  if (vendor_ == &::google::protobuf::internal::kEmptyString) {
    vendor_ = new ::std::string;
  }
  vendor_->assign(value);
}
inline void Features::set_vendor(const void* value, size_t size) {
  set_has_vendor();
  if (vendor_ == &::google::protobuf::internal::kEmptyString) {
    vendor_ = new ::std::string;
  }
  vendor_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Features::mutable_vendor() {
  set_has_vendor();
  if (vendor_ == &::google::protobuf::internal::kEmptyString) {
    vendor_ = new ::std::string;
  }
  return vendor_;
}
inline ::std::string* Features::release_vendor() {
  clear_has_vendor();
  if (vendor_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = vendor_;
    vendor_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Features::set_allocated_vendor(::std::string* vendor) {
  if (vendor_ != &::google::protobuf::internal::kEmptyString) {
    delete vendor_;
  }
  if (vendor) {
    set_has_vendor();
    vendor_ = vendor;
  } else {
    clear_has_vendor();
    vendor_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 major_version = 2;
inline bool Features::has_major_version() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Features::set_has_major_version() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Features::clear_has_major_version() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Features::clear_major_version() {
  major_version_ = 0u;
  clear_has_major_version();
}
inline ::google::protobuf::uint32 Features::major_version() const {
  return major_version_;
}
inline void Features::set_major_version(::google::protobuf::uint32 value) {
  set_has_major_version();
  major_version_ = value;
}

// optional uint32 minor_version = 3;
inline bool Features::has_minor_version() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Features::set_has_minor_version() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Features::clear_has_minor_version() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Features::clear_minor_version() {
  minor_version_ = 0u;
  clear_has_minor_version();
}
inline ::google::protobuf::uint32 Features::minor_version() const {
  return minor_version_;
}
inline void Features::set_minor_version(::google::protobuf::uint32 value) {
  set_has_minor_version();
  minor_version_ = value;
}

// optional .SettingsType settings = 4;
inline bool Features::has_settings() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Features::set_has_settings() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Features::clear_has_settings() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Features::clear_settings() {
  if (settings_ != NULL) settings_->::SettingsType::Clear();
  clear_has_settings();
}
inline const ::SettingsType& Features::settings() const {
  return settings_ != NULL ? *settings_ : *default_instance_->settings_;
}
inline ::SettingsType* Features::mutable_settings() {
  set_has_settings();
  if (settings_ == NULL) settings_ = new ::SettingsType;
  return settings_;
}
inline ::SettingsType* Features::release_settings() {
  clear_has_settings();
  ::SettingsType* temp = settings_;
  settings_ = NULL;
  return temp;
}
inline void Features::set_allocated_settings(::SettingsType* settings) {
  delete settings_;
  settings_ = settings;
  if (settings) {
    set_has_settings();
  } else {
    clear_has_settings();
  }
}

// optional bytes serial_number = 5;
inline bool Features::has_serial_number() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Features::set_has_serial_number() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Features::clear_has_serial_number() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Features::clear_serial_number() {
  if (serial_number_ != &::google::protobuf::internal::kEmptyString) {
    serial_number_->clear();
  }
  clear_has_serial_number();
}
inline const ::std::string& Features::serial_number() const {
  return *serial_number_;
}
inline void Features::set_serial_number(const ::std::string& value) {
  set_has_serial_number();
  if (serial_number_ == &::google::protobuf::internal::kEmptyString) {
    serial_number_ = new ::std::string;
  }
  serial_number_->assign(value);
}
inline void Features::set_serial_number(const char* value) {
  set_has_serial_number();
  if (serial_number_ == &::google::protobuf::internal::kEmptyString) {
    serial_number_ = new ::std::string;
  }
  serial_number_->assign(value);
}
inline void Features::set_serial_number(const void* value, size_t size) {
  set_has_serial_number();
  if (serial_number_ == &::google::protobuf::internal::kEmptyString) {
    serial_number_ = new ::std::string;
  }
  serial_number_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Features::mutable_serial_number() {
  set_has_serial_number();
  if (serial_number_ == &::google::protobuf::internal::kEmptyString) {
    serial_number_ = new ::std::string;
  }
  return serial_number_;
}
inline ::std::string* Features::release_serial_number() {
  clear_has_serial_number();
  if (serial_number_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = serial_number_;
    serial_number_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Features::set_allocated_serial_number(::std::string* serial_number) {
  if (serial_number_ != &::google::protobuf::internal::kEmptyString) {
    delete serial_number_;
  }
  if (serial_number) {
    set_has_serial_number();
    serial_number_ = serial_number;
  } else {
    clear_has_serial_number();
    serial_number_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// ApplySettings

// optional bytes language = 1;
inline bool ApplySettings::has_language() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ApplySettings::set_has_language() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ApplySettings::clear_has_language() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ApplySettings::clear_language() {
  if (language_ != &::google::protobuf::internal::kEmptyString) {
    language_->clear();
  }
  clear_has_language();
}
inline const ::std::string& ApplySettings::language() const {
  return *language_;
}
inline void ApplySettings::set_language(const ::std::string& value) {
  set_has_language();
  if (language_ == &::google::protobuf::internal::kEmptyString) {
    language_ = new ::std::string;
  }
  language_->assign(value);
}
inline void ApplySettings::set_language(const char* value) {
  set_has_language();
  if (language_ == &::google::protobuf::internal::kEmptyString) {
    language_ = new ::std::string;
  }
  language_->assign(value);
}
inline void ApplySettings::set_language(const void* value, size_t size) {
  set_has_language();
  if (language_ == &::google::protobuf::internal::kEmptyString) {
    language_ = new ::std::string;
  }
  language_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ApplySettings::mutable_language() {
  set_has_language();
  if (language_ == &::google::protobuf::internal::kEmptyString) {
    language_ = new ::std::string;
  }
  return language_;
}
inline ::std::string* ApplySettings::release_language() {
  clear_has_language();
  if (language_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = language_;
    language_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ApplySettings::set_allocated_language(::std::string* language) {
  if (language_ != &::google::protobuf::internal::kEmptyString) {
    delete language_;
  }
  if (language) {
    set_has_language();
    language_ = language;
  } else {
    clear_has_language();
    language_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes coin_shortcut = 2;
inline bool ApplySettings::has_coin_shortcut() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ApplySettings::set_has_coin_shortcut() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ApplySettings::clear_has_coin_shortcut() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ApplySettings::clear_coin_shortcut() {
  if (coin_shortcut_ != &::google::protobuf::internal::kEmptyString) {
    coin_shortcut_->clear();
  }
  clear_has_coin_shortcut();
}
inline const ::std::string& ApplySettings::coin_shortcut() const {
  return *coin_shortcut_;
}
inline void ApplySettings::set_coin_shortcut(const ::std::string& value) {
  set_has_coin_shortcut();
  if (coin_shortcut_ == &::google::protobuf::internal::kEmptyString) {
    coin_shortcut_ = new ::std::string;
  }
  coin_shortcut_->assign(value);
}
inline void ApplySettings::set_coin_shortcut(const char* value) {
  set_has_coin_shortcut();
  if (coin_shortcut_ == &::google::protobuf::internal::kEmptyString) {
    coin_shortcut_ = new ::std::string;
  }
  coin_shortcut_->assign(value);
}
inline void ApplySettings::set_coin_shortcut(const void* value, size_t size) {
  set_has_coin_shortcut();
  if (coin_shortcut_ == &::google::protobuf::internal::kEmptyString) {
    coin_shortcut_ = new ::std::string;
  }
  coin_shortcut_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ApplySettings::mutable_coin_shortcut() {
  set_has_coin_shortcut();
  if (coin_shortcut_ == &::google::protobuf::internal::kEmptyString) {
    coin_shortcut_ = new ::std::string;
  }
  return coin_shortcut_;
}
inline ::std::string* ApplySettings::release_coin_shortcut() {
  clear_has_coin_shortcut();
  if (coin_shortcut_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = coin_shortcut_;
    coin_shortcut_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ApplySettings::set_allocated_coin_shortcut(::std::string* coin_shortcut) {
  if (coin_shortcut_ != &::google::protobuf::internal::kEmptyString) {
    delete coin_shortcut_;
  }
  if (coin_shortcut) {
    set_has_coin_shortcut();
    coin_shortcut_ = coin_shortcut;
  } else {
    clear_has_coin_shortcut();
    coin_shortcut_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes label = 3;
inline bool ApplySettings::has_label() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ApplySettings::set_has_label() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ApplySettings::clear_has_label() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ApplySettings::clear_label() {
  if (label_ != &::google::protobuf::internal::kEmptyString) {
    label_->clear();
  }
  clear_has_label();
}
inline const ::std::string& ApplySettings::label() const {
  return *label_;
}
inline void ApplySettings::set_label(const ::std::string& value) {
  set_has_label();
  if (label_ == &::google::protobuf::internal::kEmptyString) {
    label_ = new ::std::string;
  }
  label_->assign(value);
}
inline void ApplySettings::set_label(const char* value) {
  set_has_label();
  if (label_ == &::google::protobuf::internal::kEmptyString) {
    label_ = new ::std::string;
  }
  label_->assign(value);
}
inline void ApplySettings::set_label(const void* value, size_t size) {
  set_has_label();
  if (label_ == &::google::protobuf::internal::kEmptyString) {
    label_ = new ::std::string;
  }
  label_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ApplySettings::mutable_label() {
  set_has_label();
  if (label_ == &::google::protobuf::internal::kEmptyString) {
    label_ = new ::std::string;
  }
  return label_;
}
inline ::std::string* ApplySettings::release_label() {
  clear_has_label();
  if (label_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = label_;
    label_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ApplySettings::set_allocated_label(::std::string* label) {
  if (label_ != &::google::protobuf::internal::kEmptyString) {
    delete label_;
  }
  if (label) {
    set_has_label();
    label_ = label;
  } else {
    clear_has_label();
    label_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// Ping

// optional bytes message = 1;
inline bool Ping::has_message() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Ping::set_has_message() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Ping::clear_has_message() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Ping::clear_message() {
  if (message_ != &::google::protobuf::internal::kEmptyString) {
    message_->clear();
  }
  clear_has_message();
}
inline const ::std::string& Ping::message() const {
  return *message_;
}
inline void Ping::set_message(const ::std::string& value) {
  set_has_message();
  if (message_ == &::google::protobuf::internal::kEmptyString) {
    message_ = new ::std::string;
  }
  message_->assign(value);
}
inline void Ping::set_message(const char* value) {
  set_has_message();
  if (message_ == &::google::protobuf::internal::kEmptyString) {
    message_ = new ::std::string;
  }
  message_->assign(value);
}
inline void Ping::set_message(const void* value, size_t size) {
  set_has_message();
  if (message_ == &::google::protobuf::internal::kEmptyString) {
    message_ = new ::std::string;
  }
  message_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Ping::mutable_message() {
  set_has_message();
  if (message_ == &::google::protobuf::internal::kEmptyString) {
    message_ = new ::std::string;
  }
  return message_;
}
inline ::std::string* Ping::release_message() {
  clear_has_message();
  if (message_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = message_;
    message_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Ping::set_allocated_message(::std::string* message) {
  if (message_ != &::google::protobuf::internal::kEmptyString) {
    delete message_;
  }
  if (message) {
    set_has_message();
    message_ = message;
  } else {
    clear_has_message();
    message_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// DebugLinkDecision

// required bool yes_no = 1;
inline bool DebugLinkDecision::has_yes_no() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DebugLinkDecision::set_has_yes_no() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DebugLinkDecision::clear_has_yes_no() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DebugLinkDecision::clear_yes_no() {
  yes_no_ = false;
  clear_has_yes_no();
}
inline bool DebugLinkDecision::yes_no() const {
  return yes_no_;
}
inline void DebugLinkDecision::set_yes_no(bool value) {
  set_has_yes_no();
  yes_no_ = value;
}

// -------------------------------------------------------------------

// DebugLinkGetState

// optional bool layout = 1;
inline bool DebugLinkGetState::has_layout() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DebugLinkGetState::set_has_layout() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DebugLinkGetState::clear_has_layout() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DebugLinkGetState::clear_layout() {
  layout_ = false;
  clear_has_layout();
}
inline bool DebugLinkGetState::layout() const {
  return layout_;
}
inline void DebugLinkGetState::set_layout(bool value) {
  set_has_layout();
  layout_ = value;
}

// optional bool pin = 2;
inline bool DebugLinkGetState::has_pin() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DebugLinkGetState::set_has_pin() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DebugLinkGetState::clear_has_pin() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DebugLinkGetState::clear_pin() {
  pin_ = false;
  clear_has_pin();
}
inline bool DebugLinkGetState::pin() const {
  return pin_;
}
inline void DebugLinkGetState::set_pin(bool value) {
  set_has_pin();
  pin_ = value;
}

// optional bool matrix = 3;
inline bool DebugLinkGetState::has_matrix() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DebugLinkGetState::set_has_matrix() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DebugLinkGetState::clear_has_matrix() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DebugLinkGetState::clear_matrix() {
  matrix_ = false;
  clear_has_matrix();
}
inline bool DebugLinkGetState::matrix() const {
  return matrix_;
}
inline void DebugLinkGetState::set_matrix(bool value) {
  set_has_matrix();
  matrix_ = value;
}

// optional bool seed = 4;
inline bool DebugLinkGetState::has_seed() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void DebugLinkGetState::set_has_seed() {
  _has_bits_[0] |= 0x00000008u;
}
inline void DebugLinkGetState::clear_has_seed() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void DebugLinkGetState::clear_seed() {
  seed_ = false;
  clear_has_seed();
}
inline bool DebugLinkGetState::seed() const {
  return seed_;
}
inline void DebugLinkGetState::set_seed(bool value) {
  set_has_seed();
  seed_ = value;
}

// -------------------------------------------------------------------

// DebugLinkState

// optional bytes layout = 1;
inline bool DebugLinkState::has_layout() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DebugLinkState::set_has_layout() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DebugLinkState::clear_has_layout() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DebugLinkState::clear_layout() {
  if (layout_ != &::google::protobuf::internal::kEmptyString) {
    layout_->clear();
  }
  clear_has_layout();
}
inline const ::std::string& DebugLinkState::layout() const {
  return *layout_;
}
inline void DebugLinkState::set_layout(const ::std::string& value) {
  set_has_layout();
  if (layout_ == &::google::protobuf::internal::kEmptyString) {
    layout_ = new ::std::string;
  }
  layout_->assign(value);
}
inline void DebugLinkState::set_layout(const char* value) {
  set_has_layout();
  if (layout_ == &::google::protobuf::internal::kEmptyString) {
    layout_ = new ::std::string;
  }
  layout_->assign(value);
}
inline void DebugLinkState::set_layout(const void* value, size_t size) {
  set_has_layout();
  if (layout_ == &::google::protobuf::internal::kEmptyString) {
    layout_ = new ::std::string;
  }
  layout_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DebugLinkState::mutable_layout() {
  set_has_layout();
  if (layout_ == &::google::protobuf::internal::kEmptyString) {
    layout_ = new ::std::string;
  }
  return layout_;
}
inline ::std::string* DebugLinkState::release_layout() {
  clear_has_layout();
  if (layout_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = layout_;
    layout_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void DebugLinkState::set_allocated_layout(::std::string* layout) {
  if (layout_ != &::google::protobuf::internal::kEmptyString) {
    delete layout_;
  }
  if (layout) {
    set_has_layout();
    layout_ = layout;
  } else {
    clear_has_layout();
    layout_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes pin = 2;
inline bool DebugLinkState::has_pin() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DebugLinkState::set_has_pin() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DebugLinkState::clear_has_pin() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DebugLinkState::clear_pin() {
  if (pin_ != &::google::protobuf::internal::kEmptyString) {
    pin_->clear();
  }
  clear_has_pin();
}
inline const ::std::string& DebugLinkState::pin() const {
  return *pin_;
}
inline void DebugLinkState::set_pin(const ::std::string& value) {
  set_has_pin();
  if (pin_ == &::google::protobuf::internal::kEmptyString) {
    pin_ = new ::std::string;
  }
  pin_->assign(value);
}
inline void DebugLinkState::set_pin(const char* value) {
  set_has_pin();
  if (pin_ == &::google::protobuf::internal::kEmptyString) {
    pin_ = new ::std::string;
  }
  pin_->assign(value);
}
inline void DebugLinkState::set_pin(const void* value, size_t size) {
  set_has_pin();
  if (pin_ == &::google::protobuf::internal::kEmptyString) {
    pin_ = new ::std::string;
  }
  pin_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DebugLinkState::mutable_pin() {
  set_has_pin();
  if (pin_ == &::google::protobuf::internal::kEmptyString) {
    pin_ = new ::std::string;
  }
  return pin_;
}
inline ::std::string* DebugLinkState::release_pin() {
  clear_has_pin();
  if (pin_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = pin_;
    pin_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void DebugLinkState::set_allocated_pin(::std::string* pin) {
  if (pin_ != &::google::protobuf::internal::kEmptyString) {
    delete pin_;
  }
  if (pin) {
    set_has_pin();
    pin_ = pin;
  } else {
    clear_has_pin();
    pin_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes matrix = 3;
inline bool DebugLinkState::has_matrix() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DebugLinkState::set_has_matrix() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DebugLinkState::clear_has_matrix() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DebugLinkState::clear_matrix() {
  if (matrix_ != &::google::protobuf::internal::kEmptyString) {
    matrix_->clear();
  }
  clear_has_matrix();
}
inline const ::std::string& DebugLinkState::matrix() const {
  return *matrix_;
}
inline void DebugLinkState::set_matrix(const ::std::string& value) {
  set_has_matrix();
  if (matrix_ == &::google::protobuf::internal::kEmptyString) {
    matrix_ = new ::std::string;
  }
  matrix_->assign(value);
}
inline void DebugLinkState::set_matrix(const char* value) {
  set_has_matrix();
  if (matrix_ == &::google::protobuf::internal::kEmptyString) {
    matrix_ = new ::std::string;
  }
  matrix_->assign(value);
}
inline void DebugLinkState::set_matrix(const void* value, size_t size) {
  set_has_matrix();
  if (matrix_ == &::google::protobuf::internal::kEmptyString) {
    matrix_ = new ::std::string;
  }
  matrix_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DebugLinkState::mutable_matrix() {
  set_has_matrix();
  if (matrix_ == &::google::protobuf::internal::kEmptyString) {
    matrix_ = new ::std::string;
  }
  return matrix_;
}
inline ::std::string* DebugLinkState::release_matrix() {
  clear_has_matrix();
  if (matrix_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = matrix_;
    matrix_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void DebugLinkState::set_allocated_matrix(::std::string* matrix) {
  if (matrix_ != &::google::protobuf::internal::kEmptyString) {
    delete matrix_;
  }
  if (matrix) {
    set_has_matrix();
    matrix_ = matrix;
  } else {
    clear_has_matrix();
    matrix_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes seed = 4;
inline bool DebugLinkState::has_seed() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void DebugLinkState::set_has_seed() {
  _has_bits_[0] |= 0x00000008u;
}
inline void DebugLinkState::clear_has_seed() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void DebugLinkState::clear_seed() {
  if (seed_ != &::google::protobuf::internal::kEmptyString) {
    seed_->clear();
  }
  clear_has_seed();
}
inline const ::std::string& DebugLinkState::seed() const {
  return *seed_;
}
inline void DebugLinkState::set_seed(const ::std::string& value) {
  set_has_seed();
  if (seed_ == &::google::protobuf::internal::kEmptyString) {
    seed_ = new ::std::string;
  }
  seed_->assign(value);
}
inline void DebugLinkState::set_seed(const char* value) {
  set_has_seed();
  if (seed_ == &::google::protobuf::internal::kEmptyString) {
    seed_ = new ::std::string;
  }
  seed_->assign(value);
}
inline void DebugLinkState::set_seed(const void* value, size_t size) {
  set_has_seed();
  if (seed_ == &::google::protobuf::internal::kEmptyString) {
    seed_ = new ::std::string;
  }
  seed_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DebugLinkState::mutable_seed() {
  set_has_seed();
  if (seed_ == &::google::protobuf::internal::kEmptyString) {
    seed_ = new ::std::string;
  }
  return seed_;
}
inline ::std::string* DebugLinkState::release_seed() {
  clear_has_seed();
  if (seed_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = seed_;
    seed_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void DebugLinkState::set_allocated_seed(::std::string* seed) {
  if (seed_ != &::google::protobuf::internal::kEmptyString) {
    delete seed_;
  }
  if (seed) {
    set_has_seed();
    seed_ = seed;
  } else {
    clear_has_seed();
    seed_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// DebugLinkStop

// -------------------------------------------------------------------

// Success

// optional bytes message = 1;
inline bool Success::has_message() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Success::set_has_message() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Success::clear_has_message() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Success::clear_message() {
  if (message_ != &::google::protobuf::internal::kEmptyString) {
    message_->clear();
  }
  clear_has_message();
}
inline const ::std::string& Success::message() const {
  return *message_;
}
inline void Success::set_message(const ::std::string& value) {
  set_has_message();
  if (message_ == &::google::protobuf::internal::kEmptyString) {
    message_ = new ::std::string;
  }
  message_->assign(value);
}
inline void Success::set_message(const char* value) {
  set_has_message();
  if (message_ == &::google::protobuf::internal::kEmptyString) {
    message_ = new ::std::string;
  }
  message_->assign(value);
}
inline void Success::set_message(const void* value, size_t size) {
  set_has_message();
  if (message_ == &::google::protobuf::internal::kEmptyString) {
    message_ = new ::std::string;
  }
  message_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Success::mutable_message() {
  set_has_message();
  if (message_ == &::google::protobuf::internal::kEmptyString) {
    message_ = new ::std::string;
  }
  return message_;
}
inline ::std::string* Success::release_message() {
  clear_has_message();
  if (message_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = message_;
    message_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Success::set_allocated_message(::std::string* message) {
  if (message_ != &::google::protobuf::internal::kEmptyString) {
    delete message_;
  }
  if (message) {
    set_has_message();
    message_ = message;
  } else {
    clear_has_message();
    message_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// Failure

// optional int32 code = 1;
inline bool Failure::has_code() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Failure::set_has_code() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Failure::clear_has_code() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Failure::clear_code() {
  code_ = 0;
  clear_has_code();
}
inline ::google::protobuf::int32 Failure::code() const {
  return code_;
}
inline void Failure::set_code(::google::protobuf::int32 value) {
  set_has_code();
  code_ = value;
}

// optional bytes message = 2;
inline bool Failure::has_message() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Failure::set_has_message() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Failure::clear_has_message() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Failure::clear_message() {
  if (message_ != &::google::protobuf::internal::kEmptyString) {
    message_->clear();
  }
  clear_has_message();
}
inline const ::std::string& Failure::message() const {
  return *message_;
}
inline void Failure::set_message(const ::std::string& value) {
  set_has_message();
  if (message_ == &::google::protobuf::internal::kEmptyString) {
    message_ = new ::std::string;
  }
  message_->assign(value);
}
inline void Failure::set_message(const char* value) {
  set_has_message();
  if (message_ == &::google::protobuf::internal::kEmptyString) {
    message_ = new ::std::string;
  }
  message_->assign(value);
}
inline void Failure::set_message(const void* value, size_t size) {
  set_has_message();
  if (message_ == &::google::protobuf::internal::kEmptyString) {
    message_ = new ::std::string;
  }
  message_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Failure::mutable_message() {
  set_has_message();
  if (message_ == &::google::protobuf::internal::kEmptyString) {
    message_ = new ::std::string;
  }
  return message_;
}
inline ::std::string* Failure::release_message() {
  clear_has_message();
  if (message_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = message_;
    message_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Failure::set_allocated_message(::std::string* message) {
  if (message_ != &::google::protobuf::internal::kEmptyString) {
    delete message_;
  }
  if (message) {
    set_has_message();
    message_ = message;
  } else {
    clear_has_message();
    message_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// ButtonRequest

// -------------------------------------------------------------------

// ButtonAck

// -------------------------------------------------------------------

// ButtonCancel

// -------------------------------------------------------------------

// PinMatrixRequest

// optional bytes message = 1;
inline bool PinMatrixRequest::has_message() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PinMatrixRequest::set_has_message() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PinMatrixRequest::clear_has_message() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PinMatrixRequest::clear_message() {
  if (message_ != &::google::protobuf::internal::kEmptyString) {
    message_->clear();
  }
  clear_has_message();
}
inline const ::std::string& PinMatrixRequest::message() const {
  return *message_;
}
inline void PinMatrixRequest::set_message(const ::std::string& value) {
  set_has_message();
  if (message_ == &::google::protobuf::internal::kEmptyString) {
    message_ = new ::std::string;
  }
  message_->assign(value);
}
inline void PinMatrixRequest::set_message(const char* value) {
  set_has_message();
  if (message_ == &::google::protobuf::internal::kEmptyString) {
    message_ = new ::std::string;
  }
  message_->assign(value);
}
inline void PinMatrixRequest::set_message(const void* value, size_t size) {
  set_has_message();
  if (message_ == &::google::protobuf::internal::kEmptyString) {
    message_ = new ::std::string;
  }
  message_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PinMatrixRequest::mutable_message() {
  set_has_message();
  if (message_ == &::google::protobuf::internal::kEmptyString) {
    message_ = new ::std::string;
  }
  return message_;
}
inline ::std::string* PinMatrixRequest::release_message() {
  clear_has_message();
  if (message_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = message_;
    message_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void PinMatrixRequest::set_allocated_message(::std::string* message) {
  if (message_ != &::google::protobuf::internal::kEmptyString) {
    delete message_;
  }
  if (message) {
    set_has_message();
    message_ = message;
  } else {
    clear_has_message();
    message_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// PinMatrixAck

// required bytes pin = 1;
inline bool PinMatrixAck::has_pin() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PinMatrixAck::set_has_pin() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PinMatrixAck::clear_has_pin() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PinMatrixAck::clear_pin() {
  if (pin_ != &::google::protobuf::internal::kEmptyString) {
    pin_->clear();
  }
  clear_has_pin();
}
inline const ::std::string& PinMatrixAck::pin() const {
  return *pin_;
}
inline void PinMatrixAck::set_pin(const ::std::string& value) {
  set_has_pin();
  if (pin_ == &::google::protobuf::internal::kEmptyString) {
    pin_ = new ::std::string;
  }
  pin_->assign(value);
}
inline void PinMatrixAck::set_pin(const char* value) {
  set_has_pin();
  if (pin_ == &::google::protobuf::internal::kEmptyString) {
    pin_ = new ::std::string;
  }
  pin_->assign(value);
}
inline void PinMatrixAck::set_pin(const void* value, size_t size) {
  set_has_pin();
  if (pin_ == &::google::protobuf::internal::kEmptyString) {
    pin_ = new ::std::string;
  }
  pin_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PinMatrixAck::mutable_pin() {
  set_has_pin();
  if (pin_ == &::google::protobuf::internal::kEmptyString) {
    pin_ = new ::std::string;
  }
  return pin_;
}
inline ::std::string* PinMatrixAck::release_pin() {
  clear_has_pin();
  if (pin_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = pin_;
    pin_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void PinMatrixAck::set_allocated_pin(::std::string* pin) {
  if (pin_ != &::google::protobuf::internal::kEmptyString) {
    delete pin_;
  }
  if (pin) {
    set_has_pin();
    pin_ = pin;
  } else {
    clear_has_pin();
    pin_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// PinMatrixCancel

// -------------------------------------------------------------------

// GetEntropy

// required uint32 size = 1;
inline bool GetEntropy::has_size() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetEntropy::set_has_size() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetEntropy::clear_has_size() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetEntropy::clear_size() {
  size_ = 0u;
  clear_has_size();
}
inline ::google::protobuf::uint32 GetEntropy::size() const {
  return size_;
}
inline void GetEntropy::set_size(::google::protobuf::uint32 value) {
  set_has_size();
  size_ = value;
}

// -------------------------------------------------------------------

// Entropy

// required bytes entropy = 1;
inline bool Entropy::has_entropy() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Entropy::set_has_entropy() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Entropy::clear_has_entropy() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Entropy::clear_entropy() {
  if (entropy_ != &::google::protobuf::internal::kEmptyString) {
    entropy_->clear();
  }
  clear_has_entropy();
}
inline const ::std::string& Entropy::entropy() const {
  return *entropy_;
}
inline void Entropy::set_entropy(const ::std::string& value) {
  set_has_entropy();
  if (entropy_ == &::google::protobuf::internal::kEmptyString) {
    entropy_ = new ::std::string;
  }
  entropy_->assign(value);
}
inline void Entropy::set_entropy(const char* value) {
  set_has_entropy();
  if (entropy_ == &::google::protobuf::internal::kEmptyString) {
    entropy_ = new ::std::string;
  }
  entropy_->assign(value);
}
inline void Entropy::set_entropy(const void* value, size_t size) {
  set_has_entropy();
  if (entropy_ == &::google::protobuf::internal::kEmptyString) {
    entropy_ = new ::std::string;
  }
  entropy_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Entropy::mutable_entropy() {
  set_has_entropy();
  if (entropy_ == &::google::protobuf::internal::kEmptyString) {
    entropy_ = new ::std::string;
  }
  return entropy_;
}
inline ::std::string* Entropy::release_entropy() {
  clear_has_entropy();
  if (entropy_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = entropy_;
    entropy_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Entropy::set_allocated_entropy(::std::string* entropy) {
  if (entropy_ != &::google::protobuf::internal::kEmptyString) {
    delete entropy_;
  }
  if (entropy) {
    set_has_entropy();
    entropy_ = entropy;
  } else {
    clear_has_entropy();
    entropy_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// GetMasterPublicKey

// -------------------------------------------------------------------

// MasterPublicKey

// required bytes key = 1;
inline bool MasterPublicKey::has_key() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MasterPublicKey::set_has_key() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MasterPublicKey::clear_has_key() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MasterPublicKey::clear_key() {
  if (key_ != &::google::protobuf::internal::kEmptyString) {
    key_->clear();
  }
  clear_has_key();
}
inline const ::std::string& MasterPublicKey::key() const {
  return *key_;
}
inline void MasterPublicKey::set_key(const ::std::string& value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  key_->assign(value);
}
inline void MasterPublicKey::set_key(const char* value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  key_->assign(value);
}
inline void MasterPublicKey::set_key(const void* value, size_t size) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  key_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MasterPublicKey::mutable_key() {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  return key_;
}
inline ::std::string* MasterPublicKey::release_key() {
  clear_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = key_;
    key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void MasterPublicKey::set_allocated_key(::std::string* key) {
  if (key_ != &::google::protobuf::internal::kEmptyString) {
    delete key_;
  }
  if (key) {
    set_has_key();
    key_ = key;
  } else {
    clear_has_key();
    key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// GetAddress

// repeated uint32 address_n = 1;
inline int GetAddress::address_n_size() const {
  return address_n_.size();
}
inline void GetAddress::clear_address_n() {
  address_n_.Clear();
}
inline ::google::protobuf::uint32 GetAddress::address_n(int index) const {
  return address_n_.Get(index);
}
inline void GetAddress::set_address_n(int index, ::google::protobuf::uint32 value) {
  address_n_.Set(index, value);
}
inline void GetAddress::add_address_n(::google::protobuf::uint32 value) {
  address_n_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
GetAddress::address_n() const {
  return address_n_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
GetAddress::mutable_address_n() {
  return &address_n_;
}

// -------------------------------------------------------------------

// Address

// required bytes address = 1;
inline bool Address::has_address() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Address::set_has_address() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Address::clear_has_address() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Address::clear_address() {
  if (address_ != &::google::protobuf::internal::kEmptyString) {
    address_->clear();
  }
  clear_has_address();
}
inline const ::std::string& Address::address() const {
  return *address_;
}
inline void Address::set_address(const ::std::string& value) {
  set_has_address();
  if (address_ == &::google::protobuf::internal::kEmptyString) {
    address_ = new ::std::string;
  }
  address_->assign(value);
}
inline void Address::set_address(const char* value) {
  set_has_address();
  if (address_ == &::google::protobuf::internal::kEmptyString) {
    address_ = new ::std::string;
  }
  address_->assign(value);
}
inline void Address::set_address(const void* value, size_t size) {
  set_has_address();
  if (address_ == &::google::protobuf::internal::kEmptyString) {
    address_ = new ::std::string;
  }
  address_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Address::mutable_address() {
  set_has_address();
  if (address_ == &::google::protobuf::internal::kEmptyString) {
    address_ = new ::std::string;
  }
  return address_;
}
inline ::std::string* Address::release_address() {
  clear_has_address();
  if (address_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = address_;
    address_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Address::set_allocated_address(::std::string* address) {
  if (address_ != &::google::protobuf::internal::kEmptyString) {
    delete address_;
  }
  if (address) {
    set_has_address();
    address_ = address;
  } else {
    clear_has_address();
    address_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// LoadDevice

// optional bytes seed = 1;
inline bool LoadDevice::has_seed() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LoadDevice::set_has_seed() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LoadDevice::clear_has_seed() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LoadDevice::clear_seed() {
  if (seed_ != &::google::protobuf::internal::kEmptyString) {
    seed_->clear();
  }
  clear_has_seed();
}
inline const ::std::string& LoadDevice::seed() const {
  return *seed_;
}
inline void LoadDevice::set_seed(const ::std::string& value) {
  set_has_seed();
  if (seed_ == &::google::protobuf::internal::kEmptyString) {
    seed_ = new ::std::string;
  }
  seed_->assign(value);
}
inline void LoadDevice::set_seed(const char* value) {
  set_has_seed();
  if (seed_ == &::google::protobuf::internal::kEmptyString) {
    seed_ = new ::std::string;
  }
  seed_->assign(value);
}
inline void LoadDevice::set_seed(const void* value, size_t size) {
  set_has_seed();
  if (seed_ == &::google::protobuf::internal::kEmptyString) {
    seed_ = new ::std::string;
  }
  seed_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LoadDevice::mutable_seed() {
  set_has_seed();
  if (seed_ == &::google::protobuf::internal::kEmptyString) {
    seed_ = new ::std::string;
  }
  return seed_;
}
inline ::std::string* LoadDevice::release_seed() {
  clear_has_seed();
  if (seed_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = seed_;
    seed_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void LoadDevice::set_allocated_seed(::std::string* seed) {
  if (seed_ != &::google::protobuf::internal::kEmptyString) {
    delete seed_;
  }
  if (seed) {
    set_has_seed();
    seed_ = seed;
  } else {
    clear_has_seed();
    seed_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .XprvType xprv = 2;
inline bool LoadDevice::has_xprv() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LoadDevice::set_has_xprv() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LoadDevice::clear_has_xprv() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LoadDevice::clear_xprv() {
  if (xprv_ != NULL) xprv_->::XprvType::Clear();
  clear_has_xprv();
}
inline const ::XprvType& LoadDevice::xprv() const {
  return xprv_ != NULL ? *xprv_ : *default_instance_->xprv_;
}
inline ::XprvType* LoadDevice::mutable_xprv() {
  set_has_xprv();
  if (xprv_ == NULL) xprv_ = new ::XprvType;
  return xprv_;
}
inline ::XprvType* LoadDevice::release_xprv() {
  clear_has_xprv();
  ::XprvType* temp = xprv_;
  xprv_ = NULL;
  return temp;
}
inline void LoadDevice::set_allocated_xprv(::XprvType* xprv) {
  delete xprv_;
  xprv_ = xprv;
  if (xprv) {
    set_has_xprv();
  } else {
    clear_has_xprv();
  }
}

// optional bytes pin = 3;
inline bool LoadDevice::has_pin() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void LoadDevice::set_has_pin() {
  _has_bits_[0] |= 0x00000004u;
}
inline void LoadDevice::clear_has_pin() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void LoadDevice::clear_pin() {
  if (pin_ != &::google::protobuf::internal::kEmptyString) {
    pin_->clear();
  }
  clear_has_pin();
}
inline const ::std::string& LoadDevice::pin() const {
  return *pin_;
}
inline void LoadDevice::set_pin(const ::std::string& value) {
  set_has_pin();
  if (pin_ == &::google::protobuf::internal::kEmptyString) {
    pin_ = new ::std::string;
  }
  pin_->assign(value);
}
inline void LoadDevice::set_pin(const char* value) {
  set_has_pin();
  if (pin_ == &::google::protobuf::internal::kEmptyString) {
    pin_ = new ::std::string;
  }
  pin_->assign(value);
}
inline void LoadDevice::set_pin(const void* value, size_t size) {
  set_has_pin();
  if (pin_ == &::google::protobuf::internal::kEmptyString) {
    pin_ = new ::std::string;
  }
  pin_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LoadDevice::mutable_pin() {
  set_has_pin();
  if (pin_ == &::google::protobuf::internal::kEmptyString) {
    pin_ = new ::std::string;
  }
  return pin_;
}
inline ::std::string* LoadDevice::release_pin() {
  clear_has_pin();
  if (pin_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = pin_;
    pin_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void LoadDevice::set_allocated_pin(::std::string* pin) {
  if (pin_ != &::google::protobuf::internal::kEmptyString) {
    delete pin_;
  }
  if (pin) {
    set_has_pin();
    pin_ = pin;
  } else {
    clear_has_pin();
    pin_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// ResetDevice

// optional bytes random = 7;
inline bool ResetDevice::has_random() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ResetDevice::set_has_random() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ResetDevice::clear_has_random() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ResetDevice::clear_random() {
  if (random_ != &::google::protobuf::internal::kEmptyString) {
    random_->clear();
  }
  clear_has_random();
}
inline const ::std::string& ResetDevice::random() const {
  return *random_;
}
inline void ResetDevice::set_random(const ::std::string& value) {
  set_has_random();
  if (random_ == &::google::protobuf::internal::kEmptyString) {
    random_ = new ::std::string;
  }
  random_->assign(value);
}
inline void ResetDevice::set_random(const char* value) {
  set_has_random();
  if (random_ == &::google::protobuf::internal::kEmptyString) {
    random_ = new ::std::string;
  }
  random_->assign(value);
}
inline void ResetDevice::set_random(const void* value, size_t size) {
  set_has_random();
  if (random_ == &::google::protobuf::internal::kEmptyString) {
    random_ = new ::std::string;
  }
  random_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ResetDevice::mutable_random() {
  set_has_random();
  if (random_ == &::google::protobuf::internal::kEmptyString) {
    random_ = new ::std::string;
  }
  return random_;
}
inline ::std::string* ResetDevice::release_random() {
  clear_has_random();
  if (random_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = random_;
    random_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ResetDevice::set_allocated_random(::std::string* random) {
  if (random_ != &::google::protobuf::internal::kEmptyString) {
    delete random_;
  }
  if (random) {
    set_has_random();
    random_ = random;
  } else {
    clear_has_random();
    random_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// SignTx

// required uint32 outputs_count = 3;
inline bool SignTx::has_outputs_count() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SignTx::set_has_outputs_count() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SignTx::clear_has_outputs_count() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SignTx::clear_outputs_count() {
  outputs_count_ = 0u;
  clear_has_outputs_count();
}
inline ::google::protobuf::uint32 SignTx::outputs_count() const {
  return outputs_count_;
}
inline void SignTx::set_outputs_count(::google::protobuf::uint32 value) {
  set_has_outputs_count();
  outputs_count_ = value;
}

// required uint32 inputs_count = 5;
inline bool SignTx::has_inputs_count() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SignTx::set_has_inputs_count() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SignTx::clear_has_inputs_count() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SignTx::clear_inputs_count() {
  inputs_count_ = 0u;
  clear_has_inputs_count();
}
inline ::google::protobuf::uint32 SignTx::inputs_count() const {
  return inputs_count_;
}
inline void SignTx::set_inputs_count(::google::protobuf::uint32 value) {
  set_has_inputs_count();
  inputs_count_ = value;
}

// -------------------------------------------------------------------

// SimpleSignTx

// repeated .TxInput inputs = 1;
inline int SimpleSignTx::inputs_size() const {
  return inputs_.size();
}
inline void SimpleSignTx::clear_inputs() {
  inputs_.Clear();
}
inline const ::TxInput& SimpleSignTx::inputs(int index) const {
  return inputs_.Get(index);
}
inline ::TxInput* SimpleSignTx::mutable_inputs(int index) {
  return inputs_.Mutable(index);
}
inline ::TxInput* SimpleSignTx::add_inputs() {
  return inputs_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::TxInput >&
SimpleSignTx::inputs() const {
  return inputs_;
}
inline ::google::protobuf::RepeatedPtrField< ::TxInput >*
SimpleSignTx::mutable_inputs() {
  return &inputs_;
}

// repeated .TxOutput outputs = 2;
inline int SimpleSignTx::outputs_size() const {
  return outputs_.size();
}
inline void SimpleSignTx::clear_outputs() {
  outputs_.Clear();
}
inline const ::TxOutput& SimpleSignTx::outputs(int index) const {
  return outputs_.Get(index);
}
inline ::TxOutput* SimpleSignTx::mutable_outputs(int index) {
  return outputs_.Mutable(index);
}
inline ::TxOutput* SimpleSignTx::add_outputs() {
  return outputs_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::TxOutput >&
SimpleSignTx::outputs() const {
  return outputs_;
}
inline ::google::protobuf::RepeatedPtrField< ::TxOutput >*
SimpleSignTx::mutable_outputs() {
  return &outputs_;
}

// -------------------------------------------------------------------

// TxRequest

// optional int32 request_index = 1;
inline bool TxRequest::has_request_index() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TxRequest::set_has_request_index() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TxRequest::clear_has_request_index() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TxRequest::clear_request_index() {
  request_index_ = 0;
  clear_has_request_index();
}
inline ::google::protobuf::int32 TxRequest::request_index() const {
  return request_index_;
}
inline void TxRequest::set_request_index(::google::protobuf::int32 value) {
  set_has_request_index();
  request_index_ = value;
}

// optional .RequestType request_type = 2;
inline bool TxRequest::has_request_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TxRequest::set_has_request_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TxRequest::clear_has_request_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TxRequest::clear_request_type() {
  request_type_ = 0;
  clear_has_request_type();
}
inline ::RequestType TxRequest::request_type() const {
  return static_cast< ::RequestType >(request_type_);
}
inline void TxRequest::set_request_type(::RequestType value) {
  assert(::RequestType_IsValid(value));
  set_has_request_type();
  request_type_ = value;
}

// optional int32 signed_index = 3;
inline bool TxRequest::has_signed_index() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TxRequest::set_has_signed_index() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TxRequest::clear_has_signed_index() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TxRequest::clear_signed_index() {
  signed_index_ = 0;
  clear_has_signed_index();
}
inline ::google::protobuf::int32 TxRequest::signed_index() const {
  return signed_index_;
}
inline void TxRequest::set_signed_index(::google::protobuf::int32 value) {
  set_has_signed_index();
  signed_index_ = value;
}

// optional bytes signature = 4;
inline bool TxRequest::has_signature() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TxRequest::set_has_signature() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TxRequest::clear_has_signature() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TxRequest::clear_signature() {
  if (signature_ != &::google::protobuf::internal::kEmptyString) {
    signature_->clear();
  }
  clear_has_signature();
}
inline const ::std::string& TxRequest::signature() const {
  return *signature_;
}
inline void TxRequest::set_signature(const ::std::string& value) {
  set_has_signature();
  if (signature_ == &::google::protobuf::internal::kEmptyString) {
    signature_ = new ::std::string;
  }
  signature_->assign(value);
}
inline void TxRequest::set_signature(const char* value) {
  set_has_signature();
  if (signature_ == &::google::protobuf::internal::kEmptyString) {
    signature_ = new ::std::string;
  }
  signature_->assign(value);
}
inline void TxRequest::set_signature(const void* value, size_t size) {
  set_has_signature();
  if (signature_ == &::google::protobuf::internal::kEmptyString) {
    signature_ = new ::std::string;
  }
  signature_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TxRequest::mutable_signature() {
  set_has_signature();
  if (signature_ == &::google::protobuf::internal::kEmptyString) {
    signature_ = new ::std::string;
  }
  return signature_;
}
inline ::std::string* TxRequest::release_signature() {
  clear_has_signature();
  if (signature_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = signature_;
    signature_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TxRequest::set_allocated_signature(::std::string* signature) {
  if (signature_ != &::google::protobuf::internal::kEmptyString) {
    delete signature_;
  }
  if (signature) {
    set_has_signature();
    signature_ = signature;
  } else {
    clear_has_signature();
    signature_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes serialized_tx = 5;
inline bool TxRequest::has_serialized_tx() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TxRequest::set_has_serialized_tx() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TxRequest::clear_has_serialized_tx() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TxRequest::clear_serialized_tx() {
  if (serialized_tx_ != &::google::protobuf::internal::kEmptyString) {
    serialized_tx_->clear();
  }
  clear_has_serialized_tx();
}
inline const ::std::string& TxRequest::serialized_tx() const {
  return *serialized_tx_;
}
inline void TxRequest::set_serialized_tx(const ::std::string& value) {
  set_has_serialized_tx();
  if (serialized_tx_ == &::google::protobuf::internal::kEmptyString) {
    serialized_tx_ = new ::std::string;
  }
  serialized_tx_->assign(value);
}
inline void TxRequest::set_serialized_tx(const char* value) {
  set_has_serialized_tx();
  if (serialized_tx_ == &::google::protobuf::internal::kEmptyString) {
    serialized_tx_ = new ::std::string;
  }
  serialized_tx_->assign(value);
}
inline void TxRequest::set_serialized_tx(const void* value, size_t size) {
  set_has_serialized_tx();
  if (serialized_tx_ == &::google::protobuf::internal::kEmptyString) {
    serialized_tx_ = new ::std::string;
  }
  serialized_tx_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TxRequest::mutable_serialized_tx() {
  set_has_serialized_tx();
  if (serialized_tx_ == &::google::protobuf::internal::kEmptyString) {
    serialized_tx_ = new ::std::string;
  }
  return serialized_tx_;
}
inline ::std::string* TxRequest::release_serialized_tx() {
  clear_has_serialized_tx();
  if (serialized_tx_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = serialized_tx_;
    serialized_tx_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TxRequest::set_allocated_serialized_tx(::std::string* serialized_tx) {
  if (serialized_tx_ != &::google::protobuf::internal::kEmptyString) {
    delete serialized_tx_;
  }
  if (serialized_tx) {
    set_has_serialized_tx();
    serialized_tx_ = serialized_tx;
  } else {
    clear_has_serialized_tx();
    serialized_tx_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// TxInput

// required uint32 index = 1;
inline bool TxInput::has_index() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TxInput::set_has_index() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TxInput::clear_has_index() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TxInput::clear_index() {
  index_ = 0u;
  clear_has_index();
}
inline ::google::protobuf::uint32 TxInput::index() const {
  return index_;
}
inline void TxInput::set_index(::google::protobuf::uint32 value) {
  set_has_index();
  index_ = value;
}

// repeated uint32 address_n = 2;
inline int TxInput::address_n_size() const {
  return address_n_.size();
}
inline void TxInput::clear_address_n() {
  address_n_.Clear();
}
inline ::google::protobuf::uint32 TxInput::address_n(int index) const {
  return address_n_.Get(index);
}
inline void TxInput::set_address_n(int index, ::google::protobuf::uint32 value) {
  address_n_.Set(index, value);
}
inline void TxInput::add_address_n(::google::protobuf::uint32 value) {
  address_n_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
TxInput::address_n() const {
  return address_n_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
TxInput::mutable_address_n() {
  return &address_n_;
}

// required uint64 amount = 3;
inline bool TxInput::has_amount() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TxInput::set_has_amount() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TxInput::clear_has_amount() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TxInput::clear_amount() {
  amount_ = GOOGLE_ULONGLONG(0);
  clear_has_amount();
}
inline ::google::protobuf::uint64 TxInput::amount() const {
  return amount_;
}
inline void TxInput::set_amount(::google::protobuf::uint64 value) {
  set_has_amount();
  amount_ = value;
}

// required bytes prev_hash = 4;
inline bool TxInput::has_prev_hash() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TxInput::set_has_prev_hash() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TxInput::clear_has_prev_hash() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TxInput::clear_prev_hash() {
  if (prev_hash_ != &::google::protobuf::internal::kEmptyString) {
    prev_hash_->clear();
  }
  clear_has_prev_hash();
}
inline const ::std::string& TxInput::prev_hash() const {
  return *prev_hash_;
}
inline void TxInput::set_prev_hash(const ::std::string& value) {
  set_has_prev_hash();
  if (prev_hash_ == &::google::protobuf::internal::kEmptyString) {
    prev_hash_ = new ::std::string;
  }
  prev_hash_->assign(value);
}
inline void TxInput::set_prev_hash(const char* value) {
  set_has_prev_hash();
  if (prev_hash_ == &::google::protobuf::internal::kEmptyString) {
    prev_hash_ = new ::std::string;
  }
  prev_hash_->assign(value);
}
inline void TxInput::set_prev_hash(const void* value, size_t size) {
  set_has_prev_hash();
  if (prev_hash_ == &::google::protobuf::internal::kEmptyString) {
    prev_hash_ = new ::std::string;
  }
  prev_hash_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TxInput::mutable_prev_hash() {
  set_has_prev_hash();
  if (prev_hash_ == &::google::protobuf::internal::kEmptyString) {
    prev_hash_ = new ::std::string;
  }
  return prev_hash_;
}
inline ::std::string* TxInput::release_prev_hash() {
  clear_has_prev_hash();
  if (prev_hash_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = prev_hash_;
    prev_hash_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TxInput::set_allocated_prev_hash(::std::string* prev_hash) {
  if (prev_hash_ != &::google::protobuf::internal::kEmptyString) {
    delete prev_hash_;
  }
  if (prev_hash) {
    set_has_prev_hash();
    prev_hash_ = prev_hash;
  } else {
    clear_has_prev_hash();
    prev_hash_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required uint32 prev_index = 5;
inline bool TxInput::has_prev_index() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TxInput::set_has_prev_index() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TxInput::clear_has_prev_index() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TxInput::clear_prev_index() {
  prev_index_ = 0u;
  clear_has_prev_index();
}
inline ::google::protobuf::uint32 TxInput::prev_index() const {
  return prev_index_;
}
inline void TxInput::set_prev_index(::google::protobuf::uint32 value) {
  set_has_prev_index();
  prev_index_ = value;
}

// optional bytes script_sig = 6;
inline bool TxInput::has_script_sig() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TxInput::set_has_script_sig() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TxInput::clear_has_script_sig() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TxInput::clear_script_sig() {
  if (script_sig_ != &::google::protobuf::internal::kEmptyString) {
    script_sig_->clear();
  }
  clear_has_script_sig();
}
inline const ::std::string& TxInput::script_sig() const {
  return *script_sig_;
}
inline void TxInput::set_script_sig(const ::std::string& value) {
  set_has_script_sig();
  if (script_sig_ == &::google::protobuf::internal::kEmptyString) {
    script_sig_ = new ::std::string;
  }
  script_sig_->assign(value);
}
inline void TxInput::set_script_sig(const char* value) {
  set_has_script_sig();
  if (script_sig_ == &::google::protobuf::internal::kEmptyString) {
    script_sig_ = new ::std::string;
  }
  script_sig_->assign(value);
}
inline void TxInput::set_script_sig(const void* value, size_t size) {
  set_has_script_sig();
  if (script_sig_ == &::google::protobuf::internal::kEmptyString) {
    script_sig_ = new ::std::string;
  }
  script_sig_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TxInput::mutable_script_sig() {
  set_has_script_sig();
  if (script_sig_ == &::google::protobuf::internal::kEmptyString) {
    script_sig_ = new ::std::string;
  }
  return script_sig_;
}
inline ::std::string* TxInput::release_script_sig() {
  clear_has_script_sig();
  if (script_sig_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = script_sig_;
    script_sig_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TxInput::set_allocated_script_sig(::std::string* script_sig) {
  if (script_sig_ != &::google::protobuf::internal::kEmptyString) {
    delete script_sig_;
  }
  if (script_sig) {
    set_has_script_sig();
    script_sig_ = script_sig;
  } else {
    clear_has_script_sig();
    script_sig_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// TxOutput

// required uint32 index = 1;
inline bool TxOutput::has_index() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TxOutput::set_has_index() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TxOutput::clear_has_index() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TxOutput::clear_index() {
  index_ = 0u;
  clear_has_index();
}
inline ::google::protobuf::uint32 TxOutput::index() const {
  return index_;
}
inline void TxOutput::set_index(::google::protobuf::uint32 value) {
  set_has_index();
  index_ = value;
}

// required bytes address = 2;
inline bool TxOutput::has_address() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TxOutput::set_has_address() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TxOutput::clear_has_address() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TxOutput::clear_address() {
  if (address_ != &::google::protobuf::internal::kEmptyString) {
    address_->clear();
  }
  clear_has_address();
}
inline const ::std::string& TxOutput::address() const {
  return *address_;
}
inline void TxOutput::set_address(const ::std::string& value) {
  set_has_address();
  if (address_ == &::google::protobuf::internal::kEmptyString) {
    address_ = new ::std::string;
  }
  address_->assign(value);
}
inline void TxOutput::set_address(const char* value) {
  set_has_address();
  if (address_ == &::google::protobuf::internal::kEmptyString) {
    address_ = new ::std::string;
  }
  address_->assign(value);
}
inline void TxOutput::set_address(const void* value, size_t size) {
  set_has_address();
  if (address_ == &::google::protobuf::internal::kEmptyString) {
    address_ = new ::std::string;
  }
  address_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TxOutput::mutable_address() {
  set_has_address();
  if (address_ == &::google::protobuf::internal::kEmptyString) {
    address_ = new ::std::string;
  }
  return address_;
}
inline ::std::string* TxOutput::release_address() {
  clear_has_address();
  if (address_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = address_;
    address_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TxOutput::set_allocated_address(::std::string* address) {
  if (address_ != &::google::protobuf::internal::kEmptyString) {
    delete address_;
  }
  if (address) {
    set_has_address();
    address_ = address;
  } else {
    clear_has_address();
    address_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated uint32 address_n = 3;
inline int TxOutput::address_n_size() const {
  return address_n_.size();
}
inline void TxOutput::clear_address_n() {
  address_n_.Clear();
}
inline ::google::protobuf::uint32 TxOutput::address_n(int index) const {
  return address_n_.Get(index);
}
inline void TxOutput::set_address_n(int index, ::google::protobuf::uint32 value) {
  address_n_.Set(index, value);
}
inline void TxOutput::add_address_n(::google::protobuf::uint32 value) {
  address_n_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
TxOutput::address_n() const {
  return address_n_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
TxOutput::mutable_address_n() {
  return &address_n_;
}

// required uint64 amount = 4;
inline bool TxOutput::has_amount() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TxOutput::set_has_amount() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TxOutput::clear_has_amount() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TxOutput::clear_amount() {
  amount_ = GOOGLE_ULONGLONG(0);
  clear_has_amount();
}
inline ::google::protobuf::uint64 TxOutput::amount() const {
  return amount_;
}
inline void TxOutput::set_amount(::google::protobuf::uint64 value) {
  set_has_amount();
  amount_ = value;
}

// required .ScriptType script_type = 5;
inline bool TxOutput::has_script_type() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TxOutput::set_has_script_type() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TxOutput::clear_has_script_type() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TxOutput::clear_script_type() {
  script_type_ = 0;
  clear_has_script_type();
}
inline ::ScriptType TxOutput::script_type() const {
  return static_cast< ::ScriptType >(script_type_);
}
inline void TxOutput::set_script_type(::ScriptType value) {
  assert(::ScriptType_IsValid(value));
  set_has_script_type();
  script_type_ = value;
}

// repeated bytes script_args = 6;
inline int TxOutput::script_args_size() const {
  return script_args_.size();
}
inline void TxOutput::clear_script_args() {
  script_args_.Clear();
}
inline const ::std::string& TxOutput::script_args(int index) const {
  return script_args_.Get(index);
}
inline ::std::string* TxOutput::mutable_script_args(int index) {
  return script_args_.Mutable(index);
}
inline void TxOutput::set_script_args(int index, const ::std::string& value) {
  script_args_.Mutable(index)->assign(value);
}
inline void TxOutput::set_script_args(int index, const char* value) {
  script_args_.Mutable(index)->assign(value);
}
inline void TxOutput::set_script_args(int index, const void* value, size_t size) {
  script_args_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TxOutput::add_script_args() {
  return script_args_.Add();
}
inline void TxOutput::add_script_args(const ::std::string& value) {
  script_args_.Add()->assign(value);
}
inline void TxOutput::add_script_args(const char* value) {
  script_args_.Add()->assign(value);
}
inline void TxOutput::add_script_args(const void* value, size_t size) {
  script_args_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
TxOutput::script_args() const {
  return script_args_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
TxOutput::mutable_script_args() {
  return &script_args_;
}


// @@protoc_insertion_point(namespace_scope)

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ScriptType>() {
  return ::ScriptType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::RequestType>() {
  return ::RequestType_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_trezor_2eproto__INCLUDED
