// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: trezor.proto

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
#include "trezor.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)

namespace {

const ::google::protobuf::Descriptor* XprvType_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  XprvType_reflection_ = NULL;
const ::google::protobuf::Descriptor* XpubType_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  XpubType_reflection_ = NULL;
const ::google::protobuf::Descriptor* CoinType_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  CoinType_reflection_ = NULL;
const ::google::protobuf::Descriptor* SettingsType_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  SettingsType_reflection_ = NULL;
const ::google::protobuf::Descriptor* Initialize_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Initialize_reflection_ = NULL;
const ::google::protobuf::Descriptor* Features_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Features_reflection_ = NULL;
const ::google::protobuf::Descriptor* ApplySettings_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ApplySettings_reflection_ = NULL;
const ::google::protobuf::Descriptor* ChangePin_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ChangePin_reflection_ = NULL;
const ::google::protobuf::Descriptor* Ping_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Ping_reflection_ = NULL;
const ::google::protobuf::Descriptor* Success_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Success_reflection_ = NULL;
const ::google::protobuf::Descriptor* Failure_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Failure_reflection_ = NULL;
const ::google::protobuf::Descriptor* ButtonRequest_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ButtonRequest_reflection_ = NULL;
const ::google::protobuf::Descriptor* ButtonAck_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ButtonAck_reflection_ = NULL;
const ::google::protobuf::Descriptor* ButtonCancel_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ButtonCancel_reflection_ = NULL;
const ::google::protobuf::Descriptor* PinMatrixRequest_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  PinMatrixRequest_reflection_ = NULL;
const ::google::protobuf::Descriptor* PinMatrixAck_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  PinMatrixAck_reflection_ = NULL;
const ::google::protobuf::Descriptor* PinMatrixCancel_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  PinMatrixCancel_reflection_ = NULL;
const ::google::protobuf::Descriptor* GetEntropy_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  GetEntropy_reflection_ = NULL;
const ::google::protobuf::Descriptor* Entropy_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Entropy_reflection_ = NULL;
const ::google::protobuf::Descriptor* GetMasterPublicKey_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  GetMasterPublicKey_reflection_ = NULL;
const ::google::protobuf::Descriptor* MasterPublicKey_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  MasterPublicKey_reflection_ = NULL;
const ::google::protobuf::Descriptor* GetAddress_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  GetAddress_reflection_ = NULL;
const ::google::protobuf::Descriptor* Address_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Address_reflection_ = NULL;
const ::google::protobuf::Descriptor* WipeDevice_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  WipeDevice_reflection_ = NULL;
const ::google::protobuf::Descriptor* LoadDevice_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  LoadDevice_reflection_ = NULL;
const ::google::protobuf::Descriptor* ResetDevice_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ResetDevice_reflection_ = NULL;
const ::google::protobuf::Descriptor* EntropyRequest_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  EntropyRequest_reflection_ = NULL;
const ::google::protobuf::Descriptor* EntropyAck_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  EntropyAck_reflection_ = NULL;
const ::google::protobuf::Descriptor* SignTx_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  SignTx_reflection_ = NULL;
const ::google::protobuf::Descriptor* SimpleSignTx_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  SimpleSignTx_reflection_ = NULL;
const ::google::protobuf::Descriptor* TxRequest_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  TxRequest_reflection_ = NULL;
const ::google::protobuf::Descriptor* TxInput_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  TxInput_reflection_ = NULL;
const ::google::protobuf::Descriptor* TxOutput_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  TxOutput_reflection_ = NULL;
const ::google::protobuf::Descriptor* DebugLinkDecision_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  DebugLinkDecision_reflection_ = NULL;
const ::google::protobuf::Descriptor* DebugLinkGetState_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  DebugLinkGetState_reflection_ = NULL;
const ::google::protobuf::Descriptor* DebugLinkState_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  DebugLinkState_reflection_ = NULL;
const ::google::protobuf::Descriptor* DebugLinkStop_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  DebugLinkStop_reflection_ = NULL;
const ::google::protobuf::EnumDescriptor* MessageType_descriptor_ = NULL;
const ::google::protobuf::EnumDescriptor* ScriptType_descriptor_ = NULL;
const ::google::protobuf::EnumDescriptor* RequestType_descriptor_ = NULL;

}  // namespace


void protobuf_AssignDesc_trezor_2eproto() {
  protobuf_AddDesc_trezor_2eproto();
  const ::google::protobuf::FileDescriptor* file =
    ::google::protobuf::DescriptorPool::generated_pool()->FindFileByName(
      "trezor.proto");
  GOOGLE_CHECK(file != NULL);
  XprvType_descriptor_ = file->message_type(0);
  static const int XprvType_offsets_[6] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(XprvType, version_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(XprvType, depth_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(XprvType, fingerprint_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(XprvType, child_num_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(XprvType, chain_code_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(XprvType, private_key_),
  };
  XprvType_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      XprvType_descriptor_,
      XprvType::default_instance_,
      XprvType_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(XprvType, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(XprvType, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(XprvType));
  XpubType_descriptor_ = file->message_type(1);
  static const int XpubType_offsets_[6] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(XpubType, version_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(XpubType, depth_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(XpubType, fingerprint_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(XpubType, child_num_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(XpubType, chain_code_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(XpubType, public_key_),
  };
  XpubType_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      XpubType_descriptor_,
      XpubType::default_instance_,
      XpubType_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(XpubType, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(XpubType, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(XpubType));
  CoinType_descriptor_ = file->message_type(2);
  static const int CoinType_offsets_[4] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CoinType, coin_name_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CoinType, coin_shortcut_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CoinType, address_type_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CoinType, maxfee_kb_),
  };
  CoinType_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      CoinType_descriptor_,
      CoinType::default_instance_,
      CoinType_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CoinType, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CoinType, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(CoinType));
  SettingsType_descriptor_ = file->message_type(3);
  static const int SettingsType_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SettingsType, language_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SettingsType, coin_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SettingsType, label_),
  };
  SettingsType_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      SettingsType_descriptor_,
      SettingsType::default_instance_,
      SettingsType_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SettingsType, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SettingsType, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(SettingsType));
  Initialize_descriptor_ = file->message_type(4);
  static const int Initialize_offsets_[1] = {
  };
  Initialize_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Initialize_descriptor_,
      Initialize::default_instance_,
      Initialize_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Initialize, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Initialize, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Initialize));
  Features_descriptor_ = file->message_type(5);
  static const int Features_offsets_[7] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Features, vendor_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Features, major_version_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Features, minor_version_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Features, settings_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Features, device_id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Features, mpk_hash_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Features, pin_protection_),
  };
  Features_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Features_descriptor_,
      Features::default_instance_,
      Features_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Features, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Features, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Features));
  ApplySettings_descriptor_ = file->message_type(6);
  static const int ApplySettings_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ApplySettings, language_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ApplySettings, coin_shortcut_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ApplySettings, label_),
  };
  ApplySettings_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      ApplySettings_descriptor_,
      ApplySettings::default_instance_,
      ApplySettings_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ApplySettings, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ApplySettings, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(ApplySettings));
  ChangePin_descriptor_ = file->message_type(7);
  static const int ChangePin_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ChangePin, remove_),
  };
  ChangePin_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      ChangePin_descriptor_,
      ChangePin::default_instance_,
      ChangePin_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ChangePin, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ChangePin, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(ChangePin));
  Ping_descriptor_ = file->message_type(8);
  static const int Ping_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Ping, message_),
  };
  Ping_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Ping_descriptor_,
      Ping::default_instance_,
      Ping_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Ping, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Ping, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Ping));
  Success_descriptor_ = file->message_type(9);
  static const int Success_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Success, message_),
  };
  Success_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Success_descriptor_,
      Success::default_instance_,
      Success_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Success, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Success, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Success));
  Failure_descriptor_ = file->message_type(10);
  static const int Failure_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Failure, code_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Failure, message_),
  };
  Failure_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Failure_descriptor_,
      Failure::default_instance_,
      Failure_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Failure, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Failure, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Failure));
  ButtonRequest_descriptor_ = file->message_type(11);
  static const int ButtonRequest_offsets_[1] = {
  };
  ButtonRequest_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      ButtonRequest_descriptor_,
      ButtonRequest::default_instance_,
      ButtonRequest_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ButtonRequest, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ButtonRequest, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(ButtonRequest));
  ButtonAck_descriptor_ = file->message_type(12);
  static const int ButtonAck_offsets_[1] = {
  };
  ButtonAck_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      ButtonAck_descriptor_,
      ButtonAck::default_instance_,
      ButtonAck_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ButtonAck, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ButtonAck, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(ButtonAck));
  ButtonCancel_descriptor_ = file->message_type(13);
  static const int ButtonCancel_offsets_[1] = {
  };
  ButtonCancel_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      ButtonCancel_descriptor_,
      ButtonCancel::default_instance_,
      ButtonCancel_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ButtonCancel, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ButtonCancel, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(ButtonCancel));
  PinMatrixRequest_descriptor_ = file->message_type(14);
  static const int PinMatrixRequest_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PinMatrixRequest, message_),
  };
  PinMatrixRequest_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      PinMatrixRequest_descriptor_,
      PinMatrixRequest::default_instance_,
      PinMatrixRequest_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PinMatrixRequest, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PinMatrixRequest, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(PinMatrixRequest));
  PinMatrixAck_descriptor_ = file->message_type(15);
  static const int PinMatrixAck_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PinMatrixAck, pin_),
  };
  PinMatrixAck_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      PinMatrixAck_descriptor_,
      PinMatrixAck::default_instance_,
      PinMatrixAck_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PinMatrixAck, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PinMatrixAck, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(PinMatrixAck));
  PinMatrixCancel_descriptor_ = file->message_type(16);
  static const int PinMatrixCancel_offsets_[1] = {
  };
  PinMatrixCancel_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      PinMatrixCancel_descriptor_,
      PinMatrixCancel::default_instance_,
      PinMatrixCancel_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PinMatrixCancel, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PinMatrixCancel, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(PinMatrixCancel));
  GetEntropy_descriptor_ = file->message_type(17);
  static const int GetEntropy_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GetEntropy, size_),
  };
  GetEntropy_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      GetEntropy_descriptor_,
      GetEntropy::default_instance_,
      GetEntropy_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GetEntropy, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GetEntropy, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(GetEntropy));
  Entropy_descriptor_ = file->message_type(18);
  static const int Entropy_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Entropy, entropy_),
  };
  Entropy_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Entropy_descriptor_,
      Entropy::default_instance_,
      Entropy_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Entropy, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Entropy, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Entropy));
  GetMasterPublicKey_descriptor_ = file->message_type(19);
  static const int GetMasterPublicKey_offsets_[1] = {
  };
  GetMasterPublicKey_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      GetMasterPublicKey_descriptor_,
      GetMasterPublicKey::default_instance_,
      GetMasterPublicKey_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GetMasterPublicKey, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GetMasterPublicKey, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(GetMasterPublicKey));
  MasterPublicKey_descriptor_ = file->message_type(20);
  static const int MasterPublicKey_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MasterPublicKey, mpk_),
  };
  MasterPublicKey_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      MasterPublicKey_descriptor_,
      MasterPublicKey::default_instance_,
      MasterPublicKey_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MasterPublicKey, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MasterPublicKey, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(MasterPublicKey));
  GetAddress_descriptor_ = file->message_type(21);
  static const int GetAddress_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GetAddress, address_n_),
  };
  GetAddress_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      GetAddress_descriptor_,
      GetAddress::default_instance_,
      GetAddress_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GetAddress, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GetAddress, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(GetAddress));
  Address_descriptor_ = file->message_type(22);
  static const int Address_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Address, address_),
  };
  Address_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Address_descriptor_,
      Address::default_instance_,
      Address_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Address, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Address, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Address));
  WipeDevice_descriptor_ = file->message_type(23);
  static const int WipeDevice_offsets_[1] = {
  };
  WipeDevice_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      WipeDevice_descriptor_,
      WipeDevice::default_instance_,
      WipeDevice_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(WipeDevice, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(WipeDevice, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(WipeDevice));
  LoadDevice_descriptor_ = file->message_type(24);
  static const int LoadDevice_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LoadDevice, seed_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LoadDevice, xprv_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LoadDevice, pin_),
  };
  LoadDevice_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      LoadDevice_descriptor_,
      LoadDevice::default_instance_,
      LoadDevice_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LoadDevice, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LoadDevice, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(LoadDevice));
  ResetDevice_descriptor_ = file->message_type(25);
  static const int ResetDevice_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ResetDevice, display_random_),
  };
  ResetDevice_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      ResetDevice_descriptor_,
      ResetDevice::default_instance_,
      ResetDevice_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ResetDevice, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ResetDevice, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(ResetDevice));
  EntropyRequest_descriptor_ = file->message_type(26);
  static const int EntropyRequest_offsets_[1] = {
  };
  EntropyRequest_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      EntropyRequest_descriptor_,
      EntropyRequest::default_instance_,
      EntropyRequest_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EntropyRequest, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EntropyRequest, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(EntropyRequest));
  EntropyAck_descriptor_ = file->message_type(27);
  static const int EntropyAck_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EntropyAck, entropy_),
  };
  EntropyAck_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      EntropyAck_descriptor_,
      EntropyAck::default_instance_,
      EntropyAck_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EntropyAck, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EntropyAck, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(EntropyAck));
  SignTx_descriptor_ = file->message_type(28);
  static const int SignTx_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SignTx, outputs_count_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SignTx, inputs_count_),
  };
  SignTx_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      SignTx_descriptor_,
      SignTx::default_instance_,
      SignTx_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SignTx, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SignTx, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(SignTx));
  SimpleSignTx_descriptor_ = file->message_type(29);
  static const int SimpleSignTx_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SimpleSignTx, inputs_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SimpleSignTx, outputs_),
  };
  SimpleSignTx_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      SimpleSignTx_descriptor_,
      SimpleSignTx::default_instance_,
      SimpleSignTx_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SimpleSignTx, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SimpleSignTx, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(SimpleSignTx));
  TxRequest_descriptor_ = file->message_type(30);
  static const int TxRequest_offsets_[5] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TxRequest, request_index_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TxRequest, request_type_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TxRequest, signed_index_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TxRequest, signature_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TxRequest, serialized_tx_),
  };
  TxRequest_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      TxRequest_descriptor_,
      TxRequest::default_instance_,
      TxRequest_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TxRequest, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TxRequest, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(TxRequest));
  TxInput_descriptor_ = file->message_type(31);
  static const int TxInput_offsets_[6] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TxInput, index_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TxInput, address_n_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TxInput, amount_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TxInput, prev_hash_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TxInput, prev_index_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TxInput, script_sig_),
  };
  TxInput_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      TxInput_descriptor_,
      TxInput::default_instance_,
      TxInput_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TxInput, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TxInput, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(TxInput));
  TxOutput_descriptor_ = file->message_type(32);
  static const int TxOutput_offsets_[6] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TxOutput, index_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TxOutput, address_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TxOutput, address_n_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TxOutput, amount_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TxOutput, script_type_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TxOutput, script_args_),
  };
  TxOutput_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      TxOutput_descriptor_,
      TxOutput::default_instance_,
      TxOutput_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TxOutput, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TxOutput, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(TxOutput));
  DebugLinkDecision_descriptor_ = file->message_type(33);
  static const int DebugLinkDecision_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DebugLinkDecision, yes_no_),
  };
  DebugLinkDecision_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      DebugLinkDecision_descriptor_,
      DebugLinkDecision::default_instance_,
      DebugLinkDecision_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DebugLinkDecision, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DebugLinkDecision, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(DebugLinkDecision));
  DebugLinkGetState_descriptor_ = file->message_type(34);
  static const int DebugLinkGetState_offsets_[4] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DebugLinkGetState, layout_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DebugLinkGetState, pin_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DebugLinkGetState, matrix_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DebugLinkGetState, seed_),
  };
  DebugLinkGetState_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      DebugLinkGetState_descriptor_,
      DebugLinkGetState::default_instance_,
      DebugLinkGetState_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DebugLinkGetState, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DebugLinkGetState, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(DebugLinkGetState));
  DebugLinkState_descriptor_ = file->message_type(35);
  static const int DebugLinkState_offsets_[4] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DebugLinkState, layout_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DebugLinkState, pin_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DebugLinkState, matrix_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DebugLinkState, seed_),
  };
  DebugLinkState_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      DebugLinkState_descriptor_,
      DebugLinkState::default_instance_,
      DebugLinkState_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DebugLinkState, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DebugLinkState, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(DebugLinkState));
  DebugLinkStop_descriptor_ = file->message_type(36);
  static const int DebugLinkStop_offsets_[1] = {
  };
  DebugLinkStop_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      DebugLinkStop_descriptor_,
      DebugLinkStop::default_instance_,
      DebugLinkStop_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DebugLinkStop, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DebugLinkStop, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(DebugLinkStop));
  MessageType_descriptor_ = file->enum_type(0);
  ScriptType_descriptor_ = file->enum_type(1);
  RequestType_descriptor_ = file->enum_type(2);
}

namespace {

GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_AssignDescriptors_once_);
inline void protobuf_AssignDescriptorsOnce() {
  ::google::protobuf::GoogleOnceInit(&protobuf_AssignDescriptors_once_,
                 &protobuf_AssignDesc_trezor_2eproto);
}

void protobuf_RegisterTypes(const ::std::string&) {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    XprvType_descriptor_, &XprvType::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    XpubType_descriptor_, &XpubType::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    CoinType_descriptor_, &CoinType::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    SettingsType_descriptor_, &SettingsType::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Initialize_descriptor_, &Initialize::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Features_descriptor_, &Features::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    ApplySettings_descriptor_, &ApplySettings::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    ChangePin_descriptor_, &ChangePin::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Ping_descriptor_, &Ping::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Success_descriptor_, &Success::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Failure_descriptor_, &Failure::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    ButtonRequest_descriptor_, &ButtonRequest::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    ButtonAck_descriptor_, &ButtonAck::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    ButtonCancel_descriptor_, &ButtonCancel::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    PinMatrixRequest_descriptor_, &PinMatrixRequest::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    PinMatrixAck_descriptor_, &PinMatrixAck::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    PinMatrixCancel_descriptor_, &PinMatrixCancel::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    GetEntropy_descriptor_, &GetEntropy::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Entropy_descriptor_, &Entropy::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    GetMasterPublicKey_descriptor_, &GetMasterPublicKey::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    MasterPublicKey_descriptor_, &MasterPublicKey::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    GetAddress_descriptor_, &GetAddress::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Address_descriptor_, &Address::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    WipeDevice_descriptor_, &WipeDevice::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    LoadDevice_descriptor_, &LoadDevice::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    ResetDevice_descriptor_, &ResetDevice::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    EntropyRequest_descriptor_, &EntropyRequest::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    EntropyAck_descriptor_, &EntropyAck::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    SignTx_descriptor_, &SignTx::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    SimpleSignTx_descriptor_, &SimpleSignTx::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    TxRequest_descriptor_, &TxRequest::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    TxInput_descriptor_, &TxInput::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    TxOutput_descriptor_, &TxOutput::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    DebugLinkDecision_descriptor_, &DebugLinkDecision::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    DebugLinkGetState_descriptor_, &DebugLinkGetState::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    DebugLinkState_descriptor_, &DebugLinkState::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    DebugLinkStop_descriptor_, &DebugLinkStop::default_instance());
}

}  // namespace

void protobuf_ShutdownFile_trezor_2eproto() {
  delete XprvType::default_instance_;
  delete XprvType_reflection_;
  delete XpubType::default_instance_;
  delete XpubType_reflection_;
  delete CoinType::default_instance_;
  delete CoinType_reflection_;
  delete SettingsType::default_instance_;
  delete SettingsType_reflection_;
  delete Initialize::default_instance_;
  delete Initialize_reflection_;
  delete Features::default_instance_;
  delete Features_reflection_;
  delete ApplySettings::default_instance_;
  delete ApplySettings_reflection_;
  delete ChangePin::default_instance_;
  delete ChangePin_reflection_;
  delete Ping::default_instance_;
  delete Ping_reflection_;
  delete Success::default_instance_;
  delete Success_reflection_;
  delete Failure::default_instance_;
  delete Failure_reflection_;
  delete ButtonRequest::default_instance_;
  delete ButtonRequest_reflection_;
  delete ButtonAck::default_instance_;
  delete ButtonAck_reflection_;
  delete ButtonCancel::default_instance_;
  delete ButtonCancel_reflection_;
  delete PinMatrixRequest::default_instance_;
  delete PinMatrixRequest_reflection_;
  delete PinMatrixAck::default_instance_;
  delete PinMatrixAck_reflection_;
  delete PinMatrixCancel::default_instance_;
  delete PinMatrixCancel_reflection_;
  delete GetEntropy::default_instance_;
  delete GetEntropy_reflection_;
  delete Entropy::default_instance_;
  delete Entropy_reflection_;
  delete GetMasterPublicKey::default_instance_;
  delete GetMasterPublicKey_reflection_;
  delete MasterPublicKey::default_instance_;
  delete MasterPublicKey_reflection_;
  delete GetAddress::default_instance_;
  delete GetAddress_reflection_;
  delete Address::default_instance_;
  delete Address_reflection_;
  delete WipeDevice::default_instance_;
  delete WipeDevice_reflection_;
  delete LoadDevice::default_instance_;
  delete LoadDevice_reflection_;
  delete ResetDevice::default_instance_;
  delete ResetDevice_reflection_;
  delete EntropyRequest::default_instance_;
  delete EntropyRequest_reflection_;
  delete EntropyAck::default_instance_;
  delete EntropyAck_reflection_;
  delete SignTx::default_instance_;
  delete SignTx_reflection_;
  delete SimpleSignTx::default_instance_;
  delete SimpleSignTx_reflection_;
  delete TxRequest::default_instance_;
  delete TxRequest_reflection_;
  delete TxInput::default_instance_;
  delete TxInput_reflection_;
  delete TxOutput::default_instance_;
  delete TxOutput_reflection_;
  delete DebugLinkDecision::default_instance_;
  delete DebugLinkDecision_reflection_;
  delete DebugLinkGetState::default_instance_;
  delete DebugLinkGetState_reflection_;
  delete DebugLinkState::default_instance_;
  delete DebugLinkState_reflection_;
  delete DebugLinkStop::default_instance_;
  delete DebugLinkStop_reflection_;
}

void protobuf_AddDesc_trezor_2eproto() {
  static bool already_here = false;
  if (already_here) return;
  already_here = true;
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  ::google::protobuf::protobuf_AddDesc_google_2fprotobuf_2fdescriptor_2eproto();
  ::google::protobuf::DescriptorPool::InternalAddGeneratedFile(
    "\n\014trezor.proto\032 google/protobuf/descript"
    "or.proto\"\207\001\n\010XprvType\022\017\n\007version\030\001 \002(\r\022\r"
    "\n\005depth\030\002 \002(\r\022\023\n\013fingerprint\030\003 \002(\r\022\021\n\tch"
    "ild_num\030\004 \002(\r\022\030\n\nchain_code\030\005 \002(\014B\004\210\265\030\001\022"
    "\031\n\013private_key\030\006 \002(\014B\004\210\265\030\001\"\206\001\n\010XpubType\022"
    "\017\n\007version\030\001 \002(\r\022\r\n\005depth\030\002 \002(\r\022\023\n\013finge"
    "rprint\030\003 \002(\r\022\021\n\tchild_num\030\004 \002(\r\022\030\n\nchain"
    "_code\030\005 \002(\014B\004\210\265\030\001\022\030\n\npublic_key\030\006 \002(\014B\004\210"
    "\265\030\001\"]\n\010CoinType\022\021\n\tcoin_name\030\001 \001(\014\022\025\n\rco"
    "in_shortcut\030\002 \001(\014\022\024\n\014address_type\030\003 \001(\r\022"
    "\021\n\tmaxfee_kb\030\004 \001(\004\"H\n\014SettingsType\022\020\n\010la"
    "nguage\030\001 \001(\014\022\027\n\004coin\030\002 \001(\0132\t.CoinType\022\r\n"
    "\005label\030\003 \001(\014\"\014\n\nInitialize\"\262\001\n\010Features\022"
    "\016\n\006vendor\030\001 \001(\014\022\025\n\rmajor_version\030\002 \001(\r\022\025"
    "\n\rminor_version\030\003 \001(\r\022\037\n\010settings\030\004 \001(\0132"
    "\r.SettingsType\022\027\n\tdevice_id\030\005 \001(\014B\004\210\265\030\001\022"
    "\026\n\010mpk_hash\030\006 \001(\014B\004\210\265\030\001\022\026\n\016pin_protectio"
    "n\030\007 \001(\010\"G\n\rApplySettings\022\020\n\010language\030\001 \001"
    "(\014\022\025\n\rcoin_shortcut\030\002 \001(\014\022\r\n\005label\030\003 \001(\014"
    "\"\033\n\tChangePin\022\016\n\006remove\030\001 \001(\010\"\027\n\004Ping\022\017\n"
    "\007message\030\001 \001(\014\"\032\n\007Success\022\017\n\007message\030\001 \001"
    "(\014\"(\n\007Failure\022\014\n\004code\030\001 \001(\005\022\017\n\007message\030\002"
    " \001(\014\"\017\n\rButtonRequest\"\013\n\tButtonAck\"\016\n\014Bu"
    "ttonCancel\"#\n\020PinMatrixRequest\022\017\n\007messag"
    "e\030\001 \001(\014\"\033\n\014PinMatrixAck\022\013\n\003pin\030\001 \002(\014\"\021\n\017"
    "PinMatrixCancel\"\032\n\nGetEntropy\022\014\n\004size\030\001 "
    "\002(\r\" \n\007Entropy\022\025\n\007entropy\030\001 \002(\014B\004\210\265\030\001\"\024\n"
    "\022GetMasterPublicKey\")\n\017MasterPublicKey\022\026"
    "\n\003mpk\030\001 \002(\0132\t.XpubType\"\037\n\nGetAddress\022\021\n\t"
    "address_n\030\001 \003(\r\"\032\n\007Address\022\017\n\007address\030\001 "
    "\002(\014\"\014\n\nWipeDevice\"@\n\nLoadDevice\022\014\n\004seed\030"
    "\001 \001(\014\022\027\n\004xprv\030\002 \001(\0132\t.XprvType\022\013\n\003pin\030\003 "
    "\001(\014\"%\n\013ResetDevice\022\026\n\016display_random\030\001 \001"
    "(\010\"\020\n\016EntropyRequest\"#\n\nEntropyAck\022\025\n\007en"
    "tropy\030\001 \001(\014B\004\210\265\030\001\"5\n\006SignTx\022\025\n\routputs_c"
    "ount\030\003 \002(\r\022\024\n\014inputs_count\030\005 \002(\r\"D\n\014Simp"
    "leSignTx\022\030\n\006inputs\030\001 \003(\0132\010.TxInput\022\032\n\007ou"
    "tputs\030\002 \003(\0132\t.TxOutput\"\222\001\n\tTxRequest\022\025\n\r"
    "request_index\030\001 \001(\005\022\"\n\014request_type\030\002 \001("
    "\0162\014.RequestType\022\024\n\014signed_index\030\003 \001(\005\022\027\n"
    "\tsignature\030\004 \001(\014B\004\210\265\030\001\022\033\n\rserialized_tx\030"
    "\005 \001(\014B\004\210\265\030\001\"\202\001\n\007TxInput\022\r\n\005index\030\001 \002(\r\022\021"
    "\n\taddress_n\030\002 \003(\r\022\016\n\006amount\030\003 \002(\004\022\027\n\tpre"
    "v_hash\030\004 \002(\014B\004\210\265\030\001\022\022\n\nprev_index\030\005 \002(\r\022\030"
    "\n\nscript_sig\030\006 \001(\014B\004\210\265\030\001\"\212\001\n\010TxOutput\022\r\n"
    "\005index\030\001 \002(\r\022\017\n\007address\030\002 \002(\014\022\021\n\taddress"
    "_n\030\003 \003(\r\022\016\n\006amount\030\004 \002(\004\022 \n\013script_type\030"
    "\005 \002(\0162\013.ScriptType\022\031\n\013script_args\030\006 \003(\014B"
    "\004\210\265\030\001\"#\n\021DebugLinkDecision\022\016\n\006yes_no\030\001 \002"
    "(\010\"N\n\021DebugLinkGetState\022\016\n\006layout\030\001 \001(\010\022"
    "\013\n\003pin\030\002 \001(\010\022\016\n\006matrix\030\003 \001(\010\022\014\n\004seed\030\004 \001"
    "(\010\"Q\n\016DebugLinkState\022\024\n\006layout\030\001 \001(\014B\004\210\265"
    "\030\001\022\013\n\003pin\030\002 \001(\014\022\016\n\006matrix\030\003 \001(\014\022\014\n\004seed\030"
    "\004 \001(\014\"\017\n\rDebugLinkStop*\263\010\n\013MessageType\022\032"
    "\n\026MessageType_Initialize\020\000\022\024\n\020MessageTyp"
    "e_Ping\020\001\022\027\n\023MessageType_Success\020\002\022\027\n\023Mes"
    "sageType_Failure\020\003\022\031\n\025MessageType_Change"
    "Pin\020\004\022\032\n\026MessageType_WipeDevice\020\005\022\032\n\026Mes"
    "sageType_GetEntropy\020\t\022\027\n\023MessageType_Ent"
    "ropy\020\n\022\"\n\036MessageType_GetMasterPublicKey"
    "\020\013\022\037\n\033MessageType_MasterPublicKey\020\014\022\032\n\026M"
    "essageType_LoadDevice\020\r\022\033\n\027MessageType_R"
    "esetDevice\020\016\022\026\n\022MessageType_SignTx\020\017\022\034\n\030"
    "MessageType_SimpleSignTx\020\020\022\030\n\024MessageTyp"
    "e_Features\020\021\022 \n\034MessageType_PinMatrixReq"
    "uest\020\022\022\034\n\030MessageType_PinMatrixAck\020\023\022\037\n\033"
    "MessageType_PinMatrixCancel\020\024\022\031\n\025Message"
    "Type_TxRequest\020\025\022\027\n\023MessageType_TxInput\020"
    "\027\022\030\n\024MessageType_TxOutput\020\030\022\035\n\031MessageTy"
    "pe_ApplySettings\020\031\022\035\n\031MessageType_Button"
    "Request\020\032\022\031\n\025MessageType_ButtonAck\020\033\022\034\n\030"
    "MessageType_ButtonCancel\020\034\022\032\n\026MessageTyp"
    "e_GetAddress\020\035\022\027\n\023MessageType_Address\020\036\022"
    "\034\n\030MessageType_SettingsType\020\037\022\030\n\024Message"
    "Type_XprvType\020 \022\030\n\024MessageType_CoinType\020"
    "!\022\030\n\024MessageType_XpubType\020\"\022\036\n\032MessageTy"
    "pe_EntropyRequest\020#\022\032\n\026MessageType_Entro"
    "pyAck\020$\022!\n\035MessageType_DebugLinkDecision"
    "\020d\022!\n\035MessageType_DebugLinkGetState\020e\022\036\n"
    "\032MessageType_DebugLinkState\020f\022\035\n\031Message"
    "Type_DebugLinkStop\020g*3\n\nScriptType\022\020\n\014PA"
    "YTOADDRESS\020\000\022\023\n\017PAYTOSCRIPTHASH\020\001*(\n\013Req"
    "uestType\022\013\n\007TXINPUT\020\000\022\014\n\010TXOUTPUT\020\001:/\n\006b"
    "inary\022\035.google.protobuf.FieldOptions\030\321\206\003"
    " \001(\010", 3364);
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedFile(
    "trezor.proto", &protobuf_RegisterTypes);
  XprvType::default_instance_ = new XprvType();
  XpubType::default_instance_ = new XpubType();
  CoinType::default_instance_ = new CoinType();
  SettingsType::default_instance_ = new SettingsType();
  Initialize::default_instance_ = new Initialize();
  Features::default_instance_ = new Features();
  ApplySettings::default_instance_ = new ApplySettings();
  ChangePin::default_instance_ = new ChangePin();
  Ping::default_instance_ = new Ping();
  Success::default_instance_ = new Success();
  Failure::default_instance_ = new Failure();
  ButtonRequest::default_instance_ = new ButtonRequest();
  ButtonAck::default_instance_ = new ButtonAck();
  ButtonCancel::default_instance_ = new ButtonCancel();
  PinMatrixRequest::default_instance_ = new PinMatrixRequest();
  PinMatrixAck::default_instance_ = new PinMatrixAck();
  PinMatrixCancel::default_instance_ = new PinMatrixCancel();
  GetEntropy::default_instance_ = new GetEntropy();
  Entropy::default_instance_ = new Entropy();
  GetMasterPublicKey::default_instance_ = new GetMasterPublicKey();
  MasterPublicKey::default_instance_ = new MasterPublicKey();
  GetAddress::default_instance_ = new GetAddress();
  Address::default_instance_ = new Address();
  WipeDevice::default_instance_ = new WipeDevice();
  LoadDevice::default_instance_ = new LoadDevice();
  ResetDevice::default_instance_ = new ResetDevice();
  EntropyRequest::default_instance_ = new EntropyRequest();
  EntropyAck::default_instance_ = new EntropyAck();
  SignTx::default_instance_ = new SignTx();
  SimpleSignTx::default_instance_ = new SimpleSignTx();
  TxRequest::default_instance_ = new TxRequest();
  TxInput::default_instance_ = new TxInput();
  TxOutput::default_instance_ = new TxOutput();
  DebugLinkDecision::default_instance_ = new DebugLinkDecision();
  DebugLinkGetState::default_instance_ = new DebugLinkGetState();
  DebugLinkState::default_instance_ = new DebugLinkState();
  DebugLinkStop::default_instance_ = new DebugLinkStop();
  ::google::protobuf::internal::ExtensionSet::RegisterExtension(
    &::google::protobuf::FieldOptions::default_instance(),
    50001, 8, false, false);
  XprvType::default_instance_->InitAsDefaultInstance();
  XpubType::default_instance_->InitAsDefaultInstance();
  CoinType::default_instance_->InitAsDefaultInstance();
  SettingsType::default_instance_->InitAsDefaultInstance();
  Initialize::default_instance_->InitAsDefaultInstance();
  Features::default_instance_->InitAsDefaultInstance();
  ApplySettings::default_instance_->InitAsDefaultInstance();
  ChangePin::default_instance_->InitAsDefaultInstance();
  Ping::default_instance_->InitAsDefaultInstance();
  Success::default_instance_->InitAsDefaultInstance();
  Failure::default_instance_->InitAsDefaultInstance();
  ButtonRequest::default_instance_->InitAsDefaultInstance();
  ButtonAck::default_instance_->InitAsDefaultInstance();
  ButtonCancel::default_instance_->InitAsDefaultInstance();
  PinMatrixRequest::default_instance_->InitAsDefaultInstance();
  PinMatrixAck::default_instance_->InitAsDefaultInstance();
  PinMatrixCancel::default_instance_->InitAsDefaultInstance();
  GetEntropy::default_instance_->InitAsDefaultInstance();
  Entropy::default_instance_->InitAsDefaultInstance();
  GetMasterPublicKey::default_instance_->InitAsDefaultInstance();
  MasterPublicKey::default_instance_->InitAsDefaultInstance();
  GetAddress::default_instance_->InitAsDefaultInstance();
  Address::default_instance_->InitAsDefaultInstance();
  WipeDevice::default_instance_->InitAsDefaultInstance();
  LoadDevice::default_instance_->InitAsDefaultInstance();
  ResetDevice::default_instance_->InitAsDefaultInstance();
  EntropyRequest::default_instance_->InitAsDefaultInstance();
  EntropyAck::default_instance_->InitAsDefaultInstance();
  SignTx::default_instance_->InitAsDefaultInstance();
  SimpleSignTx::default_instance_->InitAsDefaultInstance();
  TxRequest::default_instance_->InitAsDefaultInstance();
  TxInput::default_instance_->InitAsDefaultInstance();
  TxOutput::default_instance_->InitAsDefaultInstance();
  DebugLinkDecision::default_instance_->InitAsDefaultInstance();
  DebugLinkGetState::default_instance_->InitAsDefaultInstance();
  DebugLinkState::default_instance_->InitAsDefaultInstance();
  DebugLinkStop::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_trezor_2eproto);
}

// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer_trezor_2eproto {
  StaticDescriptorInitializer_trezor_2eproto() {
    protobuf_AddDesc_trezor_2eproto();
  }
} static_descriptor_initializer_trezor_2eproto_;
const ::google::protobuf::EnumDescriptor* MessageType_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return MessageType_descriptor_;
}
bool MessageType_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 9:
    case 10:
    case 11:
    case 12:
    case 13:
    case 14:
    case 15:
    case 16:
    case 17:
    case 18:
    case 19:
    case 20:
    case 21:
    case 23:
    case 24:
    case 25:
    case 26:
    case 27:
    case 28:
    case 29:
    case 30:
    case 31:
    case 32:
    case 33:
    case 34:
    case 35:
    case 36:
    case 100:
    case 101:
    case 102:
    case 103:
      return true;
    default:
      return false;
  }
}

const ::google::protobuf::EnumDescriptor* ScriptType_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ScriptType_descriptor_;
}
bool ScriptType_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
      return true;
    default:
      return false;
  }
}

const ::google::protobuf::EnumDescriptor* RequestType_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return RequestType_descriptor_;
}
bool RequestType_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
      return true;
    default:
      return false;
  }
}


// ===================================================================

#ifndef _MSC_VER
const int XprvType::kVersionFieldNumber;
const int XprvType::kDepthFieldNumber;
const int XprvType::kFingerprintFieldNumber;
const int XprvType::kChildNumFieldNumber;
const int XprvType::kChainCodeFieldNumber;
const int XprvType::kPrivateKeyFieldNumber;
#endif  // !_MSC_VER

XprvType::XprvType()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void XprvType::InitAsDefaultInstance() {
}

XprvType::XprvType(const XprvType& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void XprvType::SharedCtor() {
  _cached_size_ = 0;
  version_ = 0u;
  depth_ = 0u;
  fingerprint_ = 0u;
  child_num_ = 0u;
  chain_code_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  private_key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

XprvType::~XprvType() {
  SharedDtor();
}

void XprvType::SharedDtor() {
  if (chain_code_ != &::google::protobuf::internal::kEmptyString) {
    delete chain_code_;
  }
  if (private_key_ != &::google::protobuf::internal::kEmptyString) {
    delete private_key_;
  }
  if (this != default_instance_) {
  }
}

void XprvType::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* XprvType::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return XprvType_descriptor_;
}

const XprvType& XprvType::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_trezor_2eproto();
  return *default_instance_;
}

XprvType* XprvType::default_instance_ = NULL;

XprvType* XprvType::New() const {
  return new XprvType;
}

void XprvType::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    version_ = 0u;
    depth_ = 0u;
    fingerprint_ = 0u;
    child_num_ = 0u;
    if (has_chain_code()) {
      if (chain_code_ != &::google::protobuf::internal::kEmptyString) {
        chain_code_->clear();
      }
    }
    if (has_private_key()) {
      if (private_key_ != &::google::protobuf::internal::kEmptyString) {
        private_key_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool XprvType::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 version = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &version_)));
          set_has_version();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_depth;
        break;
      }

      // required uint32 depth = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_depth:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &depth_)));
          set_has_depth();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_fingerprint;
        break;
      }

      // required uint32 fingerprint = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_fingerprint:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &fingerprint_)));
          set_has_fingerprint();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_child_num;
        break;
      }

      // required uint32 child_num = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_child_num:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &child_num_)));
          set_has_child_num();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(42)) goto parse_chain_code;
        break;
      }

      // required bytes chain_code = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_chain_code:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_chain_code()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(50)) goto parse_private_key;
        break;
      }

      // required bytes private_key = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_private_key:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_private_key()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void XprvType::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint32 version = 1;
  if (has_version()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->version(), output);
  }

  // required uint32 depth = 2;
  if (has_depth()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->depth(), output);
  }

  // required uint32 fingerprint = 3;
  if (has_fingerprint()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->fingerprint(), output);
  }

  // required uint32 child_num = 4;
  if (has_child_num()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->child_num(), output);
  }

  // required bytes chain_code = 5;
  if (has_chain_code()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      5, this->chain_code(), output);
  }

  // required bytes private_key = 6;
  if (has_private_key()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      6, this->private_key(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* XprvType::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required uint32 version = 1;
  if (has_version()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->version(), target);
  }

  // required uint32 depth = 2;
  if (has_depth()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(2, this->depth(), target);
  }

  // required uint32 fingerprint = 3;
  if (has_fingerprint()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(3, this->fingerprint(), target);
  }

  // required uint32 child_num = 4;
  if (has_child_num()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(4, this->child_num(), target);
  }

  // required bytes chain_code = 5;
  if (has_chain_code()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        5, this->chain_code(), target);
  }

  // required bytes private_key = 6;
  if (has_private_key()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        6, this->private_key(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int XprvType::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 version = 1;
    if (has_version()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->version());
    }

    // required uint32 depth = 2;
    if (has_depth()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->depth());
    }

    // required uint32 fingerprint = 3;
    if (has_fingerprint()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->fingerprint());
    }

    // required uint32 child_num = 4;
    if (has_child_num()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->child_num());
    }

    // required bytes chain_code = 5;
    if (has_chain_code()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->chain_code());
    }

    // required bytes private_key = 6;
    if (has_private_key()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->private_key());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void XprvType::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const XprvType* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const XprvType*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void XprvType::MergeFrom(const XprvType& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_version()) {
      set_version(from.version());
    }
    if (from.has_depth()) {
      set_depth(from.depth());
    }
    if (from.has_fingerprint()) {
      set_fingerprint(from.fingerprint());
    }
    if (from.has_child_num()) {
      set_child_num(from.child_num());
    }
    if (from.has_chain_code()) {
      set_chain_code(from.chain_code());
    }
    if (from.has_private_key()) {
      set_private_key(from.private_key());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void XprvType::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void XprvType::CopyFrom(const XprvType& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool XprvType::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000003f) != 0x0000003f) return false;

  return true;
}

void XprvType::Swap(XprvType* other) {
  if (other != this) {
    std::swap(version_, other->version_);
    std::swap(depth_, other->depth_);
    std::swap(fingerprint_, other->fingerprint_);
    std::swap(child_num_, other->child_num_);
    std::swap(chain_code_, other->chain_code_);
    std::swap(private_key_, other->private_key_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata XprvType::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = XprvType_descriptor_;
  metadata.reflection = XprvType_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int XpubType::kVersionFieldNumber;
const int XpubType::kDepthFieldNumber;
const int XpubType::kFingerprintFieldNumber;
const int XpubType::kChildNumFieldNumber;
const int XpubType::kChainCodeFieldNumber;
const int XpubType::kPublicKeyFieldNumber;
#endif  // !_MSC_VER

XpubType::XpubType()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void XpubType::InitAsDefaultInstance() {
}

XpubType::XpubType(const XpubType& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void XpubType::SharedCtor() {
  _cached_size_ = 0;
  version_ = 0u;
  depth_ = 0u;
  fingerprint_ = 0u;
  child_num_ = 0u;
  chain_code_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  public_key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

XpubType::~XpubType() {
  SharedDtor();
}

void XpubType::SharedDtor() {
  if (chain_code_ != &::google::protobuf::internal::kEmptyString) {
    delete chain_code_;
  }
  if (public_key_ != &::google::protobuf::internal::kEmptyString) {
    delete public_key_;
  }
  if (this != default_instance_) {
  }
}

void XpubType::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* XpubType::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return XpubType_descriptor_;
}

const XpubType& XpubType::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_trezor_2eproto();
  return *default_instance_;
}

XpubType* XpubType::default_instance_ = NULL;

XpubType* XpubType::New() const {
  return new XpubType;
}

void XpubType::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    version_ = 0u;
    depth_ = 0u;
    fingerprint_ = 0u;
    child_num_ = 0u;
    if (has_chain_code()) {
      if (chain_code_ != &::google::protobuf::internal::kEmptyString) {
        chain_code_->clear();
      }
    }
    if (has_public_key()) {
      if (public_key_ != &::google::protobuf::internal::kEmptyString) {
        public_key_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool XpubType::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 version = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &version_)));
          set_has_version();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_depth;
        break;
      }

      // required uint32 depth = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_depth:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &depth_)));
          set_has_depth();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_fingerprint;
        break;
      }

      // required uint32 fingerprint = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_fingerprint:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &fingerprint_)));
          set_has_fingerprint();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_child_num;
        break;
      }

      // required uint32 child_num = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_child_num:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &child_num_)));
          set_has_child_num();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(42)) goto parse_chain_code;
        break;
      }

      // required bytes chain_code = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_chain_code:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_chain_code()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(50)) goto parse_public_key;
        break;
      }

      // required bytes public_key = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_public_key:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_public_key()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void XpubType::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint32 version = 1;
  if (has_version()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->version(), output);
  }

  // required uint32 depth = 2;
  if (has_depth()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->depth(), output);
  }

  // required uint32 fingerprint = 3;
  if (has_fingerprint()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->fingerprint(), output);
  }

  // required uint32 child_num = 4;
  if (has_child_num()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->child_num(), output);
  }

  // required bytes chain_code = 5;
  if (has_chain_code()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      5, this->chain_code(), output);
  }

  // required bytes public_key = 6;
  if (has_public_key()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      6, this->public_key(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* XpubType::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required uint32 version = 1;
  if (has_version()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->version(), target);
  }

  // required uint32 depth = 2;
  if (has_depth()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(2, this->depth(), target);
  }

  // required uint32 fingerprint = 3;
  if (has_fingerprint()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(3, this->fingerprint(), target);
  }

  // required uint32 child_num = 4;
  if (has_child_num()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(4, this->child_num(), target);
  }

  // required bytes chain_code = 5;
  if (has_chain_code()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        5, this->chain_code(), target);
  }

  // required bytes public_key = 6;
  if (has_public_key()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        6, this->public_key(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int XpubType::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 version = 1;
    if (has_version()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->version());
    }

    // required uint32 depth = 2;
    if (has_depth()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->depth());
    }

    // required uint32 fingerprint = 3;
    if (has_fingerprint()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->fingerprint());
    }

    // required uint32 child_num = 4;
    if (has_child_num()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->child_num());
    }

    // required bytes chain_code = 5;
    if (has_chain_code()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->chain_code());
    }

    // required bytes public_key = 6;
    if (has_public_key()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->public_key());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void XpubType::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const XpubType* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const XpubType*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void XpubType::MergeFrom(const XpubType& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_version()) {
      set_version(from.version());
    }
    if (from.has_depth()) {
      set_depth(from.depth());
    }
    if (from.has_fingerprint()) {
      set_fingerprint(from.fingerprint());
    }
    if (from.has_child_num()) {
      set_child_num(from.child_num());
    }
    if (from.has_chain_code()) {
      set_chain_code(from.chain_code());
    }
    if (from.has_public_key()) {
      set_public_key(from.public_key());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void XpubType::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void XpubType::CopyFrom(const XpubType& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool XpubType::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000003f) != 0x0000003f) return false;

  return true;
}

void XpubType::Swap(XpubType* other) {
  if (other != this) {
    std::swap(version_, other->version_);
    std::swap(depth_, other->depth_);
    std::swap(fingerprint_, other->fingerprint_);
    std::swap(child_num_, other->child_num_);
    std::swap(chain_code_, other->chain_code_);
    std::swap(public_key_, other->public_key_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata XpubType::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = XpubType_descriptor_;
  metadata.reflection = XpubType_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int CoinType::kCoinNameFieldNumber;
const int CoinType::kCoinShortcutFieldNumber;
const int CoinType::kAddressTypeFieldNumber;
const int CoinType::kMaxfeeKbFieldNumber;
#endif  // !_MSC_VER

CoinType::CoinType()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void CoinType::InitAsDefaultInstance() {
}

CoinType::CoinType(const CoinType& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void CoinType::SharedCtor() {
  _cached_size_ = 0;
  coin_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  coin_shortcut_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  address_type_ = 0u;
  maxfee_kb_ = GOOGLE_ULONGLONG(0);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CoinType::~CoinType() {
  SharedDtor();
}

void CoinType::SharedDtor() {
  if (coin_name_ != &::google::protobuf::internal::kEmptyString) {
    delete coin_name_;
  }
  if (coin_shortcut_ != &::google::protobuf::internal::kEmptyString) {
    delete coin_shortcut_;
  }
  if (this != default_instance_) {
  }
}

void CoinType::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* CoinType::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return CoinType_descriptor_;
}

const CoinType& CoinType::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_trezor_2eproto();
  return *default_instance_;
}

CoinType* CoinType::default_instance_ = NULL;

CoinType* CoinType::New() const {
  return new CoinType;
}

void CoinType::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_coin_name()) {
      if (coin_name_ != &::google::protobuf::internal::kEmptyString) {
        coin_name_->clear();
      }
    }
    if (has_coin_shortcut()) {
      if (coin_shortcut_ != &::google::protobuf::internal::kEmptyString) {
        coin_shortcut_->clear();
      }
    }
    address_type_ = 0u;
    maxfee_kb_ = GOOGLE_ULONGLONG(0);
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool CoinType::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional bytes coin_name = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_coin_name()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_coin_shortcut;
        break;
      }

      // optional bytes coin_shortcut = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_coin_shortcut:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_coin_shortcut()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_address_type;
        break;
      }

      // optional uint32 address_type = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_address_type:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &address_type_)));
          set_has_address_type();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_maxfee_kb;
        break;
      }

      // optional uint64 maxfee_kb = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_maxfee_kb:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &maxfee_kb_)));
          set_has_maxfee_kb();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void CoinType::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional bytes coin_name = 1;
  if (has_coin_name()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      1, this->coin_name(), output);
  }

  // optional bytes coin_shortcut = 2;
  if (has_coin_shortcut()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      2, this->coin_shortcut(), output);
  }

  // optional uint32 address_type = 3;
  if (has_address_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->address_type(), output);
  }

  // optional uint64 maxfee_kb = 4;
  if (has_maxfee_kb()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(4, this->maxfee_kb(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* CoinType::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional bytes coin_name = 1;
  if (has_coin_name()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        1, this->coin_name(), target);
  }

  // optional bytes coin_shortcut = 2;
  if (has_coin_shortcut()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        2, this->coin_shortcut(), target);
  }

  // optional uint32 address_type = 3;
  if (has_address_type()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(3, this->address_type(), target);
  }

  // optional uint64 maxfee_kb = 4;
  if (has_maxfee_kb()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(4, this->maxfee_kb(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int CoinType::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional bytes coin_name = 1;
    if (has_coin_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->coin_name());
    }

    // optional bytes coin_shortcut = 2;
    if (has_coin_shortcut()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->coin_shortcut());
    }

    // optional uint32 address_type = 3;
    if (has_address_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->address_type());
    }

    // optional uint64 maxfee_kb = 4;
    if (has_maxfee_kb()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->maxfee_kb());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CoinType::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const CoinType* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const CoinType*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void CoinType::MergeFrom(const CoinType& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_coin_name()) {
      set_coin_name(from.coin_name());
    }
    if (from.has_coin_shortcut()) {
      set_coin_shortcut(from.coin_shortcut());
    }
    if (from.has_address_type()) {
      set_address_type(from.address_type());
    }
    if (from.has_maxfee_kb()) {
      set_maxfee_kb(from.maxfee_kb());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void CoinType::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void CoinType::CopyFrom(const CoinType& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CoinType::IsInitialized() const {

  return true;
}

void CoinType::Swap(CoinType* other) {
  if (other != this) {
    std::swap(coin_name_, other->coin_name_);
    std::swap(coin_shortcut_, other->coin_shortcut_);
    std::swap(address_type_, other->address_type_);
    std::swap(maxfee_kb_, other->maxfee_kb_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata CoinType::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = CoinType_descriptor_;
  metadata.reflection = CoinType_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int SettingsType::kLanguageFieldNumber;
const int SettingsType::kCoinFieldNumber;
const int SettingsType::kLabelFieldNumber;
#endif  // !_MSC_VER

SettingsType::SettingsType()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void SettingsType::InitAsDefaultInstance() {
  coin_ = const_cast< ::CoinType*>(&::CoinType::default_instance());
}

SettingsType::SettingsType(const SettingsType& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void SettingsType::SharedCtor() {
  _cached_size_ = 0;
  language_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  coin_ = NULL;
  label_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

SettingsType::~SettingsType() {
  SharedDtor();
}

void SettingsType::SharedDtor() {
  if (language_ != &::google::protobuf::internal::kEmptyString) {
    delete language_;
  }
  if (label_ != &::google::protobuf::internal::kEmptyString) {
    delete label_;
  }
  if (this != default_instance_) {
    delete coin_;
  }
}

void SettingsType::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* SettingsType::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return SettingsType_descriptor_;
}

const SettingsType& SettingsType::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_trezor_2eproto();
  return *default_instance_;
}

SettingsType* SettingsType::default_instance_ = NULL;

SettingsType* SettingsType::New() const {
  return new SettingsType;
}

void SettingsType::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_language()) {
      if (language_ != &::google::protobuf::internal::kEmptyString) {
        language_->clear();
      }
    }
    if (has_coin()) {
      if (coin_ != NULL) coin_->::CoinType::Clear();
    }
    if (has_label()) {
      if (label_ != &::google::protobuf::internal::kEmptyString) {
        label_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool SettingsType::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional bytes language = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_language()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_coin;
        break;
      }

      // optional .CoinType coin = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_coin:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_coin()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_label;
        break;
      }

      // optional bytes label = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_label:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_label()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void SettingsType::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional bytes language = 1;
  if (has_language()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      1, this->language(), output);
  }

  // optional .CoinType coin = 2;
  if (has_coin()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->coin(), output);
  }

  // optional bytes label = 3;
  if (has_label()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      3, this->label(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* SettingsType::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional bytes language = 1;
  if (has_language()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        1, this->language(), target);
  }

  // optional .CoinType coin = 2;
  if (has_coin()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->coin(), target);
  }

  // optional bytes label = 3;
  if (has_label()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        3, this->label(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int SettingsType::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional bytes language = 1;
    if (has_language()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->language());
    }

    // optional .CoinType coin = 2;
    if (has_coin()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->coin());
    }

    // optional bytes label = 3;
    if (has_label()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->label());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void SettingsType::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const SettingsType* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const SettingsType*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void SettingsType::MergeFrom(const SettingsType& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_language()) {
      set_language(from.language());
    }
    if (from.has_coin()) {
      mutable_coin()->::CoinType::MergeFrom(from.coin());
    }
    if (from.has_label()) {
      set_label(from.label());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void SettingsType::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void SettingsType::CopyFrom(const SettingsType& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SettingsType::IsInitialized() const {

  return true;
}

void SettingsType::Swap(SettingsType* other) {
  if (other != this) {
    std::swap(language_, other->language_);
    std::swap(coin_, other->coin_);
    std::swap(label_, other->label_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata SettingsType::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = SettingsType_descriptor_;
  metadata.reflection = SettingsType_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
#endif  // !_MSC_VER

Initialize::Initialize()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void Initialize::InitAsDefaultInstance() {
}

Initialize::Initialize(const Initialize& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void Initialize::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Initialize::~Initialize() {
  SharedDtor();
}

void Initialize::SharedDtor() {
  if (this != default_instance_) {
  }
}

void Initialize::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Initialize::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Initialize_descriptor_;
}

const Initialize& Initialize::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_trezor_2eproto();
  return *default_instance_;
}

Initialize* Initialize::default_instance_ = NULL;

Initialize* Initialize::New() const {
  return new Initialize;
}

void Initialize::Clear() {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Initialize::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      return true;
    }
    DO_(::google::protobuf::internal::WireFormat::SkipField(
          input, tag, mutable_unknown_fields()));
  }
  return true;
#undef DO_
}

void Initialize::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* Initialize::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int Initialize::ByteSize() const {
  int total_size = 0;

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Initialize::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Initialize* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Initialize*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Initialize::MergeFrom(const Initialize& from) {
  GOOGLE_CHECK_NE(&from, this);
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Initialize::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Initialize::CopyFrom(const Initialize& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Initialize::IsInitialized() const {

  return true;
}

void Initialize::Swap(Initialize* other) {
  if (other != this) {
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Initialize::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Initialize_descriptor_;
  metadata.reflection = Initialize_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int Features::kVendorFieldNumber;
const int Features::kMajorVersionFieldNumber;
const int Features::kMinorVersionFieldNumber;
const int Features::kSettingsFieldNumber;
const int Features::kDeviceIdFieldNumber;
const int Features::kMpkHashFieldNumber;
const int Features::kPinProtectionFieldNumber;
#endif  // !_MSC_VER

Features::Features()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void Features::InitAsDefaultInstance() {
  settings_ = const_cast< ::SettingsType*>(&::SettingsType::default_instance());
}

Features::Features(const Features& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void Features::SharedCtor() {
  _cached_size_ = 0;
  vendor_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  major_version_ = 0u;
  minor_version_ = 0u;
  settings_ = NULL;
  device_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  mpk_hash_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  pin_protection_ = false;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Features::~Features() {
  SharedDtor();
}

void Features::SharedDtor() {
  if (vendor_ != &::google::protobuf::internal::kEmptyString) {
    delete vendor_;
  }
  if (device_id_ != &::google::protobuf::internal::kEmptyString) {
    delete device_id_;
  }
  if (mpk_hash_ != &::google::protobuf::internal::kEmptyString) {
    delete mpk_hash_;
  }
  if (this != default_instance_) {
    delete settings_;
  }
}

void Features::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Features::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Features_descriptor_;
}

const Features& Features::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_trezor_2eproto();
  return *default_instance_;
}

Features* Features::default_instance_ = NULL;

Features* Features::New() const {
  return new Features;
}

void Features::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_vendor()) {
      if (vendor_ != &::google::protobuf::internal::kEmptyString) {
        vendor_->clear();
      }
    }
    major_version_ = 0u;
    minor_version_ = 0u;
    if (has_settings()) {
      if (settings_ != NULL) settings_->::SettingsType::Clear();
    }
    if (has_device_id()) {
      if (device_id_ != &::google::protobuf::internal::kEmptyString) {
        device_id_->clear();
      }
    }
    if (has_mpk_hash()) {
      if (mpk_hash_ != &::google::protobuf::internal::kEmptyString) {
        mpk_hash_->clear();
      }
    }
    pin_protection_ = false;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Features::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional bytes vendor = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_vendor()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_major_version;
        break;
      }

      // optional uint32 major_version = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_major_version:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &major_version_)));
          set_has_major_version();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_minor_version;
        break;
      }

      // optional uint32 minor_version = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_minor_version:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &minor_version_)));
          set_has_minor_version();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_settings;
        break;
      }

      // optional .SettingsType settings = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_settings:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_settings()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(42)) goto parse_device_id;
        break;
      }

      // optional bytes device_id = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_device_id:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_device_id()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(50)) goto parse_mpk_hash;
        break;
      }

      // optional bytes mpk_hash = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_mpk_hash:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_mpk_hash()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(56)) goto parse_pin_protection;
        break;
      }

      // optional bool pin_protection = 7;
      case 7: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_pin_protection:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &pin_protection_)));
          set_has_pin_protection();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Features::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional bytes vendor = 1;
  if (has_vendor()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      1, this->vendor(), output);
  }

  // optional uint32 major_version = 2;
  if (has_major_version()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->major_version(), output);
  }

  // optional uint32 minor_version = 3;
  if (has_minor_version()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->minor_version(), output);
  }

  // optional .SettingsType settings = 4;
  if (has_settings()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      4, this->settings(), output);
  }

  // optional bytes device_id = 5;
  if (has_device_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      5, this->device_id(), output);
  }

  // optional bytes mpk_hash = 6;
  if (has_mpk_hash()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      6, this->mpk_hash(), output);
  }

  // optional bool pin_protection = 7;
  if (has_pin_protection()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(7, this->pin_protection(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* Features::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional bytes vendor = 1;
  if (has_vendor()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        1, this->vendor(), target);
  }

  // optional uint32 major_version = 2;
  if (has_major_version()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(2, this->major_version(), target);
  }

  // optional uint32 minor_version = 3;
  if (has_minor_version()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(3, this->minor_version(), target);
  }

  // optional .SettingsType settings = 4;
  if (has_settings()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        4, this->settings(), target);
  }

  // optional bytes device_id = 5;
  if (has_device_id()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        5, this->device_id(), target);
  }

  // optional bytes mpk_hash = 6;
  if (has_mpk_hash()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        6, this->mpk_hash(), target);
  }

  // optional bool pin_protection = 7;
  if (has_pin_protection()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(7, this->pin_protection(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int Features::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional bytes vendor = 1;
    if (has_vendor()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->vendor());
    }

    // optional uint32 major_version = 2;
    if (has_major_version()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->major_version());
    }

    // optional uint32 minor_version = 3;
    if (has_minor_version()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->minor_version());
    }

    // optional .SettingsType settings = 4;
    if (has_settings()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->settings());
    }

    // optional bytes device_id = 5;
    if (has_device_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->device_id());
    }

    // optional bytes mpk_hash = 6;
    if (has_mpk_hash()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->mpk_hash());
    }

    // optional bool pin_protection = 7;
    if (has_pin_protection()) {
      total_size += 1 + 1;
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Features::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Features* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Features*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Features::MergeFrom(const Features& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_vendor()) {
      set_vendor(from.vendor());
    }
    if (from.has_major_version()) {
      set_major_version(from.major_version());
    }
    if (from.has_minor_version()) {
      set_minor_version(from.minor_version());
    }
    if (from.has_settings()) {
      mutable_settings()->::SettingsType::MergeFrom(from.settings());
    }
    if (from.has_device_id()) {
      set_device_id(from.device_id());
    }
    if (from.has_mpk_hash()) {
      set_mpk_hash(from.mpk_hash());
    }
    if (from.has_pin_protection()) {
      set_pin_protection(from.pin_protection());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Features::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Features::CopyFrom(const Features& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Features::IsInitialized() const {

  return true;
}

void Features::Swap(Features* other) {
  if (other != this) {
    std::swap(vendor_, other->vendor_);
    std::swap(major_version_, other->major_version_);
    std::swap(minor_version_, other->minor_version_);
    std::swap(settings_, other->settings_);
    std::swap(device_id_, other->device_id_);
    std::swap(mpk_hash_, other->mpk_hash_);
    std::swap(pin_protection_, other->pin_protection_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Features::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Features_descriptor_;
  metadata.reflection = Features_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int ApplySettings::kLanguageFieldNumber;
const int ApplySettings::kCoinShortcutFieldNumber;
const int ApplySettings::kLabelFieldNumber;
#endif  // !_MSC_VER

ApplySettings::ApplySettings()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void ApplySettings::InitAsDefaultInstance() {
}

ApplySettings::ApplySettings(const ApplySettings& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void ApplySettings::SharedCtor() {
  _cached_size_ = 0;
  language_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  coin_shortcut_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  label_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ApplySettings::~ApplySettings() {
  SharedDtor();
}

void ApplySettings::SharedDtor() {
  if (language_ != &::google::protobuf::internal::kEmptyString) {
    delete language_;
  }
  if (coin_shortcut_ != &::google::protobuf::internal::kEmptyString) {
    delete coin_shortcut_;
  }
  if (label_ != &::google::protobuf::internal::kEmptyString) {
    delete label_;
  }
  if (this != default_instance_) {
  }
}

void ApplySettings::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ApplySettings::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ApplySettings_descriptor_;
}

const ApplySettings& ApplySettings::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_trezor_2eproto();
  return *default_instance_;
}

ApplySettings* ApplySettings::default_instance_ = NULL;

ApplySettings* ApplySettings::New() const {
  return new ApplySettings;
}

void ApplySettings::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_language()) {
      if (language_ != &::google::protobuf::internal::kEmptyString) {
        language_->clear();
      }
    }
    if (has_coin_shortcut()) {
      if (coin_shortcut_ != &::google::protobuf::internal::kEmptyString) {
        coin_shortcut_->clear();
      }
    }
    if (has_label()) {
      if (label_ != &::google::protobuf::internal::kEmptyString) {
        label_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool ApplySettings::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional bytes language = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_language()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_coin_shortcut;
        break;
      }

      // optional bytes coin_shortcut = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_coin_shortcut:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_coin_shortcut()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_label;
        break;
      }

      // optional bytes label = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_label:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_label()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ApplySettings::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional bytes language = 1;
  if (has_language()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      1, this->language(), output);
  }

  // optional bytes coin_shortcut = 2;
  if (has_coin_shortcut()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      2, this->coin_shortcut(), output);
  }

  // optional bytes label = 3;
  if (has_label()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      3, this->label(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* ApplySettings::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional bytes language = 1;
  if (has_language()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        1, this->language(), target);
  }

  // optional bytes coin_shortcut = 2;
  if (has_coin_shortcut()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        2, this->coin_shortcut(), target);
  }

  // optional bytes label = 3;
  if (has_label()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        3, this->label(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int ApplySettings::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional bytes language = 1;
    if (has_language()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->language());
    }

    // optional bytes coin_shortcut = 2;
    if (has_coin_shortcut()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->coin_shortcut());
    }

    // optional bytes label = 3;
    if (has_label()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->label());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ApplySettings::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const ApplySettings* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const ApplySettings*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void ApplySettings::MergeFrom(const ApplySettings& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_language()) {
      set_language(from.language());
    }
    if (from.has_coin_shortcut()) {
      set_coin_shortcut(from.coin_shortcut());
    }
    if (from.has_label()) {
      set_label(from.label());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void ApplySettings::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ApplySettings::CopyFrom(const ApplySettings& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ApplySettings::IsInitialized() const {

  return true;
}

void ApplySettings::Swap(ApplySettings* other) {
  if (other != this) {
    std::swap(language_, other->language_);
    std::swap(coin_shortcut_, other->coin_shortcut_);
    std::swap(label_, other->label_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata ApplySettings::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ApplySettings_descriptor_;
  metadata.reflection = ApplySettings_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int ChangePin::kRemoveFieldNumber;
#endif  // !_MSC_VER

ChangePin::ChangePin()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void ChangePin::InitAsDefaultInstance() {
}

ChangePin::ChangePin(const ChangePin& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void ChangePin::SharedCtor() {
  _cached_size_ = 0;
  remove_ = false;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ChangePin::~ChangePin() {
  SharedDtor();
}

void ChangePin::SharedDtor() {
  if (this != default_instance_) {
  }
}

void ChangePin::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ChangePin::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ChangePin_descriptor_;
}

const ChangePin& ChangePin::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_trezor_2eproto();
  return *default_instance_;
}

ChangePin* ChangePin::default_instance_ = NULL;

ChangePin* ChangePin::New() const {
  return new ChangePin;
}

void ChangePin::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    remove_ = false;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool ChangePin::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional bool remove = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &remove_)));
          set_has_remove();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ChangePin::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional bool remove = 1;
  if (has_remove()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(1, this->remove(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* ChangePin::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional bool remove = 1;
  if (has_remove()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(1, this->remove(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int ChangePin::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional bool remove = 1;
    if (has_remove()) {
      total_size += 1 + 1;
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ChangePin::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const ChangePin* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const ChangePin*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void ChangePin::MergeFrom(const ChangePin& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_remove()) {
      set_remove(from.remove());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void ChangePin::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ChangePin::CopyFrom(const ChangePin& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ChangePin::IsInitialized() const {

  return true;
}

void ChangePin::Swap(ChangePin* other) {
  if (other != this) {
    std::swap(remove_, other->remove_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata ChangePin::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ChangePin_descriptor_;
  metadata.reflection = ChangePin_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int Ping::kMessageFieldNumber;
#endif  // !_MSC_VER

Ping::Ping()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void Ping::InitAsDefaultInstance() {
}

Ping::Ping(const Ping& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void Ping::SharedCtor() {
  _cached_size_ = 0;
  message_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Ping::~Ping() {
  SharedDtor();
}

void Ping::SharedDtor() {
  if (message_ != &::google::protobuf::internal::kEmptyString) {
    delete message_;
  }
  if (this != default_instance_) {
  }
}

void Ping::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Ping::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Ping_descriptor_;
}

const Ping& Ping::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_trezor_2eproto();
  return *default_instance_;
}

Ping* Ping::default_instance_ = NULL;

Ping* Ping::New() const {
  return new Ping;
}

void Ping::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_message()) {
      if (message_ != &::google::protobuf::internal::kEmptyString) {
        message_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Ping::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional bytes message = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_message()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Ping::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional bytes message = 1;
  if (has_message()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      1, this->message(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* Ping::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional bytes message = 1;
  if (has_message()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        1, this->message(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int Ping::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional bytes message = 1;
    if (has_message()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->message());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Ping::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Ping* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Ping*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Ping::MergeFrom(const Ping& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_message()) {
      set_message(from.message());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Ping::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Ping::CopyFrom(const Ping& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Ping::IsInitialized() const {

  return true;
}

void Ping::Swap(Ping* other) {
  if (other != this) {
    std::swap(message_, other->message_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Ping::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Ping_descriptor_;
  metadata.reflection = Ping_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int Success::kMessageFieldNumber;
#endif  // !_MSC_VER

Success::Success()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void Success::InitAsDefaultInstance() {
}

Success::Success(const Success& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void Success::SharedCtor() {
  _cached_size_ = 0;
  message_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Success::~Success() {
  SharedDtor();
}

void Success::SharedDtor() {
  if (message_ != &::google::protobuf::internal::kEmptyString) {
    delete message_;
  }
  if (this != default_instance_) {
  }
}

void Success::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Success::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Success_descriptor_;
}

const Success& Success::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_trezor_2eproto();
  return *default_instance_;
}

Success* Success::default_instance_ = NULL;

Success* Success::New() const {
  return new Success;
}

void Success::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_message()) {
      if (message_ != &::google::protobuf::internal::kEmptyString) {
        message_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Success::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional bytes message = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_message()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Success::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional bytes message = 1;
  if (has_message()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      1, this->message(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* Success::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional bytes message = 1;
  if (has_message()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        1, this->message(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int Success::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional bytes message = 1;
    if (has_message()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->message());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Success::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Success* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Success*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Success::MergeFrom(const Success& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_message()) {
      set_message(from.message());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Success::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Success::CopyFrom(const Success& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Success::IsInitialized() const {

  return true;
}

void Success::Swap(Success* other) {
  if (other != this) {
    std::swap(message_, other->message_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Success::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Success_descriptor_;
  metadata.reflection = Success_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int Failure::kCodeFieldNumber;
const int Failure::kMessageFieldNumber;
#endif  // !_MSC_VER

Failure::Failure()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void Failure::InitAsDefaultInstance() {
}

Failure::Failure(const Failure& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void Failure::SharedCtor() {
  _cached_size_ = 0;
  code_ = 0;
  message_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Failure::~Failure() {
  SharedDtor();
}

void Failure::SharedDtor() {
  if (message_ != &::google::protobuf::internal::kEmptyString) {
    delete message_;
  }
  if (this != default_instance_) {
  }
}

void Failure::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Failure::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Failure_descriptor_;
}

const Failure& Failure::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_trezor_2eproto();
  return *default_instance_;
}

Failure* Failure::default_instance_ = NULL;

Failure* Failure::New() const {
  return new Failure;
}

void Failure::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    code_ = 0;
    if (has_message()) {
      if (message_ != &::google::protobuf::internal::kEmptyString) {
        message_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Failure::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 code = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &code_)));
          set_has_code();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_message;
        break;
      }

      // optional bytes message = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_message:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_message()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Failure::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional int32 code = 1;
  if (has_code()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->code(), output);
  }

  // optional bytes message = 2;
  if (has_message()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      2, this->message(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* Failure::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional int32 code = 1;
  if (has_code()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->code(), target);
  }

  // optional bytes message = 2;
  if (has_message()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        2, this->message(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int Failure::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional int32 code = 1;
    if (has_code()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->code());
    }

    // optional bytes message = 2;
    if (has_message()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->message());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Failure::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Failure* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Failure*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Failure::MergeFrom(const Failure& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_code()) {
      set_code(from.code());
    }
    if (from.has_message()) {
      set_message(from.message());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Failure::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Failure::CopyFrom(const Failure& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Failure::IsInitialized() const {

  return true;
}

void Failure::Swap(Failure* other) {
  if (other != this) {
    std::swap(code_, other->code_);
    std::swap(message_, other->message_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Failure::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Failure_descriptor_;
  metadata.reflection = Failure_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
#endif  // !_MSC_VER

ButtonRequest::ButtonRequest()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void ButtonRequest::InitAsDefaultInstance() {
}

ButtonRequest::ButtonRequest(const ButtonRequest& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void ButtonRequest::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ButtonRequest::~ButtonRequest() {
  SharedDtor();
}

void ButtonRequest::SharedDtor() {
  if (this != default_instance_) {
  }
}

void ButtonRequest::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ButtonRequest::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ButtonRequest_descriptor_;
}

const ButtonRequest& ButtonRequest::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_trezor_2eproto();
  return *default_instance_;
}

ButtonRequest* ButtonRequest::default_instance_ = NULL;

ButtonRequest* ButtonRequest::New() const {
  return new ButtonRequest;
}

void ButtonRequest::Clear() {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool ButtonRequest::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      return true;
    }
    DO_(::google::protobuf::internal::WireFormat::SkipField(
          input, tag, mutable_unknown_fields()));
  }
  return true;
#undef DO_
}

void ButtonRequest::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* ButtonRequest::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int ButtonRequest::ByteSize() const {
  int total_size = 0;

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ButtonRequest::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const ButtonRequest* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const ButtonRequest*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void ButtonRequest::MergeFrom(const ButtonRequest& from) {
  GOOGLE_CHECK_NE(&from, this);
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void ButtonRequest::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ButtonRequest::CopyFrom(const ButtonRequest& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ButtonRequest::IsInitialized() const {

  return true;
}

void ButtonRequest::Swap(ButtonRequest* other) {
  if (other != this) {
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata ButtonRequest::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ButtonRequest_descriptor_;
  metadata.reflection = ButtonRequest_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
#endif  // !_MSC_VER

ButtonAck::ButtonAck()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void ButtonAck::InitAsDefaultInstance() {
}

ButtonAck::ButtonAck(const ButtonAck& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void ButtonAck::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ButtonAck::~ButtonAck() {
  SharedDtor();
}

void ButtonAck::SharedDtor() {
  if (this != default_instance_) {
  }
}

void ButtonAck::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ButtonAck::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ButtonAck_descriptor_;
}

const ButtonAck& ButtonAck::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_trezor_2eproto();
  return *default_instance_;
}

ButtonAck* ButtonAck::default_instance_ = NULL;

ButtonAck* ButtonAck::New() const {
  return new ButtonAck;
}

void ButtonAck::Clear() {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool ButtonAck::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      return true;
    }
    DO_(::google::protobuf::internal::WireFormat::SkipField(
          input, tag, mutable_unknown_fields()));
  }
  return true;
#undef DO_
}

void ButtonAck::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* ButtonAck::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int ButtonAck::ByteSize() const {
  int total_size = 0;

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ButtonAck::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const ButtonAck* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const ButtonAck*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void ButtonAck::MergeFrom(const ButtonAck& from) {
  GOOGLE_CHECK_NE(&from, this);
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void ButtonAck::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ButtonAck::CopyFrom(const ButtonAck& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ButtonAck::IsInitialized() const {

  return true;
}

void ButtonAck::Swap(ButtonAck* other) {
  if (other != this) {
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata ButtonAck::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ButtonAck_descriptor_;
  metadata.reflection = ButtonAck_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
#endif  // !_MSC_VER

ButtonCancel::ButtonCancel()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void ButtonCancel::InitAsDefaultInstance() {
}

ButtonCancel::ButtonCancel(const ButtonCancel& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void ButtonCancel::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ButtonCancel::~ButtonCancel() {
  SharedDtor();
}

void ButtonCancel::SharedDtor() {
  if (this != default_instance_) {
  }
}

void ButtonCancel::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ButtonCancel::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ButtonCancel_descriptor_;
}

const ButtonCancel& ButtonCancel::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_trezor_2eproto();
  return *default_instance_;
}

ButtonCancel* ButtonCancel::default_instance_ = NULL;

ButtonCancel* ButtonCancel::New() const {
  return new ButtonCancel;
}

void ButtonCancel::Clear() {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool ButtonCancel::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      return true;
    }
    DO_(::google::protobuf::internal::WireFormat::SkipField(
          input, tag, mutable_unknown_fields()));
  }
  return true;
#undef DO_
}

void ButtonCancel::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* ButtonCancel::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int ButtonCancel::ByteSize() const {
  int total_size = 0;

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ButtonCancel::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const ButtonCancel* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const ButtonCancel*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void ButtonCancel::MergeFrom(const ButtonCancel& from) {
  GOOGLE_CHECK_NE(&from, this);
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void ButtonCancel::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ButtonCancel::CopyFrom(const ButtonCancel& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ButtonCancel::IsInitialized() const {

  return true;
}

void ButtonCancel::Swap(ButtonCancel* other) {
  if (other != this) {
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata ButtonCancel::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ButtonCancel_descriptor_;
  metadata.reflection = ButtonCancel_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int PinMatrixRequest::kMessageFieldNumber;
#endif  // !_MSC_VER

PinMatrixRequest::PinMatrixRequest()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void PinMatrixRequest::InitAsDefaultInstance() {
}

PinMatrixRequest::PinMatrixRequest(const PinMatrixRequest& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void PinMatrixRequest::SharedCtor() {
  _cached_size_ = 0;
  message_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

PinMatrixRequest::~PinMatrixRequest() {
  SharedDtor();
}

void PinMatrixRequest::SharedDtor() {
  if (message_ != &::google::protobuf::internal::kEmptyString) {
    delete message_;
  }
  if (this != default_instance_) {
  }
}

void PinMatrixRequest::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* PinMatrixRequest::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return PinMatrixRequest_descriptor_;
}

const PinMatrixRequest& PinMatrixRequest::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_trezor_2eproto();
  return *default_instance_;
}

PinMatrixRequest* PinMatrixRequest::default_instance_ = NULL;

PinMatrixRequest* PinMatrixRequest::New() const {
  return new PinMatrixRequest;
}

void PinMatrixRequest::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_message()) {
      if (message_ != &::google::protobuf::internal::kEmptyString) {
        message_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool PinMatrixRequest::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional bytes message = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_message()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void PinMatrixRequest::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional bytes message = 1;
  if (has_message()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      1, this->message(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* PinMatrixRequest::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional bytes message = 1;
  if (has_message()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        1, this->message(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int PinMatrixRequest::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional bytes message = 1;
    if (has_message()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->message());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void PinMatrixRequest::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const PinMatrixRequest* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const PinMatrixRequest*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void PinMatrixRequest::MergeFrom(const PinMatrixRequest& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_message()) {
      set_message(from.message());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void PinMatrixRequest::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void PinMatrixRequest::CopyFrom(const PinMatrixRequest& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PinMatrixRequest::IsInitialized() const {

  return true;
}

void PinMatrixRequest::Swap(PinMatrixRequest* other) {
  if (other != this) {
    std::swap(message_, other->message_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata PinMatrixRequest::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = PinMatrixRequest_descriptor_;
  metadata.reflection = PinMatrixRequest_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int PinMatrixAck::kPinFieldNumber;
#endif  // !_MSC_VER

PinMatrixAck::PinMatrixAck()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void PinMatrixAck::InitAsDefaultInstance() {
}

PinMatrixAck::PinMatrixAck(const PinMatrixAck& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void PinMatrixAck::SharedCtor() {
  _cached_size_ = 0;
  pin_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

PinMatrixAck::~PinMatrixAck() {
  SharedDtor();
}

void PinMatrixAck::SharedDtor() {
  if (pin_ != &::google::protobuf::internal::kEmptyString) {
    delete pin_;
  }
  if (this != default_instance_) {
  }
}

void PinMatrixAck::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* PinMatrixAck::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return PinMatrixAck_descriptor_;
}

const PinMatrixAck& PinMatrixAck::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_trezor_2eproto();
  return *default_instance_;
}

PinMatrixAck* PinMatrixAck::default_instance_ = NULL;

PinMatrixAck* PinMatrixAck::New() const {
  return new PinMatrixAck;
}

void PinMatrixAck::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_pin()) {
      if (pin_ != &::google::protobuf::internal::kEmptyString) {
        pin_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool PinMatrixAck::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required bytes pin = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_pin()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void PinMatrixAck::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required bytes pin = 1;
  if (has_pin()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      1, this->pin(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* PinMatrixAck::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required bytes pin = 1;
  if (has_pin()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        1, this->pin(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int PinMatrixAck::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required bytes pin = 1;
    if (has_pin()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->pin());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void PinMatrixAck::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const PinMatrixAck* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const PinMatrixAck*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void PinMatrixAck::MergeFrom(const PinMatrixAck& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_pin()) {
      set_pin(from.pin());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void PinMatrixAck::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void PinMatrixAck::CopyFrom(const PinMatrixAck& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PinMatrixAck::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void PinMatrixAck::Swap(PinMatrixAck* other) {
  if (other != this) {
    std::swap(pin_, other->pin_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata PinMatrixAck::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = PinMatrixAck_descriptor_;
  metadata.reflection = PinMatrixAck_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
#endif  // !_MSC_VER

PinMatrixCancel::PinMatrixCancel()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void PinMatrixCancel::InitAsDefaultInstance() {
}

PinMatrixCancel::PinMatrixCancel(const PinMatrixCancel& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void PinMatrixCancel::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

PinMatrixCancel::~PinMatrixCancel() {
  SharedDtor();
}

void PinMatrixCancel::SharedDtor() {
  if (this != default_instance_) {
  }
}

void PinMatrixCancel::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* PinMatrixCancel::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return PinMatrixCancel_descriptor_;
}

const PinMatrixCancel& PinMatrixCancel::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_trezor_2eproto();
  return *default_instance_;
}

PinMatrixCancel* PinMatrixCancel::default_instance_ = NULL;

PinMatrixCancel* PinMatrixCancel::New() const {
  return new PinMatrixCancel;
}

void PinMatrixCancel::Clear() {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool PinMatrixCancel::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      return true;
    }
    DO_(::google::protobuf::internal::WireFormat::SkipField(
          input, tag, mutable_unknown_fields()));
  }
  return true;
#undef DO_
}

void PinMatrixCancel::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* PinMatrixCancel::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int PinMatrixCancel::ByteSize() const {
  int total_size = 0;

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void PinMatrixCancel::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const PinMatrixCancel* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const PinMatrixCancel*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void PinMatrixCancel::MergeFrom(const PinMatrixCancel& from) {
  GOOGLE_CHECK_NE(&from, this);
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void PinMatrixCancel::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void PinMatrixCancel::CopyFrom(const PinMatrixCancel& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PinMatrixCancel::IsInitialized() const {

  return true;
}

void PinMatrixCancel::Swap(PinMatrixCancel* other) {
  if (other != this) {
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata PinMatrixCancel::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = PinMatrixCancel_descriptor_;
  metadata.reflection = PinMatrixCancel_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int GetEntropy::kSizeFieldNumber;
#endif  // !_MSC_VER

GetEntropy::GetEntropy()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void GetEntropy::InitAsDefaultInstance() {
}

GetEntropy::GetEntropy(const GetEntropy& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void GetEntropy::SharedCtor() {
  _cached_size_ = 0;
  size_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

GetEntropy::~GetEntropy() {
  SharedDtor();
}

void GetEntropy::SharedDtor() {
  if (this != default_instance_) {
  }
}

void GetEntropy::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* GetEntropy::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return GetEntropy_descriptor_;
}

const GetEntropy& GetEntropy::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_trezor_2eproto();
  return *default_instance_;
}

GetEntropy* GetEntropy::default_instance_ = NULL;

GetEntropy* GetEntropy::New() const {
  return new GetEntropy;
}

void GetEntropy::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    size_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool GetEntropy::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 size = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &size_)));
          set_has_size();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void GetEntropy::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint32 size = 1;
  if (has_size()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->size(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* GetEntropy::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required uint32 size = 1;
  if (has_size()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->size(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int GetEntropy::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 size = 1;
    if (has_size()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->size());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void GetEntropy::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const GetEntropy* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const GetEntropy*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void GetEntropy::MergeFrom(const GetEntropy& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_size()) {
      set_size(from.size());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void GetEntropy::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void GetEntropy::CopyFrom(const GetEntropy& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GetEntropy::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void GetEntropy::Swap(GetEntropy* other) {
  if (other != this) {
    std::swap(size_, other->size_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata GetEntropy::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = GetEntropy_descriptor_;
  metadata.reflection = GetEntropy_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int Entropy::kEntropyFieldNumber;
#endif  // !_MSC_VER

Entropy::Entropy()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void Entropy::InitAsDefaultInstance() {
}

Entropy::Entropy(const Entropy& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void Entropy::SharedCtor() {
  _cached_size_ = 0;
  entropy_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Entropy::~Entropy() {
  SharedDtor();
}

void Entropy::SharedDtor() {
  if (entropy_ != &::google::protobuf::internal::kEmptyString) {
    delete entropy_;
  }
  if (this != default_instance_) {
  }
}

void Entropy::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Entropy::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Entropy_descriptor_;
}

const Entropy& Entropy::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_trezor_2eproto();
  return *default_instance_;
}

Entropy* Entropy::default_instance_ = NULL;

Entropy* Entropy::New() const {
  return new Entropy;
}

void Entropy::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_entropy()) {
      if (entropy_ != &::google::protobuf::internal::kEmptyString) {
        entropy_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Entropy::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required bytes entropy = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_entropy()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Entropy::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required bytes entropy = 1;
  if (has_entropy()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      1, this->entropy(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* Entropy::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required bytes entropy = 1;
  if (has_entropy()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        1, this->entropy(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int Entropy::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required bytes entropy = 1;
    if (has_entropy()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->entropy());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Entropy::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Entropy* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Entropy*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Entropy::MergeFrom(const Entropy& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_entropy()) {
      set_entropy(from.entropy());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Entropy::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Entropy::CopyFrom(const Entropy& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Entropy::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void Entropy::Swap(Entropy* other) {
  if (other != this) {
    std::swap(entropy_, other->entropy_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Entropy::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Entropy_descriptor_;
  metadata.reflection = Entropy_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
#endif  // !_MSC_VER

GetMasterPublicKey::GetMasterPublicKey()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void GetMasterPublicKey::InitAsDefaultInstance() {
}

GetMasterPublicKey::GetMasterPublicKey(const GetMasterPublicKey& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void GetMasterPublicKey::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

GetMasterPublicKey::~GetMasterPublicKey() {
  SharedDtor();
}

void GetMasterPublicKey::SharedDtor() {
  if (this != default_instance_) {
  }
}

void GetMasterPublicKey::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* GetMasterPublicKey::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return GetMasterPublicKey_descriptor_;
}

const GetMasterPublicKey& GetMasterPublicKey::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_trezor_2eproto();
  return *default_instance_;
}

GetMasterPublicKey* GetMasterPublicKey::default_instance_ = NULL;

GetMasterPublicKey* GetMasterPublicKey::New() const {
  return new GetMasterPublicKey;
}

void GetMasterPublicKey::Clear() {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool GetMasterPublicKey::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      return true;
    }
    DO_(::google::protobuf::internal::WireFormat::SkipField(
          input, tag, mutable_unknown_fields()));
  }
  return true;
#undef DO_
}

void GetMasterPublicKey::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* GetMasterPublicKey::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int GetMasterPublicKey::ByteSize() const {
  int total_size = 0;

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void GetMasterPublicKey::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const GetMasterPublicKey* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const GetMasterPublicKey*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void GetMasterPublicKey::MergeFrom(const GetMasterPublicKey& from) {
  GOOGLE_CHECK_NE(&from, this);
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void GetMasterPublicKey::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void GetMasterPublicKey::CopyFrom(const GetMasterPublicKey& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GetMasterPublicKey::IsInitialized() const {

  return true;
}

void GetMasterPublicKey::Swap(GetMasterPublicKey* other) {
  if (other != this) {
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata GetMasterPublicKey::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = GetMasterPublicKey_descriptor_;
  metadata.reflection = GetMasterPublicKey_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int MasterPublicKey::kMpkFieldNumber;
#endif  // !_MSC_VER

MasterPublicKey::MasterPublicKey()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void MasterPublicKey::InitAsDefaultInstance() {
  mpk_ = const_cast< ::XpubType*>(&::XpubType::default_instance());
}

MasterPublicKey::MasterPublicKey(const MasterPublicKey& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void MasterPublicKey::SharedCtor() {
  _cached_size_ = 0;
  mpk_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

MasterPublicKey::~MasterPublicKey() {
  SharedDtor();
}

void MasterPublicKey::SharedDtor() {
  if (this != default_instance_) {
    delete mpk_;
  }
}

void MasterPublicKey::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* MasterPublicKey::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return MasterPublicKey_descriptor_;
}

const MasterPublicKey& MasterPublicKey::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_trezor_2eproto();
  return *default_instance_;
}

MasterPublicKey* MasterPublicKey::default_instance_ = NULL;

MasterPublicKey* MasterPublicKey::New() const {
  return new MasterPublicKey;
}

void MasterPublicKey::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_mpk()) {
      if (mpk_ != NULL) mpk_->::XpubType::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool MasterPublicKey::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .XpubType mpk = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_mpk()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void MasterPublicKey::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .XpubType mpk = 1;
  if (has_mpk()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->mpk(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* MasterPublicKey::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required .XpubType mpk = 1;
  if (has_mpk()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->mpk(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int MasterPublicKey::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .XpubType mpk = 1;
    if (has_mpk()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->mpk());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void MasterPublicKey::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const MasterPublicKey* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const MasterPublicKey*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void MasterPublicKey::MergeFrom(const MasterPublicKey& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_mpk()) {
      mutable_mpk()->::XpubType::MergeFrom(from.mpk());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void MasterPublicKey::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void MasterPublicKey::CopyFrom(const MasterPublicKey& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MasterPublicKey::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  if (has_mpk()) {
    if (!this->mpk().IsInitialized()) return false;
  }
  return true;
}

void MasterPublicKey::Swap(MasterPublicKey* other) {
  if (other != this) {
    std::swap(mpk_, other->mpk_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata MasterPublicKey::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = MasterPublicKey_descriptor_;
  metadata.reflection = MasterPublicKey_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int GetAddress::kAddressNFieldNumber;
#endif  // !_MSC_VER

GetAddress::GetAddress()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void GetAddress::InitAsDefaultInstance() {
}

GetAddress::GetAddress(const GetAddress& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void GetAddress::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

GetAddress::~GetAddress() {
  SharedDtor();
}

void GetAddress::SharedDtor() {
  if (this != default_instance_) {
  }
}

void GetAddress::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* GetAddress::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return GetAddress_descriptor_;
}

const GetAddress& GetAddress::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_trezor_2eproto();
  return *default_instance_;
}

GetAddress* GetAddress::default_instance_ = NULL;

GetAddress* GetAddress::New() const {
  return new GetAddress;
}

void GetAddress::Clear() {
  address_n_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool GetAddress::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated uint32 address_n = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_address_n:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 1, 8, input, this->mutable_address_n())));
        } else if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag)
                   == ::google::protobuf::internal::WireFormatLite::
                      WIRETYPE_LENGTH_DELIMITED) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, this->mutable_address_n())));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(8)) goto parse_address_n;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void GetAddress::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated uint32 address_n = 1;
  for (int i = 0; i < this->address_n_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(
      1, this->address_n(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* GetAddress::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // repeated uint32 address_n = 1;
  for (int i = 0; i < this->address_n_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteUInt32ToArray(1, this->address_n(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int GetAddress::ByteSize() const {
  int total_size = 0;

  // repeated uint32 address_n = 1;
  {
    int data_size = 0;
    for (int i = 0; i < this->address_n_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::
        UInt32Size(this->address_n(i));
    }
    total_size += 1 * this->address_n_size() + data_size;
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void GetAddress::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const GetAddress* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const GetAddress*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void GetAddress::MergeFrom(const GetAddress& from) {
  GOOGLE_CHECK_NE(&from, this);
  address_n_.MergeFrom(from.address_n_);
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void GetAddress::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void GetAddress::CopyFrom(const GetAddress& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GetAddress::IsInitialized() const {

  return true;
}

void GetAddress::Swap(GetAddress* other) {
  if (other != this) {
    address_n_.Swap(&other->address_n_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata GetAddress::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = GetAddress_descriptor_;
  metadata.reflection = GetAddress_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int Address::kAddressFieldNumber;
#endif  // !_MSC_VER

Address::Address()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void Address::InitAsDefaultInstance() {
}

Address::Address(const Address& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void Address::SharedCtor() {
  _cached_size_ = 0;
  address_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Address::~Address() {
  SharedDtor();
}

void Address::SharedDtor() {
  if (address_ != &::google::protobuf::internal::kEmptyString) {
    delete address_;
  }
  if (this != default_instance_) {
  }
}

void Address::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Address::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Address_descriptor_;
}

const Address& Address::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_trezor_2eproto();
  return *default_instance_;
}

Address* Address::default_instance_ = NULL;

Address* Address::New() const {
  return new Address;
}

void Address::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_address()) {
      if (address_ != &::google::protobuf::internal::kEmptyString) {
        address_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Address::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required bytes address = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_address()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Address::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required bytes address = 1;
  if (has_address()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      1, this->address(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* Address::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required bytes address = 1;
  if (has_address()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        1, this->address(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int Address::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required bytes address = 1;
    if (has_address()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->address());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Address::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Address* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Address*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Address::MergeFrom(const Address& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_address()) {
      set_address(from.address());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Address::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Address::CopyFrom(const Address& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Address::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void Address::Swap(Address* other) {
  if (other != this) {
    std::swap(address_, other->address_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Address::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Address_descriptor_;
  metadata.reflection = Address_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
#endif  // !_MSC_VER

WipeDevice::WipeDevice()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void WipeDevice::InitAsDefaultInstance() {
}

WipeDevice::WipeDevice(const WipeDevice& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void WipeDevice::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

WipeDevice::~WipeDevice() {
  SharedDtor();
}

void WipeDevice::SharedDtor() {
  if (this != default_instance_) {
  }
}

void WipeDevice::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* WipeDevice::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return WipeDevice_descriptor_;
}

const WipeDevice& WipeDevice::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_trezor_2eproto();
  return *default_instance_;
}

WipeDevice* WipeDevice::default_instance_ = NULL;

WipeDevice* WipeDevice::New() const {
  return new WipeDevice;
}

void WipeDevice::Clear() {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool WipeDevice::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      return true;
    }
    DO_(::google::protobuf::internal::WireFormat::SkipField(
          input, tag, mutable_unknown_fields()));
  }
  return true;
#undef DO_
}

void WipeDevice::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* WipeDevice::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int WipeDevice::ByteSize() const {
  int total_size = 0;

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void WipeDevice::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const WipeDevice* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const WipeDevice*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void WipeDevice::MergeFrom(const WipeDevice& from) {
  GOOGLE_CHECK_NE(&from, this);
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void WipeDevice::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void WipeDevice::CopyFrom(const WipeDevice& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool WipeDevice::IsInitialized() const {

  return true;
}

void WipeDevice::Swap(WipeDevice* other) {
  if (other != this) {
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata WipeDevice::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = WipeDevice_descriptor_;
  metadata.reflection = WipeDevice_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int LoadDevice::kSeedFieldNumber;
const int LoadDevice::kXprvFieldNumber;
const int LoadDevice::kPinFieldNumber;
#endif  // !_MSC_VER

LoadDevice::LoadDevice()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void LoadDevice::InitAsDefaultInstance() {
  xprv_ = const_cast< ::XprvType*>(&::XprvType::default_instance());
}

LoadDevice::LoadDevice(const LoadDevice& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void LoadDevice::SharedCtor() {
  _cached_size_ = 0;
  seed_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  xprv_ = NULL;
  pin_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

LoadDevice::~LoadDevice() {
  SharedDtor();
}

void LoadDevice::SharedDtor() {
  if (seed_ != &::google::protobuf::internal::kEmptyString) {
    delete seed_;
  }
  if (pin_ != &::google::protobuf::internal::kEmptyString) {
    delete pin_;
  }
  if (this != default_instance_) {
    delete xprv_;
  }
}

void LoadDevice::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* LoadDevice::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return LoadDevice_descriptor_;
}

const LoadDevice& LoadDevice::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_trezor_2eproto();
  return *default_instance_;
}

LoadDevice* LoadDevice::default_instance_ = NULL;

LoadDevice* LoadDevice::New() const {
  return new LoadDevice;
}

void LoadDevice::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_seed()) {
      if (seed_ != &::google::protobuf::internal::kEmptyString) {
        seed_->clear();
      }
    }
    if (has_xprv()) {
      if (xprv_ != NULL) xprv_->::XprvType::Clear();
    }
    if (has_pin()) {
      if (pin_ != &::google::protobuf::internal::kEmptyString) {
        pin_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool LoadDevice::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional bytes seed = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_seed()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_xprv;
        break;
      }

      // optional .XprvType xprv = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_xprv:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_xprv()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_pin;
        break;
      }

      // optional bytes pin = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_pin:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_pin()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void LoadDevice::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional bytes seed = 1;
  if (has_seed()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      1, this->seed(), output);
  }

  // optional .XprvType xprv = 2;
  if (has_xprv()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->xprv(), output);
  }

  // optional bytes pin = 3;
  if (has_pin()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      3, this->pin(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* LoadDevice::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional bytes seed = 1;
  if (has_seed()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        1, this->seed(), target);
  }

  // optional .XprvType xprv = 2;
  if (has_xprv()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->xprv(), target);
  }

  // optional bytes pin = 3;
  if (has_pin()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        3, this->pin(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int LoadDevice::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional bytes seed = 1;
    if (has_seed()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->seed());
    }

    // optional .XprvType xprv = 2;
    if (has_xprv()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->xprv());
    }

    // optional bytes pin = 3;
    if (has_pin()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->pin());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void LoadDevice::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const LoadDevice* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const LoadDevice*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void LoadDevice::MergeFrom(const LoadDevice& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_seed()) {
      set_seed(from.seed());
    }
    if (from.has_xprv()) {
      mutable_xprv()->::XprvType::MergeFrom(from.xprv());
    }
    if (from.has_pin()) {
      set_pin(from.pin());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void LoadDevice::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void LoadDevice::CopyFrom(const LoadDevice& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LoadDevice::IsInitialized() const {

  if (has_xprv()) {
    if (!this->xprv().IsInitialized()) return false;
  }
  return true;
}

void LoadDevice::Swap(LoadDevice* other) {
  if (other != this) {
    std::swap(seed_, other->seed_);
    std::swap(xprv_, other->xprv_);
    std::swap(pin_, other->pin_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata LoadDevice::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = LoadDevice_descriptor_;
  metadata.reflection = LoadDevice_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int ResetDevice::kDisplayRandomFieldNumber;
#endif  // !_MSC_VER

ResetDevice::ResetDevice()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void ResetDevice::InitAsDefaultInstance() {
}

ResetDevice::ResetDevice(const ResetDevice& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void ResetDevice::SharedCtor() {
  _cached_size_ = 0;
  display_random_ = false;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ResetDevice::~ResetDevice() {
  SharedDtor();
}

void ResetDevice::SharedDtor() {
  if (this != default_instance_) {
  }
}

void ResetDevice::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ResetDevice::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ResetDevice_descriptor_;
}

const ResetDevice& ResetDevice::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_trezor_2eproto();
  return *default_instance_;
}

ResetDevice* ResetDevice::default_instance_ = NULL;

ResetDevice* ResetDevice::New() const {
  return new ResetDevice;
}

void ResetDevice::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    display_random_ = false;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool ResetDevice::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional bool display_random = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &display_random_)));
          set_has_display_random();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ResetDevice::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional bool display_random = 1;
  if (has_display_random()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(1, this->display_random(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* ResetDevice::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional bool display_random = 1;
  if (has_display_random()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(1, this->display_random(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int ResetDevice::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional bool display_random = 1;
    if (has_display_random()) {
      total_size += 1 + 1;
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ResetDevice::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const ResetDevice* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const ResetDevice*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void ResetDevice::MergeFrom(const ResetDevice& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_display_random()) {
      set_display_random(from.display_random());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void ResetDevice::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ResetDevice::CopyFrom(const ResetDevice& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ResetDevice::IsInitialized() const {

  return true;
}

void ResetDevice::Swap(ResetDevice* other) {
  if (other != this) {
    std::swap(display_random_, other->display_random_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata ResetDevice::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ResetDevice_descriptor_;
  metadata.reflection = ResetDevice_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
#endif  // !_MSC_VER

EntropyRequest::EntropyRequest()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void EntropyRequest::InitAsDefaultInstance() {
}

EntropyRequest::EntropyRequest(const EntropyRequest& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void EntropyRequest::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

EntropyRequest::~EntropyRequest() {
  SharedDtor();
}

void EntropyRequest::SharedDtor() {
  if (this != default_instance_) {
  }
}

void EntropyRequest::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* EntropyRequest::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return EntropyRequest_descriptor_;
}

const EntropyRequest& EntropyRequest::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_trezor_2eproto();
  return *default_instance_;
}

EntropyRequest* EntropyRequest::default_instance_ = NULL;

EntropyRequest* EntropyRequest::New() const {
  return new EntropyRequest;
}

void EntropyRequest::Clear() {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool EntropyRequest::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      return true;
    }
    DO_(::google::protobuf::internal::WireFormat::SkipField(
          input, tag, mutable_unknown_fields()));
  }
  return true;
#undef DO_
}

void EntropyRequest::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* EntropyRequest::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int EntropyRequest::ByteSize() const {
  int total_size = 0;

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void EntropyRequest::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const EntropyRequest* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const EntropyRequest*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void EntropyRequest::MergeFrom(const EntropyRequest& from) {
  GOOGLE_CHECK_NE(&from, this);
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void EntropyRequest::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void EntropyRequest::CopyFrom(const EntropyRequest& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool EntropyRequest::IsInitialized() const {

  return true;
}

void EntropyRequest::Swap(EntropyRequest* other) {
  if (other != this) {
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata EntropyRequest::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = EntropyRequest_descriptor_;
  metadata.reflection = EntropyRequest_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int EntropyAck::kEntropyFieldNumber;
#endif  // !_MSC_VER

EntropyAck::EntropyAck()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void EntropyAck::InitAsDefaultInstance() {
}

EntropyAck::EntropyAck(const EntropyAck& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void EntropyAck::SharedCtor() {
  _cached_size_ = 0;
  entropy_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

EntropyAck::~EntropyAck() {
  SharedDtor();
}

void EntropyAck::SharedDtor() {
  if (entropy_ != &::google::protobuf::internal::kEmptyString) {
    delete entropy_;
  }
  if (this != default_instance_) {
  }
}

void EntropyAck::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* EntropyAck::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return EntropyAck_descriptor_;
}

const EntropyAck& EntropyAck::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_trezor_2eproto();
  return *default_instance_;
}

EntropyAck* EntropyAck::default_instance_ = NULL;

EntropyAck* EntropyAck::New() const {
  return new EntropyAck;
}

void EntropyAck::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_entropy()) {
      if (entropy_ != &::google::protobuf::internal::kEmptyString) {
        entropy_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool EntropyAck::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional bytes entropy = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_entropy()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void EntropyAck::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional bytes entropy = 1;
  if (has_entropy()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      1, this->entropy(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* EntropyAck::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional bytes entropy = 1;
  if (has_entropy()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        1, this->entropy(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int EntropyAck::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional bytes entropy = 1;
    if (has_entropy()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->entropy());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void EntropyAck::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const EntropyAck* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const EntropyAck*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void EntropyAck::MergeFrom(const EntropyAck& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_entropy()) {
      set_entropy(from.entropy());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void EntropyAck::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void EntropyAck::CopyFrom(const EntropyAck& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool EntropyAck::IsInitialized() const {

  return true;
}

void EntropyAck::Swap(EntropyAck* other) {
  if (other != this) {
    std::swap(entropy_, other->entropy_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata EntropyAck::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = EntropyAck_descriptor_;
  metadata.reflection = EntropyAck_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int SignTx::kOutputsCountFieldNumber;
const int SignTx::kInputsCountFieldNumber;
#endif  // !_MSC_VER

SignTx::SignTx()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void SignTx::InitAsDefaultInstance() {
}

SignTx::SignTx(const SignTx& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void SignTx::SharedCtor() {
  _cached_size_ = 0;
  outputs_count_ = 0u;
  inputs_count_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

SignTx::~SignTx() {
  SharedDtor();
}

void SignTx::SharedDtor() {
  if (this != default_instance_) {
  }
}

void SignTx::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* SignTx::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return SignTx_descriptor_;
}

const SignTx& SignTx::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_trezor_2eproto();
  return *default_instance_;
}

SignTx* SignTx::default_instance_ = NULL;

SignTx* SignTx::New() const {
  return new SignTx;
}

void SignTx::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    outputs_count_ = 0u;
    inputs_count_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool SignTx::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 outputs_count = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &outputs_count_)));
          set_has_outputs_count();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(40)) goto parse_inputs_count;
        break;
      }

      // required uint32 inputs_count = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_inputs_count:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &inputs_count_)));
          set_has_inputs_count();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void SignTx::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint32 outputs_count = 3;
  if (has_outputs_count()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->outputs_count(), output);
  }

  // required uint32 inputs_count = 5;
  if (has_inputs_count()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(5, this->inputs_count(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* SignTx::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required uint32 outputs_count = 3;
  if (has_outputs_count()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(3, this->outputs_count(), target);
  }

  // required uint32 inputs_count = 5;
  if (has_inputs_count()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(5, this->inputs_count(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int SignTx::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 outputs_count = 3;
    if (has_outputs_count()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->outputs_count());
    }

    // required uint32 inputs_count = 5;
    if (has_inputs_count()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->inputs_count());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void SignTx::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const SignTx* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const SignTx*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void SignTx::MergeFrom(const SignTx& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_outputs_count()) {
      set_outputs_count(from.outputs_count());
    }
    if (from.has_inputs_count()) {
      set_inputs_count(from.inputs_count());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void SignTx::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void SignTx::CopyFrom(const SignTx& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SignTx::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void SignTx::Swap(SignTx* other) {
  if (other != this) {
    std::swap(outputs_count_, other->outputs_count_);
    std::swap(inputs_count_, other->inputs_count_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata SignTx::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = SignTx_descriptor_;
  metadata.reflection = SignTx_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int SimpleSignTx::kInputsFieldNumber;
const int SimpleSignTx::kOutputsFieldNumber;
#endif  // !_MSC_VER

SimpleSignTx::SimpleSignTx()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void SimpleSignTx::InitAsDefaultInstance() {
}

SimpleSignTx::SimpleSignTx(const SimpleSignTx& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void SimpleSignTx::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

SimpleSignTx::~SimpleSignTx() {
  SharedDtor();
}

void SimpleSignTx::SharedDtor() {
  if (this != default_instance_) {
  }
}

void SimpleSignTx::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* SimpleSignTx::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return SimpleSignTx_descriptor_;
}

const SimpleSignTx& SimpleSignTx::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_trezor_2eproto();
  return *default_instance_;
}

SimpleSignTx* SimpleSignTx::default_instance_ = NULL;

SimpleSignTx* SimpleSignTx::New() const {
  return new SimpleSignTx;
}

void SimpleSignTx::Clear() {
  inputs_.Clear();
  outputs_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool SimpleSignTx::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .TxInput inputs = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_inputs:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_inputs()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(10)) goto parse_inputs;
        if (input->ExpectTag(18)) goto parse_outputs;
        break;
      }

      // repeated .TxOutput outputs = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_outputs:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_outputs()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_outputs;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void SimpleSignTx::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated .TxInput inputs = 1;
  for (int i = 0; i < this->inputs_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->inputs(i), output);
  }

  // repeated .TxOutput outputs = 2;
  for (int i = 0; i < this->outputs_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->outputs(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* SimpleSignTx::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // repeated .TxInput inputs = 1;
  for (int i = 0; i < this->inputs_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->inputs(i), target);
  }

  // repeated .TxOutput outputs = 2;
  for (int i = 0; i < this->outputs_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->outputs(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int SimpleSignTx::ByteSize() const {
  int total_size = 0;

  // repeated .TxInput inputs = 1;
  total_size += 1 * this->inputs_size();
  for (int i = 0; i < this->inputs_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->inputs(i));
  }

  // repeated .TxOutput outputs = 2;
  total_size += 1 * this->outputs_size();
  for (int i = 0; i < this->outputs_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->outputs(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void SimpleSignTx::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const SimpleSignTx* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const SimpleSignTx*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void SimpleSignTx::MergeFrom(const SimpleSignTx& from) {
  GOOGLE_CHECK_NE(&from, this);
  inputs_.MergeFrom(from.inputs_);
  outputs_.MergeFrom(from.outputs_);
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void SimpleSignTx::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void SimpleSignTx::CopyFrom(const SimpleSignTx& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SimpleSignTx::IsInitialized() const {

  for (int i = 0; i < inputs_size(); i++) {
    if (!this->inputs(i).IsInitialized()) return false;
  }
  for (int i = 0; i < outputs_size(); i++) {
    if (!this->outputs(i).IsInitialized()) return false;
  }
  return true;
}

void SimpleSignTx::Swap(SimpleSignTx* other) {
  if (other != this) {
    inputs_.Swap(&other->inputs_);
    outputs_.Swap(&other->outputs_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata SimpleSignTx::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = SimpleSignTx_descriptor_;
  metadata.reflection = SimpleSignTx_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int TxRequest::kRequestIndexFieldNumber;
const int TxRequest::kRequestTypeFieldNumber;
const int TxRequest::kSignedIndexFieldNumber;
const int TxRequest::kSignatureFieldNumber;
const int TxRequest::kSerializedTxFieldNumber;
#endif  // !_MSC_VER

TxRequest::TxRequest()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void TxRequest::InitAsDefaultInstance() {
}

TxRequest::TxRequest(const TxRequest& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void TxRequest::SharedCtor() {
  _cached_size_ = 0;
  request_index_ = 0;
  request_type_ = 0;
  signed_index_ = 0;
  signature_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  serialized_tx_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

TxRequest::~TxRequest() {
  SharedDtor();
}

void TxRequest::SharedDtor() {
  if (signature_ != &::google::protobuf::internal::kEmptyString) {
    delete signature_;
  }
  if (serialized_tx_ != &::google::protobuf::internal::kEmptyString) {
    delete serialized_tx_;
  }
  if (this != default_instance_) {
  }
}

void TxRequest::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* TxRequest::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return TxRequest_descriptor_;
}

const TxRequest& TxRequest::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_trezor_2eproto();
  return *default_instance_;
}

TxRequest* TxRequest::default_instance_ = NULL;

TxRequest* TxRequest::New() const {
  return new TxRequest;
}

void TxRequest::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    request_index_ = 0;
    request_type_ = 0;
    signed_index_ = 0;
    if (has_signature()) {
      if (signature_ != &::google::protobuf::internal::kEmptyString) {
        signature_->clear();
      }
    }
    if (has_serialized_tx()) {
      if (serialized_tx_ != &::google::protobuf::internal::kEmptyString) {
        serialized_tx_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool TxRequest::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 request_index = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &request_index_)));
          set_has_request_index();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_request_type;
        break;
      }

      // optional .RequestType request_type = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_request_type:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::RequestType_IsValid(value)) {
            set_request_type(static_cast< ::RequestType >(value));
          } else {
            mutable_unknown_fields()->AddVarint(2, value);
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_signed_index;
        break;
      }

      // optional int32 signed_index = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_signed_index:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &signed_index_)));
          set_has_signed_index();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_signature;
        break;
      }

      // optional bytes signature = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_signature:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_signature()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(42)) goto parse_serialized_tx;
        break;
      }

      // optional bytes serialized_tx = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_serialized_tx:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_serialized_tx()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void TxRequest::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional int32 request_index = 1;
  if (has_request_index()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->request_index(), output);
  }

  // optional .RequestType request_type = 2;
  if (has_request_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      2, this->request_type(), output);
  }

  // optional int32 signed_index = 3;
  if (has_signed_index()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->signed_index(), output);
  }

  // optional bytes signature = 4;
  if (has_signature()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      4, this->signature(), output);
  }

  // optional bytes serialized_tx = 5;
  if (has_serialized_tx()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      5, this->serialized_tx(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* TxRequest::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional int32 request_index = 1;
  if (has_request_index()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->request_index(), target);
  }

  // optional .RequestType request_type = 2;
  if (has_request_type()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      2, this->request_type(), target);
  }

  // optional int32 signed_index = 3;
  if (has_signed_index()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(3, this->signed_index(), target);
  }

  // optional bytes signature = 4;
  if (has_signature()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        4, this->signature(), target);
  }

  // optional bytes serialized_tx = 5;
  if (has_serialized_tx()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        5, this->serialized_tx(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int TxRequest::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional int32 request_index = 1;
    if (has_request_index()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->request_index());
    }

    // optional .RequestType request_type = 2;
    if (has_request_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->request_type());
    }

    // optional int32 signed_index = 3;
    if (has_signed_index()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->signed_index());
    }

    // optional bytes signature = 4;
    if (has_signature()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->signature());
    }

    // optional bytes serialized_tx = 5;
    if (has_serialized_tx()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->serialized_tx());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void TxRequest::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const TxRequest* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const TxRequest*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void TxRequest::MergeFrom(const TxRequest& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_request_index()) {
      set_request_index(from.request_index());
    }
    if (from.has_request_type()) {
      set_request_type(from.request_type());
    }
    if (from.has_signed_index()) {
      set_signed_index(from.signed_index());
    }
    if (from.has_signature()) {
      set_signature(from.signature());
    }
    if (from.has_serialized_tx()) {
      set_serialized_tx(from.serialized_tx());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void TxRequest::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void TxRequest::CopyFrom(const TxRequest& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TxRequest::IsInitialized() const {

  return true;
}

void TxRequest::Swap(TxRequest* other) {
  if (other != this) {
    std::swap(request_index_, other->request_index_);
    std::swap(request_type_, other->request_type_);
    std::swap(signed_index_, other->signed_index_);
    std::swap(signature_, other->signature_);
    std::swap(serialized_tx_, other->serialized_tx_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata TxRequest::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = TxRequest_descriptor_;
  metadata.reflection = TxRequest_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int TxInput::kIndexFieldNumber;
const int TxInput::kAddressNFieldNumber;
const int TxInput::kAmountFieldNumber;
const int TxInput::kPrevHashFieldNumber;
const int TxInput::kPrevIndexFieldNumber;
const int TxInput::kScriptSigFieldNumber;
#endif  // !_MSC_VER

TxInput::TxInput()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void TxInput::InitAsDefaultInstance() {
}

TxInput::TxInput(const TxInput& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void TxInput::SharedCtor() {
  _cached_size_ = 0;
  index_ = 0u;
  amount_ = GOOGLE_ULONGLONG(0);
  prev_hash_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  prev_index_ = 0u;
  script_sig_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

TxInput::~TxInput() {
  SharedDtor();
}

void TxInput::SharedDtor() {
  if (prev_hash_ != &::google::protobuf::internal::kEmptyString) {
    delete prev_hash_;
  }
  if (script_sig_ != &::google::protobuf::internal::kEmptyString) {
    delete script_sig_;
  }
  if (this != default_instance_) {
  }
}

void TxInput::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* TxInput::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return TxInput_descriptor_;
}

const TxInput& TxInput::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_trezor_2eproto();
  return *default_instance_;
}

TxInput* TxInput::default_instance_ = NULL;

TxInput* TxInput::New() const {
  return new TxInput;
}

void TxInput::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    index_ = 0u;
    amount_ = GOOGLE_ULONGLONG(0);
    if (has_prev_hash()) {
      if (prev_hash_ != &::google::protobuf::internal::kEmptyString) {
        prev_hash_->clear();
      }
    }
    prev_index_ = 0u;
    if (has_script_sig()) {
      if (script_sig_ != &::google::protobuf::internal::kEmptyString) {
        script_sig_->clear();
      }
    }
  }
  address_n_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool TxInput::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 index = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &index_)));
          set_has_index();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_address_n;
        break;
      }

      // repeated uint32 address_n = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_address_n:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 1, 16, input, this->mutable_address_n())));
        } else if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag)
                   == ::google::protobuf::internal::WireFormatLite::
                      WIRETYPE_LENGTH_DELIMITED) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, this->mutable_address_n())));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_address_n;
        if (input->ExpectTag(24)) goto parse_amount;
        break;
      }

      // required uint64 amount = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_amount:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &amount_)));
          set_has_amount();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_prev_hash;
        break;
      }

      // required bytes prev_hash = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_prev_hash:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_prev_hash()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(40)) goto parse_prev_index;
        break;
      }

      // required uint32 prev_index = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_prev_index:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &prev_index_)));
          set_has_prev_index();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(50)) goto parse_script_sig;
        break;
      }

      // optional bytes script_sig = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_script_sig:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_script_sig()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void TxInput::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint32 index = 1;
  if (has_index()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->index(), output);
  }

  // repeated uint32 address_n = 2;
  for (int i = 0; i < this->address_n_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(
      2, this->address_n(i), output);
  }

  // required uint64 amount = 3;
  if (has_amount()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(3, this->amount(), output);
  }

  // required bytes prev_hash = 4;
  if (has_prev_hash()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      4, this->prev_hash(), output);
  }

  // required uint32 prev_index = 5;
  if (has_prev_index()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(5, this->prev_index(), output);
  }

  // optional bytes script_sig = 6;
  if (has_script_sig()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      6, this->script_sig(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* TxInput::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required uint32 index = 1;
  if (has_index()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->index(), target);
  }

  // repeated uint32 address_n = 2;
  for (int i = 0; i < this->address_n_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteUInt32ToArray(2, this->address_n(i), target);
  }

  // required uint64 amount = 3;
  if (has_amount()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(3, this->amount(), target);
  }

  // required bytes prev_hash = 4;
  if (has_prev_hash()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        4, this->prev_hash(), target);
  }

  // required uint32 prev_index = 5;
  if (has_prev_index()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(5, this->prev_index(), target);
  }

  // optional bytes script_sig = 6;
  if (has_script_sig()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        6, this->script_sig(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int TxInput::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 index = 1;
    if (has_index()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->index());
    }

    // required uint64 amount = 3;
    if (has_amount()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->amount());
    }

    // required bytes prev_hash = 4;
    if (has_prev_hash()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->prev_hash());
    }

    // required uint32 prev_index = 5;
    if (has_prev_index()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->prev_index());
    }

    // optional bytes script_sig = 6;
    if (has_script_sig()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->script_sig());
    }

  }
  // repeated uint32 address_n = 2;
  {
    int data_size = 0;
    for (int i = 0; i < this->address_n_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::
        UInt32Size(this->address_n(i));
    }
    total_size += 1 * this->address_n_size() + data_size;
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void TxInput::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const TxInput* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const TxInput*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void TxInput::MergeFrom(const TxInput& from) {
  GOOGLE_CHECK_NE(&from, this);
  address_n_.MergeFrom(from.address_n_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_index()) {
      set_index(from.index());
    }
    if (from.has_amount()) {
      set_amount(from.amount());
    }
    if (from.has_prev_hash()) {
      set_prev_hash(from.prev_hash());
    }
    if (from.has_prev_index()) {
      set_prev_index(from.prev_index());
    }
    if (from.has_script_sig()) {
      set_script_sig(from.script_sig());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void TxInput::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void TxInput::CopyFrom(const TxInput& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TxInput::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000001d) != 0x0000001d) return false;

  return true;
}

void TxInput::Swap(TxInput* other) {
  if (other != this) {
    std::swap(index_, other->index_);
    address_n_.Swap(&other->address_n_);
    std::swap(amount_, other->amount_);
    std::swap(prev_hash_, other->prev_hash_);
    std::swap(prev_index_, other->prev_index_);
    std::swap(script_sig_, other->script_sig_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata TxInput::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = TxInput_descriptor_;
  metadata.reflection = TxInput_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int TxOutput::kIndexFieldNumber;
const int TxOutput::kAddressFieldNumber;
const int TxOutput::kAddressNFieldNumber;
const int TxOutput::kAmountFieldNumber;
const int TxOutput::kScriptTypeFieldNumber;
const int TxOutput::kScriptArgsFieldNumber;
#endif  // !_MSC_VER

TxOutput::TxOutput()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void TxOutput::InitAsDefaultInstance() {
}

TxOutput::TxOutput(const TxOutput& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void TxOutput::SharedCtor() {
  _cached_size_ = 0;
  index_ = 0u;
  address_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  amount_ = GOOGLE_ULONGLONG(0);
  script_type_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

TxOutput::~TxOutput() {
  SharedDtor();
}

void TxOutput::SharedDtor() {
  if (address_ != &::google::protobuf::internal::kEmptyString) {
    delete address_;
  }
  if (this != default_instance_) {
  }
}

void TxOutput::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* TxOutput::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return TxOutput_descriptor_;
}

const TxOutput& TxOutput::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_trezor_2eproto();
  return *default_instance_;
}

TxOutput* TxOutput::default_instance_ = NULL;

TxOutput* TxOutput::New() const {
  return new TxOutput;
}

void TxOutput::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    index_ = 0u;
    if (has_address()) {
      if (address_ != &::google::protobuf::internal::kEmptyString) {
        address_->clear();
      }
    }
    amount_ = GOOGLE_ULONGLONG(0);
    script_type_ = 0;
  }
  address_n_.Clear();
  script_args_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool TxOutput::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 index = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &index_)));
          set_has_index();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_address;
        break;
      }

      // required bytes address = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_address:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_address()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_address_n;
        break;
      }

      // repeated uint32 address_n = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_address_n:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 1, 24, input, this->mutable_address_n())));
        } else if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag)
                   == ::google::protobuf::internal::WireFormatLite::
                      WIRETYPE_LENGTH_DELIMITED) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, this->mutable_address_n())));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_address_n;
        if (input->ExpectTag(32)) goto parse_amount;
        break;
      }

      // required uint64 amount = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_amount:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &amount_)));
          set_has_amount();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(40)) goto parse_script_type;
        break;
      }

      // required .ScriptType script_type = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_script_type:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::ScriptType_IsValid(value)) {
            set_script_type(static_cast< ::ScriptType >(value));
          } else {
            mutable_unknown_fields()->AddVarint(5, value);
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(50)) goto parse_script_args;
        break;
      }

      // repeated bytes script_args = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_script_args:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->add_script_args()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(50)) goto parse_script_args;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void TxOutput::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint32 index = 1;
  if (has_index()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->index(), output);
  }

  // required bytes address = 2;
  if (has_address()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      2, this->address(), output);
  }

  // repeated uint32 address_n = 3;
  for (int i = 0; i < this->address_n_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(
      3, this->address_n(i), output);
  }

  // required uint64 amount = 4;
  if (has_amount()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(4, this->amount(), output);
  }

  // required .ScriptType script_type = 5;
  if (has_script_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      5, this->script_type(), output);
  }

  // repeated bytes script_args = 6;
  for (int i = 0; i < this->script_args_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      6, this->script_args(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* TxOutput::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required uint32 index = 1;
  if (has_index()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->index(), target);
  }

  // required bytes address = 2;
  if (has_address()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        2, this->address(), target);
  }

  // repeated uint32 address_n = 3;
  for (int i = 0; i < this->address_n_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteUInt32ToArray(3, this->address_n(i), target);
  }

  // required uint64 amount = 4;
  if (has_amount()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(4, this->amount(), target);
  }

  // required .ScriptType script_type = 5;
  if (has_script_type()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      5, this->script_type(), target);
  }

  // repeated bytes script_args = 6;
  for (int i = 0; i < this->script_args_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteBytesToArray(6, this->script_args(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int TxOutput::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 index = 1;
    if (has_index()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->index());
    }

    // required bytes address = 2;
    if (has_address()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->address());
    }

    // required uint64 amount = 4;
    if (has_amount()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->amount());
    }

    // required .ScriptType script_type = 5;
    if (has_script_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->script_type());
    }

  }
  // repeated uint32 address_n = 3;
  {
    int data_size = 0;
    for (int i = 0; i < this->address_n_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::
        UInt32Size(this->address_n(i));
    }
    total_size += 1 * this->address_n_size() + data_size;
  }

  // repeated bytes script_args = 6;
  total_size += 1 * this->script_args_size();
  for (int i = 0; i < this->script_args_size(); i++) {
    total_size += ::google::protobuf::internal::WireFormatLite::BytesSize(
      this->script_args(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void TxOutput::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const TxOutput* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const TxOutput*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void TxOutput::MergeFrom(const TxOutput& from) {
  GOOGLE_CHECK_NE(&from, this);
  address_n_.MergeFrom(from.address_n_);
  script_args_.MergeFrom(from.script_args_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_index()) {
      set_index(from.index());
    }
    if (from.has_address()) {
      set_address(from.address());
    }
    if (from.has_amount()) {
      set_amount(from.amount());
    }
    if (from.has_script_type()) {
      set_script_type(from.script_type());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void TxOutput::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void TxOutput::CopyFrom(const TxOutput& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TxOutput::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000001b) != 0x0000001b) return false;

  return true;
}

void TxOutput::Swap(TxOutput* other) {
  if (other != this) {
    std::swap(index_, other->index_);
    std::swap(address_, other->address_);
    address_n_.Swap(&other->address_n_);
    std::swap(amount_, other->amount_);
    std::swap(script_type_, other->script_type_);
    script_args_.Swap(&other->script_args_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata TxOutput::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = TxOutput_descriptor_;
  metadata.reflection = TxOutput_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int DebugLinkDecision::kYesNoFieldNumber;
#endif  // !_MSC_VER

DebugLinkDecision::DebugLinkDecision()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void DebugLinkDecision::InitAsDefaultInstance() {
}

DebugLinkDecision::DebugLinkDecision(const DebugLinkDecision& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void DebugLinkDecision::SharedCtor() {
  _cached_size_ = 0;
  yes_no_ = false;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

DebugLinkDecision::~DebugLinkDecision() {
  SharedDtor();
}

void DebugLinkDecision::SharedDtor() {
  if (this != default_instance_) {
  }
}

void DebugLinkDecision::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* DebugLinkDecision::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return DebugLinkDecision_descriptor_;
}

const DebugLinkDecision& DebugLinkDecision::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_trezor_2eproto();
  return *default_instance_;
}

DebugLinkDecision* DebugLinkDecision::default_instance_ = NULL;

DebugLinkDecision* DebugLinkDecision::New() const {
  return new DebugLinkDecision;
}

void DebugLinkDecision::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    yes_no_ = false;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool DebugLinkDecision::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required bool yes_no = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &yes_no_)));
          set_has_yes_no();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void DebugLinkDecision::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required bool yes_no = 1;
  if (has_yes_no()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(1, this->yes_no(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* DebugLinkDecision::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required bool yes_no = 1;
  if (has_yes_no()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(1, this->yes_no(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int DebugLinkDecision::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required bool yes_no = 1;
    if (has_yes_no()) {
      total_size += 1 + 1;
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void DebugLinkDecision::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const DebugLinkDecision* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const DebugLinkDecision*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void DebugLinkDecision::MergeFrom(const DebugLinkDecision& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_yes_no()) {
      set_yes_no(from.yes_no());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void DebugLinkDecision::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void DebugLinkDecision::CopyFrom(const DebugLinkDecision& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DebugLinkDecision::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void DebugLinkDecision::Swap(DebugLinkDecision* other) {
  if (other != this) {
    std::swap(yes_no_, other->yes_no_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata DebugLinkDecision::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = DebugLinkDecision_descriptor_;
  metadata.reflection = DebugLinkDecision_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int DebugLinkGetState::kLayoutFieldNumber;
const int DebugLinkGetState::kPinFieldNumber;
const int DebugLinkGetState::kMatrixFieldNumber;
const int DebugLinkGetState::kSeedFieldNumber;
#endif  // !_MSC_VER

DebugLinkGetState::DebugLinkGetState()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void DebugLinkGetState::InitAsDefaultInstance() {
}

DebugLinkGetState::DebugLinkGetState(const DebugLinkGetState& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void DebugLinkGetState::SharedCtor() {
  _cached_size_ = 0;
  layout_ = false;
  pin_ = false;
  matrix_ = false;
  seed_ = false;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

DebugLinkGetState::~DebugLinkGetState() {
  SharedDtor();
}

void DebugLinkGetState::SharedDtor() {
  if (this != default_instance_) {
  }
}

void DebugLinkGetState::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* DebugLinkGetState::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return DebugLinkGetState_descriptor_;
}

const DebugLinkGetState& DebugLinkGetState::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_trezor_2eproto();
  return *default_instance_;
}

DebugLinkGetState* DebugLinkGetState::default_instance_ = NULL;

DebugLinkGetState* DebugLinkGetState::New() const {
  return new DebugLinkGetState;
}

void DebugLinkGetState::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    layout_ = false;
    pin_ = false;
    matrix_ = false;
    seed_ = false;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool DebugLinkGetState::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional bool layout = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &layout_)));
          set_has_layout();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_pin;
        break;
      }

      // optional bool pin = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_pin:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &pin_)));
          set_has_pin();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_matrix;
        break;
      }

      // optional bool matrix = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_matrix:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &matrix_)));
          set_has_matrix();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_seed;
        break;
      }

      // optional bool seed = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_seed:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &seed_)));
          set_has_seed();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void DebugLinkGetState::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional bool layout = 1;
  if (has_layout()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(1, this->layout(), output);
  }

  // optional bool pin = 2;
  if (has_pin()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(2, this->pin(), output);
  }

  // optional bool matrix = 3;
  if (has_matrix()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(3, this->matrix(), output);
  }

  // optional bool seed = 4;
  if (has_seed()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(4, this->seed(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* DebugLinkGetState::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional bool layout = 1;
  if (has_layout()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(1, this->layout(), target);
  }

  // optional bool pin = 2;
  if (has_pin()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(2, this->pin(), target);
  }

  // optional bool matrix = 3;
  if (has_matrix()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(3, this->matrix(), target);
  }

  // optional bool seed = 4;
  if (has_seed()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(4, this->seed(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int DebugLinkGetState::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional bool layout = 1;
    if (has_layout()) {
      total_size += 1 + 1;
    }

    // optional bool pin = 2;
    if (has_pin()) {
      total_size += 1 + 1;
    }

    // optional bool matrix = 3;
    if (has_matrix()) {
      total_size += 1 + 1;
    }

    // optional bool seed = 4;
    if (has_seed()) {
      total_size += 1 + 1;
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void DebugLinkGetState::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const DebugLinkGetState* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const DebugLinkGetState*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void DebugLinkGetState::MergeFrom(const DebugLinkGetState& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_layout()) {
      set_layout(from.layout());
    }
    if (from.has_pin()) {
      set_pin(from.pin());
    }
    if (from.has_matrix()) {
      set_matrix(from.matrix());
    }
    if (from.has_seed()) {
      set_seed(from.seed());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void DebugLinkGetState::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void DebugLinkGetState::CopyFrom(const DebugLinkGetState& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DebugLinkGetState::IsInitialized() const {

  return true;
}

void DebugLinkGetState::Swap(DebugLinkGetState* other) {
  if (other != this) {
    std::swap(layout_, other->layout_);
    std::swap(pin_, other->pin_);
    std::swap(matrix_, other->matrix_);
    std::swap(seed_, other->seed_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata DebugLinkGetState::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = DebugLinkGetState_descriptor_;
  metadata.reflection = DebugLinkGetState_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int DebugLinkState::kLayoutFieldNumber;
const int DebugLinkState::kPinFieldNumber;
const int DebugLinkState::kMatrixFieldNumber;
const int DebugLinkState::kSeedFieldNumber;
#endif  // !_MSC_VER

DebugLinkState::DebugLinkState()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void DebugLinkState::InitAsDefaultInstance() {
}

DebugLinkState::DebugLinkState(const DebugLinkState& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void DebugLinkState::SharedCtor() {
  _cached_size_ = 0;
  layout_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  pin_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  matrix_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  seed_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

DebugLinkState::~DebugLinkState() {
  SharedDtor();
}

void DebugLinkState::SharedDtor() {
  if (layout_ != &::google::protobuf::internal::kEmptyString) {
    delete layout_;
  }
  if (pin_ != &::google::protobuf::internal::kEmptyString) {
    delete pin_;
  }
  if (matrix_ != &::google::protobuf::internal::kEmptyString) {
    delete matrix_;
  }
  if (seed_ != &::google::protobuf::internal::kEmptyString) {
    delete seed_;
  }
  if (this != default_instance_) {
  }
}

void DebugLinkState::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* DebugLinkState::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return DebugLinkState_descriptor_;
}

const DebugLinkState& DebugLinkState::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_trezor_2eproto();
  return *default_instance_;
}

DebugLinkState* DebugLinkState::default_instance_ = NULL;

DebugLinkState* DebugLinkState::New() const {
  return new DebugLinkState;
}

void DebugLinkState::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_layout()) {
      if (layout_ != &::google::protobuf::internal::kEmptyString) {
        layout_->clear();
      }
    }
    if (has_pin()) {
      if (pin_ != &::google::protobuf::internal::kEmptyString) {
        pin_->clear();
      }
    }
    if (has_matrix()) {
      if (matrix_ != &::google::protobuf::internal::kEmptyString) {
        matrix_->clear();
      }
    }
    if (has_seed()) {
      if (seed_ != &::google::protobuf::internal::kEmptyString) {
        seed_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool DebugLinkState::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional bytes layout = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_layout()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_pin;
        break;
      }

      // optional bytes pin = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_pin:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_pin()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_matrix;
        break;
      }

      // optional bytes matrix = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_matrix:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_matrix()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_seed;
        break;
      }

      // optional bytes seed = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_seed:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_seed()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void DebugLinkState::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional bytes layout = 1;
  if (has_layout()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      1, this->layout(), output);
  }

  // optional bytes pin = 2;
  if (has_pin()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      2, this->pin(), output);
  }

  // optional bytes matrix = 3;
  if (has_matrix()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      3, this->matrix(), output);
  }

  // optional bytes seed = 4;
  if (has_seed()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      4, this->seed(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* DebugLinkState::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional bytes layout = 1;
  if (has_layout()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        1, this->layout(), target);
  }

  // optional bytes pin = 2;
  if (has_pin()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        2, this->pin(), target);
  }

  // optional bytes matrix = 3;
  if (has_matrix()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        3, this->matrix(), target);
  }

  // optional bytes seed = 4;
  if (has_seed()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        4, this->seed(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int DebugLinkState::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional bytes layout = 1;
    if (has_layout()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->layout());
    }

    // optional bytes pin = 2;
    if (has_pin()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->pin());
    }

    // optional bytes matrix = 3;
    if (has_matrix()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->matrix());
    }

    // optional bytes seed = 4;
    if (has_seed()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->seed());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void DebugLinkState::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const DebugLinkState* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const DebugLinkState*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void DebugLinkState::MergeFrom(const DebugLinkState& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_layout()) {
      set_layout(from.layout());
    }
    if (from.has_pin()) {
      set_pin(from.pin());
    }
    if (from.has_matrix()) {
      set_matrix(from.matrix());
    }
    if (from.has_seed()) {
      set_seed(from.seed());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void DebugLinkState::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void DebugLinkState::CopyFrom(const DebugLinkState& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DebugLinkState::IsInitialized() const {

  return true;
}

void DebugLinkState::Swap(DebugLinkState* other) {
  if (other != this) {
    std::swap(layout_, other->layout_);
    std::swap(pin_, other->pin_);
    std::swap(matrix_, other->matrix_);
    std::swap(seed_, other->seed_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata DebugLinkState::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = DebugLinkState_descriptor_;
  metadata.reflection = DebugLinkState_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
#endif  // !_MSC_VER

DebugLinkStop::DebugLinkStop()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void DebugLinkStop::InitAsDefaultInstance() {
}

DebugLinkStop::DebugLinkStop(const DebugLinkStop& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void DebugLinkStop::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

DebugLinkStop::~DebugLinkStop() {
  SharedDtor();
}

void DebugLinkStop::SharedDtor() {
  if (this != default_instance_) {
  }
}

void DebugLinkStop::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* DebugLinkStop::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return DebugLinkStop_descriptor_;
}

const DebugLinkStop& DebugLinkStop::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_trezor_2eproto();
  return *default_instance_;
}

DebugLinkStop* DebugLinkStop::default_instance_ = NULL;

DebugLinkStop* DebugLinkStop::New() const {
  return new DebugLinkStop;
}

void DebugLinkStop::Clear() {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool DebugLinkStop::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      return true;
    }
    DO_(::google::protobuf::internal::WireFormat::SkipField(
          input, tag, mutable_unknown_fields()));
  }
  return true;
#undef DO_
}

void DebugLinkStop::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* DebugLinkStop::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int DebugLinkStop::ByteSize() const {
  int total_size = 0;

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void DebugLinkStop::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const DebugLinkStop* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const DebugLinkStop*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void DebugLinkStop::MergeFrom(const DebugLinkStop& from) {
  GOOGLE_CHECK_NE(&from, this);
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void DebugLinkStop::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void DebugLinkStop::CopyFrom(const DebugLinkStop& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DebugLinkStop::IsInitialized() const {

  return true;
}

void DebugLinkStop::Swap(DebugLinkStop* other) {
  if (other != this) {
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata DebugLinkStop::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = DebugLinkStop_descriptor_;
  metadata.reflection = DebugLinkStop_reflection_;
  return metadata;
}

::google::protobuf::internal::ExtensionIdentifier< ::google::protobuf::FieldOptions,
    ::google::protobuf::internal::PrimitiveTypeTraits< bool >, 8, false >
  binary(kBinaryFieldNumber, false);

// @@protoc_insertion_point(namespace_scope)

// @@protoc_insertion_point(global_scope)
